     1                                  ; 内核加载器
     2                                  
     3                                  %include "./common/global_defs.asm"
     1                              <1> ; 全局常量定义
     2                              <1> 
     3                              <1> %ifndef _GLOBAL_DEFS_
     4                              <1>     %define _GLOBAL_DEFS_
     5                              <1> 
     6                              <1>     SDA_PHY_ADDR        equ     0x00007e00	; 系统数据区的起始物理地址
     7                              <1>     PML5_PHY_ADDR       equ     0x00009000	; 内核 5 级头表物理地址
     8                              <1>     PML4_PHY_ADDR       equ     0x0000a000	; 内核 4 级头表物理地址
     9                              <1>     PDPT_PHY_ADDR       equ     0x0000b000	; 对应于低端 2MB 的内核页目录指针表物理地址
    10                              <1>     PDT_PHY_ADDR        equ     0x0000c000	; 对应于低端 2MB 的页目录表物理地址
    11                              <1>     PT_PHY_ADDR         equ     0x0000d000	; 对应于低端 2MB 的内核页表的物理地址
    12                              <1>     IDT_PHY_ADDR        equ     0x0000e000	; 中断描述符表的物理地址
    13                              <1>     LDR_PHY_ADDR        equ     0x0000f000	; 用于安装内核加载器的起始物理地址
    14                              <1>     GDT_PHY_ADDR        equ     0x00010000	; 全局描述符表 GDT 的物理地址
    15                              <1>     CORE_PHY_ADDR       equ     0x00020000	; 内核的起始物理地址
    16                              <1>     COR_PDPT_ADDR       equ     0x00100000	; 从这个物理地址开始的 1MB 是内核的 254 个页目录指针表
    17                              <1> 
    18                              <1>     LDR_START_SECTOR    equ     1      	        ; 内核加载器在硬盘上的起始逻辑扇区号
    19                              <1>     COR_START_SECTOR    equ     9      	        ; 内核程序在硬盘上的起始逻辑扇区号
    20                              <1> 
    21                              <1>     ; 虚拟内存空间的高端起始于线性地址 0xffff800000000000
    22                              <1>     UPPER_LINEAR_START  equ     0xffff800000000000  
    23                              <1>     UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	    ; 内核的高端线性地址
    24                              <1>     UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ; 文本显示缓冲区的高端起始线性地址
    25                              <1>     UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	    ; 系统数据区的高端线性地址
    26                              <1>     UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	    ; GDT 的高端线性地址
    27                              <1>     UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	    ; IDT 的高端线性地址
    28                              <1> 
    29                              <1>     ; 与全局描述符表有关的选择子定义, 及内存管理有关的常量定义
    30                              <1>     CORE_CODE64_SEL     equ     0x0018	; 内核代码段的描述符选择子(RPL=00)
    31                              <1>     CORE_STACK64_SEL    equ     0x0020	; 内核栈段的描述符选择子(RPL=00)
    32                              <1>     RESVD_DESC_SEL      equ     0x002b	; 保留的描述符选择子
    33                              <1>     USER_CODE64_SEL     equ     0x003b	; 3 特权级代码段的描述符选择子(RPL=11)
    34                              <1>     USER_STACK64_SEL    equ     0x0033	; 3 特权级栈段的描述符选择子(RPL=11)
    35                              <1> 
    36                              <1>     PHY_MEMORY_SIZE     equ     32    	            ; 物理内存大小(MB), 要求至少 3MB
    37                              <1>     CORE_ALLOC_START    equ     0xffff800000200000	; 在虚拟地址空间高端(内核)分配内存时的起始地址
    38                              <1>     USER_ALLOC_START    equ     0x0000000000000000	; 在每个任务虚拟地址空间低端分配内存时的起始地址
    39                              <1> 
    40                              <1>     ; 创建任务时, 需要分配一个物理页作为新任务的 4 级头表, 并分配一个临时的线性地址来初始化这个页
    41                              <1>     NEW_PML4_LINEAR     equ     0xffffff7ffffff000	; 用来映射新任务 4 级头表的线性地址
    42                              <1>     LAPIC_START_ADDR    equ     0xffffff7fffffe000	; LOCAL APIC 寄存器的起始线性地址
    43                              <1>     IOAPIC_START_ADDR   equ     0xffffff7fffffd000	; I/O APIC 寄存器的起始线性地址
    44                              <1>     AP_START_UP_ADDR    equ     0x0000f000 	        ; 应用处理器(AP)启动代码的物理地址
    45                              <1>     SUGG_PREEM_SLICE    equ     55          	    ; 推荐的任务/线程抢占时间片长度(毫秒)
    46                              <1> 
    47                              <1>     ; 多处理器环境下的自旋锁加锁宏。需要两个参数: 寄存器, 以及一个对应宽度的锁变量
    48                              <1>     %macro  SET_SPIN_LOCK 2             ; 两个参数, 分别是寄存器 %1 和锁变量 %2
    49                              <1>             %%spin_lock:
    50                              <1>                     cmp %2, 0           ; 看一眼锁现在是不是 0
    51                              <1>                     je %%get_lock      	; 如果是 0，说明没人占，跳过去抢
    52                              <1>                     pause				; 不是 0，先喘口气（降低 CPU 占用）, 见书中 341 页
    53                              <1>                     jmp %%spin_lock    	; 继续看
    54                              <1>             %%get_lock:
    55                              <1>                     mov %1, 1
    56                              <1>                     xchg %1, %2         ; 用 xchg 的“原子交换”能力抢锁，抢不到就一直循环（自旋）
    57                              <1>                     cmp %1, 0          	; 交换回来的 %2 旧值是 0 吗？
    58                              <1>                     jne %%spin_lock   	; 不是 0 说明别人先插了旗，回到开头重抢
    59                              <1>     %endmacro
    60                              <1> 
    61                              <1> %endif
     4                                  
     5                                  SECTION loader
     6 00000000 6C696E6F                    marker          dd "lino"           ; 内核加载器有效标志    +00 将老师的 lizh, 改为了 lino, hh
     7 00000004 [00000000]                  length          dd ldr_end          ; 内核加载器的长度      +04
     8 00000008 [A8010000]                  entry           dd start            ; 内核加载器的入口点    +08
     9                                  
    10 0000000C 4D6F7573654865726F-         msg0            db "MouseHero x64 course learning.", 0x0d, 0x0a
    10 00000015 2078363420636F7572-
    10 0000001E 7365206C6561726E69-
    10 00000027 6E672E0D0A         
    11                                  
    12 0000002C 78363420617661696C-         arch0           db "x64 available(64-bit processor installed).", 0x0d, 0x0a
    12 00000035 61626C652836342D62-
    12 0000003E 69742070726F636573-
    12 00000047 736F7220696E737461-
    12 00000050 6C6C6564292E0D0A   
    13 00000058 783634206E6F742061-         arch1           db "x64 not available(64-bit processor not installed).", 0x0d, 0x0a
    13 00000061 7661696C61626C6528-
    13 0000006A 36342D626974207072-
    13 00000073 6F636573736F72206E-
    13 0000007C 6F7420696E7374616C-
    13 00000085 6C6564292E0D0A     
    14                                  
    15                                      ; 汇编版格式化字符串
    16 0000008C 50726F636573736F72-         brand_mag       db "Processor:"
    16 00000095 3A                 
    17 00000096 00<rep 30h>                     brand       times 48 db 0
    18 000000C6 0D0A                                        db 0x0d, 0x0a
    19                                  
    20 000000C8 506879736963616C20-         cpu_addr        db "Physical address size:"
    20 000000D1 616464726573732073-
    20 000000DA 697A653A           
    21 000000DE 20<rep 3h>                      paddr       times 3 db " "
    22 000000E1 2C                                          db ","
    23 000000E2 4C696E656172206164-                         db "Linear address size:"
    23 000000EB 64726573732073697A-
    23 000000F4 653A               
    24 000000F6 20<rep 3h>                      laddr       times 3 db " "
    25 000000F9 0D0A                                        db 0x0d, 0x0a
    26                                  
    27 000000FB 50726F74656374206D-         protect         db "Protect mode has been entered to prepare for IA-32e mode.", 0x0d, 0x0a, 0
    27 00000104 6F6465206861732062-
    27 0000010D 65656E20656E746572-
    27 00000116 656420746F20707265-
    27 0000011F 7061726520666F7220-
    27 00000128 49412D333265206D6F-
    27 00000131 64652E0D0A00       
    28                                  
    29 00000137 49412D333265206D6F-         ia_32e          db "IA-32e mode(aka,long mode) is active.Specifically,"
    29 00000140 646528616B612C6C6F-
    29 00000149 6E67206D6F64652920-
    29 00000152 697320616374697665-
    29 0000015B 2E5370656369666963-
    29 00000164 616C6C792C         
    30 00000169 636F6D706174696269-                         db "compatibility mode.", 0x0d, 0x0a, 0
    30 00000172 6C697479206D6F6465-
    30 0000017B 2E0D0A00           
    31                                  
    32                                  ; ------------------------------------------------------------
    33                                  ; put_string_by_bios
    34                                  ; 功能: 在光标当前位置按指定颜色打印字符串, 内平栈
    35                                  ; 输入: 字符串地址, 长度, 颜色属性
    36                                  ; ------------------------------------------------------------
    37                                  put_string_by_bios:
    38 0000017F B403                        mov ah, 0x03                        ; 获取光标位置
    39 00000181 B700                        mov bh, 0x00
    40 00000183 CD10                        int 0x10                            ; 返回 dh=行, dl=列
    41                                  
    42 00000185 678B6C2402                  mov bp, [esp + 2]                   ; 字符串地址       
    43 0000018A 678B4C2404                  mov cx, [esp + 4]                   ; 长度    
    44 0000018F 678B5C2406                  mov bx, [esp + 6]                   ; 颜色属性
    45 00000194 B80113                      mov ax, 0x1301                      ; 写字符串, 光标移动
    46 00000197 CD10                        int 0x10
    47                                  
    48 00000199 C20600                      ret 6
    49                                  
    50                                  no_ia_32e:
    51 0000019C 6A4F                        push 0x004f
    52 0000019E 6A34                        push brand_mag - arch1
    53 000001A0 68[5800]                    push arch1
    54 000001A3 E8D9FF                      call put_string_by_bios
    55                                  
    56 000001A6 FA                          cli
    57 000001A7 F4                          hlt
    58                                  
    59                                  start:
    60 000001A8 6A4F                        push 0x004f
    61 000001AA 6A20                        push arch0 - msg0
    62 000001AC 68[0C00]                    push msg0
    63 000001AF E8CDFF                      call put_string_by_bios
    64                                  
    65                                      ; 检查处理器是否支持 ia-32e 模式
    66 000001B2 66B800000080                mov eax, 0x80000000                 ; 返回处理器支持的最大扩展功能号
    67 000001B8 0FA2                        cpuid                               ; 返回值在 eax 中
    68 000001BA 663D01000080                cmp eax, 0x80000001
    69 000001C0 72DA                        jb no_ia_32e                        ; 不支持就到 no_ia_32e 处执行
    70                                  
    71 000001C2 66B801000080                mov eax, 0x80000001                 ; edx 返回扩展的签名和特性标志位
    72 000001C8 0FA2                        cpuid
    73 000001CA 660FBAE21D                  bt edx, 29                          ; 低 29 位是 IA-32e 模式支持标志, bt 指令会影响 cf  标志位
    74 000001CF 73CB                        jnc no_ia_32e                       ; 不支持就到 no_ia_32e 处执行
    75                                  
    76 000001D1 6A07                        push 0x0007                         ; 黑底白字
    77 000001D3 6A2C                        push arch1 - arch0
    78 000001D5 68[2C00]                    push arch0
    79 000001D8 E8A4FF                      call put_string_by_bios
    80                                  
    81                                      ; 显示处理器商标信息
    82 000001DB 66B800000080                mov eax, 0x80000000 
    83 000001E1 0FA2                        cpuid
    84 000001E3 663D04000080                cmp eax, 0x80000004
    85 000001E9 725B                        jb .no_brand
    86                                  
    87 000001EB 66B802000080                mov eax, 0x80000002
    88 000001F1 0FA2                        cpuid
    89 000001F3 66A3[9600]                  mov [brand + 0x00], eax
    90 000001F7 66891E[9A00]                mov [brand + 0x04], ebx
    91 000001FC 66890E[9E00]                mov [brand + 0x08], ecx
    92 00000201 668916[A200]                mov [brand + 0x0c], edx
    93                                  
    94 00000206 66B803000080                mov eax, 0x80000003
    95 0000020C 0FA2                        cpuid
    96 0000020E 66A3[A600]                  mov [brand + 0x10], eax
    97 00000212 66891E[AA00]                mov [brand + 0x14], ebx
    98 00000217 66890E[AE00]                mov [brand + 0x18], ecx
    99 0000021C 668916[B200]                mov [brand + 0x1c], edx
   100                                  
   101 00000221 66B804000080                mov eax, 0x80000004
   102 00000227 0FA2                        cpuid
   103 00000229 66A3[B600]                  mov [brand + 0x20], eax
   104 0000022D 66891E[BA00]                mov [brand + 0x24], ebx
   105 00000232 66890E[BE00]                mov [brand + 0x28], ecx
   106 00000237 668916[C200]                mov [brand + 0x2c], edx
   107                                  
   108 0000023C 6A07                        push 0x0007
   109 0000023E 6A3C                        push cpu_addr - brand_mag
   110 00000240 68[8C00]                    push brand_mag
   111 00000243 E839FF                      call put_string_by_bios
   112                                  
   113                                  .no_brand:
   114                                      ; 获取当前系统的物理内存布局信息(使用 int 0x15, E820 功能。俗称 E820 内存), 详情见书中 268 页
   115 00000246 06                          push es 
   116                                  
   117 00000247 BBE007                      mov bx, SDA_PHY_ADDR >> 4               ; 切换到系统数据区
   118 0000024A 8EC3                        mov es, bx 
   119 0000024C 26C70616000000              mov word [es:0x16], 0                   ; 将地址描述结构的数量初始化为 0
   120 00000253 6631DB                      xor ebx, ebx                            ; 首次调用 int 0x15 时必须为 0
   121 00000256 BF1800                      mov di, 0x18                            ; 系统数据区内的偏移
   122                                  
   123                                  .mlookup:
   124 00000259 66B820E80000                mov eax, 0xe820
   125 0000025F 66B920000000                mov ecx, 32                             ; 地址描述结构的长度
   126 00000265 66BA50414D53                mov edx, "PAMS"
   127 0000026B CD15                        int 0x15
   128 0000026D 83C720                      add di, 32                              ; 写入 rs:di 中, 增加 di 偏移
   129 00000270 26FF061600                  inc word [es:0x16]
   130 00000275 6609DB                      or ebx, ebx                             ; 若 ebx 为 0, 意味着是最后一个地址数据
   131 00000278 75DF                        jnz .mlookup
   132                                  
   133 0000027A 07                          pop es
   134                                  
   135                                      ; 获取存储处理器的物理/虚拟地址尺寸信息
   136 0000027B 66B800000080                mov eax, 0x80000000                     
   137 00000281 0FA2                        cpuid
   138 00000283 663D08000080                cmp eax, 0x80000008
   139 00000289 B82430                      mov ax, 0x3024                          ; 设置默认的处理器物理/逻辑地址位数 36(0x24) 和 48(0x30)
   140 0000028C 7208                        jb .no_plsize
   141                                  
   142 0000028E 66B808000080                mov eax, 0x80000008                     ; 执行后, ax 中 0-7 位(al)是物理地址尺寸, 8-15 位(ah)是虚拟地址尺寸
   143 00000294 0FA2                        cpuid
   144                                  
   145                                  .no_plsize:
   146                                      ; 保存物理和虚拟地址尺寸到系统数据区
   147 00000296 1E                          push ds 
   148 00000297 BBE007                      mov bx, SDA_PHY_ADDR >> 4               ; 切换到系统数据区
   149 0000029A 8EDB                        mov ds, bx 
   150 0000029C A30000                      mov word [0], ax                        ; 记录处理器的物理/虚拟地址尺寸
   151 0000029F 1F                          pop ds 
   152                                  
   153                                      ; 准备显示存储器的物理地址尺寸信息
   154 000002A0 50                          push ax                                 ; 备份 ax
   155                                  
   156 000002A1 25FF00                      and ax, 0x00ff                          ; 只要 al 中的物理地址
   157 000002A4 BE0200                      mov si, 2
   158 000002A7 B30A                        mov bl, 10
   159                                  
   160                                  .re_div0:
   161 000002A9 F6F3                        div bl                                  ; 16 位除法, 商在 al 中, 余数在 ah 里
   162 000002AB 80C430                      add ah, 0x30                            ; ASCII 码
   163 000002AE 88A4[DE00]                  mov [paddr + si], ah                    ; 低位在高地址
   164 000002B2 4E                          dec si 
   165 000002B3 25FF00                      and ax, 0x00ff
   166 000002B6 75F1                        jnz .re_div0
   167                                  
   168                                      ; 准备显示处理器的虚拟地址尺寸信息
   169 000002B8 58                          pop ax 
   170                                  
   171 000002B9 C1E808                      shr ax, 8                               ; 将虚拟地址移到 al 重复上边的逻辑
   172 000002BC BE0200                      mov si, 2
   173 000002BF B30A                        mov bl, 10
   174                                  .re_div1:
   175 000002C1 F6F3                        div bl 
   176 000002C3 80C430                      add ah, 0x30 
   177 000002C6 88A4[F600]                  mov [laddr + si], ah 
   178 000002CA 4E                          dec si 
   179 000002CB 25FF00                      and ax, 0x00ff
   180 000002CE 75F1                        jnz .re_div1
   181                                  
   182                                      ; 显示处理器的物理/虚拟地址尺寸信息 
   183 000002D0 6A07                        push 0x0007
   184 000002D2 6A33                        push protect - cpu_addr
   185 000002D4 68[C800]                    push cpu_addr
   186 000002D7 E8A5FE                      call put_string_by_bios
   187                                  
   188                                      ; 以下开始进入保护模式, 为 IA-32e 模式做必要的准备工作
   189 000002DA B80010                      mov ax, GDT_PHY_ADDR >> 4               ; 计算 GDT 所在的逻辑段地址
   190 000002DD 8ED8                        mov ds, ax 
   191                                  
   192                                      ; 跳过 0# 号描述符的槽位, 处理器规定 0# 号描述符为空
   193                                      
   194                                      ; 创建 1# 描述符, 保护模式下的代码段描述符
   195 000002DF 66C7060800FFFF0000          mov dword [0x08], 0x0000ffff            ; 基地址为0, 界限0xFFFFF, DPL=00, 4KB 粒度, 代码段描述符, 向上扩展
   196 000002E8 66C7060C000098CF00          mov dword [0x0c], 0x00cf9800
   197                                      
   198                                      ; 创建 2# 描述符, 保护模式下的数据段和堆栈段描述符
   199 000002F1 66C7061000FFFF0000          mov dword [0x10], 0x0000ffff            ; 基地址为0, 界限0xFFFFF, DPL=00, 4KB 粒度, 数据段描述符, 向上扩展
   200 000002FA 66C70614000092CF00          mov dword [0x14], 0x00cf9200
   201                                  
   202                                      ; 创建 3# 描述符, 64 位模式下的代码段描述符。为进入 64 位提前作准备, 其 L 位是 1
   203 00000303 66C7061800FFFF0000          mov dword [0x18], 0x0000ffff            ; 基地址为0, 界限0xFFFFF, DPL=00, 4KB 粒度, L=1, 代码段描述符, 向上扩展
   204 0000030C 66C7061C000098AF00          mov dword [0x1c], 0x00af9800
   205                                  
   206                                      ; 记录 GDT 的基地址和界限值
   207 00000315 B8E007                      mov ax, SDA_PHY_ADDR >> 4               ; 切换到系统数据区
   208 00000318 8ED8                        mov ds, ax  
   209                                  
   210 0000031A C70602001F00                mov word[2], 0x1f                       ; 描述符表的界限
   211 00000320 66C706040000000100          mov dword[4], GDT_PHY_ADDR              ; GDT 的线性基地址
   212                                  
   213                                      ; 将 gdt 表的地址加载到 GDTR 寄存器
   214 00000329 0F01160200                  lgdt [2]
   215                                  
   216 0000032E E492                        in al, 0x92                             ; 南桥芯片内的端口
   217 00000330 0C02                        or al, 0000_0010B
   218 00000332 E692                        out 0x92, al                            ; 打开处理器的第 21 根地址线 A20
   219                                  
   220 00000334 FA                          cli                                     ; 关闭中断
   221                                  
   222 00000335 0F20C0                      mov eax, cr0                            ; 设置控制寄存器 CR0 的 PE 位, 将处理器从实模式切换到保护模式。
   223 00000338 6683C801                    or eax, 1
   224 0000033C 0F22C0                      mov cr0, eax 
   225                                  
   226                                      ; 以下进入保护模式
   227 0000033F 66EA[47F30000]0800          jmp 0x0008: dword LDR_PHY_ADDR + flush  ; 0x0008 是 16 位描述符选择子, 从 GDT 中选择第二个描述符。jmp 后清流水线并串行化处理器, 跳转到 flush
   228                                  
   229                                      [bits 32]
   230                                  flush:
   231 00000347 B810000000                  mov eax, 0x0010                         ; 加载数据段(4GB)选择子
   232 0000034C 8ED8                        mov ds, eax
   233 0000034E 8EC0                        mov es, eax
   234 00000350 8EE0                        mov fs, eax
   235 00000352 8EE8                        mov gs, eax
   236 00000354 8ED0                        mov ss, eax  
   237 00000356 BC007C0000                  mov esp, 0x7c00                         ; 堆栈指针
   238                                  
   239                                      ; 显示信息, 在保护模式下位进入 IA-32e 模式做准备
   240 0000035B BB[FBF00000]                mov ebx, LDR_PHY_ADDR + protect
   241 00000360 E863010000                  call put_string_flat32
   242                                  
   243                                      ; 以下加载系统核心程序
   244 00000365 BF00000200                  mov edi, CORE_PHY_ADDR
   245                                  
   246 0000036A B809000000                  mov eax, COR_START_SECTOR
   247 0000036F 89FB                        mov ebx, edi                            ; 起始地址
   248 00000371 E8FD010000                  call read_hard_disk_0                   ; 读取程序起始第一个扇区
   249                                  
   250                                      ; 判断程序大小
   251 00000376 8B07                        mov eax, [edi]                          ; 内核程序大小
   252 00000378 31D2                        xor edx, edx 
   253 0000037A B900020000                  mov ecx, 512                            ; 每个扇区大小为 512
   254 0000037F F7F1                        div ecx                                 ; 商存储在 eax 中, 余数存储在 edx 中
   255                                  
   256                                      ; 处理长度 < 512 字节的情况
   257 00000381 09C0                        or eax, eax 
   258 00000383 7419                        jz pge
   259                                      ; 处理长度 >= 512 字节的情况
   260 00000385 09D2                        or edx, edx 
   261 00000387 7505                        jnz @1
   262 00000389 48                          dec eax 
   263 0000038A 09C0                        or eax, eax                             ; 正好为 512 时, 单独处理
   264 0000038C 7410                        jz pge
   265                                  @1:
   266                                      ; 读取剩余扇区
   267 0000038E 89C1                        mov ecx, eax                            ; 循环次数
   268 00000390 B809000000                  mov eax, COR_START_SECTOR
   269 00000395 40                          inc eax 
   270                                  @2:
   271 00000396 E8D8010000                  call read_hard_disk_0
   272 0000039B 40                          inc eax
   273 0000039C E2F8                        loop @2
   274                                  
   275                                  pge:
   276                                      ; 回填内核加载地址的物理地址到内核程序头部
   277 0000039E C70508000200000002-         mov dword [CORE_PHY_ADDR + 0x08], CORE_PHY_ADDR
   277 000003A7 00                 
   278 000003A8 C7050C000200000000-         mov dword [CORE_PHY_ADDR + 0x0c], 0
   278 000003B1 00                 
   279                                  
   280                                      ; 创建 4 级分页系统, 只包含基本部分, 覆盖低端 1 MB物理内存
   281 000003B2 BB00A00000                  mov ebx, PML4_PHY_ADDR                  ; 找个地方存四级页表
   282                                  
   283                                      ; 4 级页表清零
   284 000003B7 B900040000                  mov ecx, 1024
   285 000003BC 31F6                        xor esi, esi 
   286                                  .cls0:
   287 000003BE C7043300000000              mov dword [ebx + esi], 0
   288 000003C5 83C604                      add esi, 4
   289 000003C8 E2F4                        loop .cls0
   290                                  
   291                                      ; 在 4 级页表内最后一项存放自身地址, 这样可以通过虚拟地址访问表中最后一项来获取页表的真实地址
   292 000003CA C783F80F000003A000-         mov dword [ebx + 511 * 8], PML4_PHY_ADDR | 3    ; 添加属性
   292 000003D3 00                 
   293 000003D4 C783FC0F0000000000-         mov dword [ebx + 511 * 8 + 4], 0
   293 000003DD 00                 
   294                                  
   295                                      ; 映射虚拟地址与物理地址的低端 2 MB, 确保开启分页后也可以正常访问, 即地址经过页表转换后不变。
   296                                      ; 0x0000000000000000--0x00000000001FFFFF 低 48 位按 9 9 9 9 12 分割进行四级分页查表。而高 16 位无效, 填充符号位
   297 000003DE C70303B00000                mov dword [ebx + 0 * 8], PDPT_PHY_ADDR  | 3     ; 添加属性
   298 000003E4 C7430400000000              mov dword [ebx + 0 * 8 + 4], 0
   299                                  
   300                                      ; 将页目录指针表中的内容清 0
   301 000003EB BB00B00000                  mov ebx, PDPT_PHY_ADDR
   302                                  
   303 000003F0 B900040000                  mov ecx, 1024
   304 000003F5 31F6                        xor esi, esi 
   305                                  .cls1:
   306 000003F7 C7043300000000              mov dword [ebx + esi], 0
   307 000003FE 83C604                      add esi, 4
   308 00000401 E2F4                        loop .cls1
   309                                  
   310                                      ; 套娃, 创建下一级页表
   311 00000403 C70303C00000                mov dword [ebx + 0 * 8], PDT_PHY_ADDR | 3
   312 00000409 C7430400000000              mov dword [ebx + 0 * 8 + 4], 0
   313                                  
   314                                      ; 清 0
   315 00000410 BB00C00000                  mov ebx, PDT_PHY_ADDR
   316                                  
   317 00000415 B900040000                  mov ecx, 1024
   318 0000041A 31F6                        xor esi, esi
   319                                  .cls2:
   320 0000041C C7043300000000              mov dword [ebx + esi], 0
   321 00000423 83C604                      add esi, 4
   322 00000426 E2F4                        loop .cls2
   323                                  
   324                                      ; 在页目录表内创建与低端 2MB 对应的表项
   325 00000428 C70383000000                mov dword [ebx + 0 * 8], 0 | 0x83       ; 位 7、R/W 位、P 位是 1, 其他全是 0
   326 0000042E C7430400000000              mov dword [ebx + 0 * 8 + 4], 0
   327                                  
   328                                      ; 将物理内存的低端 2MB 映射到线性地址空间的高端, 内核处于高地址, 要做一次重复映射。0xFFFF800000000000--0xFFFF8000001FFFFF
   329 00000435 BB00A00000                  mov ebx, PML4_PHY_ADDR
   330                                  
   331 0000043A C7830008000003B000-         mov dword [ebx + 256 * 8], PDPT_PHY_ADDR | 3 ; 页目录表
   331 00000443 00                 
   332 00000444 C78304080000000000-         mov dword [ebx + 256 * 8 + 4], 0
   332 0000044D 00                 
   333                                  
   334                                      ; 因为要为每个进程都给予一个独立的 4 级头表(可以理解为指针数组), 而内核空间是所有进程共享的, 要在每个进程独立
   335                                      ; 的 4 级头表中内核公共部分填入一样的数据。页表机制的一个特点是 就是动态分配, 用时间换空间, 为了避免此特性使
   336                                      ; 每个进程不停的去同步 4 级头表中内核公共部分, 索性直接将 4 级头表中内核公共部分全部预分配好。详细解释见书中 135 页。
   337 0000044E B801010000                  mov eax, 257
   338 00000453 BA03001000                  mov edx, COR_PDPT_ADDR | 3
   339                                  .fill_pml4:
   340 00000458 8914C3                      mov dword [ebx + eax * 8], edx 
   341 0000045B C744C30400000000            mov dword [ebx + eax * 8 + 4], 0
   342 00000463 81C200100000                add edx, 0x1000
   343 00000469 40                          inc eax 
   344 0000046A 3DFF010000                  cmp eax, 511
   345 0000046F 72E7                        jb .fill_pml4
   346                                  
   347                                      ; 将预分配的页目录指针表全部清零
   348 00000471 B800001000                  mov eax, COR_PDPT_ADDR
   349                                  .zero_pdpt:
   350 00000476 C70000000000                mov dword [eax], 0
   351 0000047C 83C004                      add eax, 4
   352 0000047F 3D00E01F00                  cmp eax, COR_PDPT_ADDR + 0x1000 * 254
   353 00000484 72F0                        jb .zero_pdpt
   354                                  
   355                                      ; 将 cr3 寄存器指向 4 级头表
   356 00000486 B800A00000                  mov eax, PML4_PHY_ADDR
   357 0000048B 0F22D8                      mov cr3, eax 
   358                                  
   359                                      ; 开启物理扩展 PAE
   360 0000048E 0F20E0                      mov eax, cr4 
   361 00000491 0FBAE805                    bts eax, 5                              ; 位测试并置位
   362 00000495 0F22E0                      mov cr4, eax 
   363                                  
   364                                      ; 设置型号专属寄存器 IA32_EFER.LME, 允许 IA_32e 模式
   365 00000498 B9800000C0                  mov ecx, 0x0c0000080                    ; 指定型号专属寄存器 IA32_EFER
   366 0000049D 0F32                        rdmsr
   367 0000049F 0FBAE808                    bts eax, 8                              ; 设置 LME 位
   368 000004A3 0F30                        wrmsr 
   369                                  
   370                                      ; 开启分页功能
   371 000004A5 0F20C0                      mov eax, cr0 
   372 000004A8 0FBAE81F                    bts eax, 31                             ; 置位 cr0.PG
   373 000004AC 0F22C0                      mov cr0, eax 
   374                                  
   375                                      ; 打印 IA_32e 激活信息
   376 000004AF BB[37F10000]                mov ebx, ia_32e + LDR_PHY_ADDR
   377 000004B4 E80F000000                  call put_string_flat32
   378                                  
   379                                      ; 通过远返回的方式进入 64 位模式内核
   380 000004B9 666A18                      push word CORE_CODE64_SEL
   381 000004BC A104000200                  mov eax, dword [CORE_PHY_ADDR + 4]
   382 000004C1 0500000200                  add eax, CORE_PHY_ADDR
   383 000004C6 50                          push eax 
   384 000004C7 CB                          retf                                    ; 压入 GDT 选择子和地址
   385                                  
   386                                  ; ------------------------------------------------------------
   387                                  ; put_string_flat32
   388                                  ; 功能: 显示 0 终止的字符串并移动光标。只运行在32位保护模式下, 且使用平坦模型。
   389                                  ; 输入: EBX=字符串的线性地址
   390                                  ; ------------------------------------------------------------
   391                                  put_string_flat32:
   392 000004C8 53                          push ebx 
   393 000004C9 51                          push ecx 
   394                                  .getc:
   395 000004CA 8A0B                        mov cl, [ebx]
   396 000004CC 08C9                        or cl, cl                               ; 检测串结束标志 0
   397 000004CE 7408                        jz .exit                                
   398 000004D0 E806000000                  call put_char
   399 000004D5 43                          inc ebx 
   400 000004D6 EBF2                        jmp .getc
   401                                  
   402                                  .exit:
   403 000004D8 59                          pop ecx 
   404 000004D9 5B                          pop ebx 
   405                                  
   406 000004DA C3                          ret 
   407                                  
   408                                  ; ------------------------------------------------------------
   409                                  ; put_char
   410                                  ; 功能: 在当前光标处显示一个字符, 并推进光标, 仅用于段内调用
   411                                  ; 输入: CL=字符ASCII码
   412                                  ; ------------------------------------------------------------
   413                                  put_char:
   414 000004DB 60                          pushad 
   415                                  
   416 000004DC 66BAD403                    mov dx, 0x3d4                           ; 0x3d4 是 VGA 显卡的索引寄存器端口地址, 用于指定要操作的显卡寄存器。
   417 000004E0 B00E                        mov al, 0xe                             ; 0xe 是显卡的光标位置寄存器的索引值, 用于读取光标的高字节位置。
   418 000004E2 EE                          out dx, al                              ; 将 0xe 输出到端口 0x3d4, 
   419 000004E3 6642                        inc dx                                  ; 0x3d5 是显卡的数据寄存器端口地址, 用于读取或写入显卡寄存器的实际数据。
   420 000004E5 EC                          in al, dx                               ; 从端口 0x3d5 读取数据到 al, 读取了光标位置的高字节
   421                                  
   422 000004E6 88C4                        mov ah, al                              ; 存入 ah 
   423                                  
   424 000004E8 664A                        dec dx                                  ; 同上, 再获取低字节
   425 000004EA B00F                        mov al, 0x0f                            ; 0x0f 是显卡的光标位置寄存器的索引值, 用于读取光标的低字节位置。
   426 000004EC EE                          out dx, al 
   427 000004ED 6642                        inc dx 
   428 000004EF EC                          in al, dx 
   429                                  
   430 000004F0 6689C3                      mov bx, ax                              ; 此时 bx 中存储了字符的数目, 一个字符占两个字节
   431 000004F3 81E2FFFF0000                and edx, 0x0000ffff
   432                                  
   433 000004F9 80F90D                      cmp cl, 0x0d                            ; 回车符?
   434 000004FC 750E                        jnz .put_0a                             ; 不是回车符检查是不是换行符(0x0a)
   435                                  
   436 000004FE 6689D8                      mov ax, bx                              ; 处理回车符
   437 00000501 B350                        mov bl, 80                              ; 行宽 80
   438 00000503 F6F3                        div bl 
   439 00000505 F6E3                        mul bl                                  ; 移到本行起始
   440 00000507 6689C3                      mov bx, ax 
   441 0000050A EB19                        jmp .roll_screen
   442                                  
   443                                  .put_0a:
   444 0000050C 80F90A                      cmp cl, 0x0a                            ; 换行符?
   445 0000050F 7506                        jnz .put_other
   446                                  
   447 00000511 6683C350                    add bx, 80                              ; 处理换行符
   448 00000515 EB0E                        jmp .roll_screen
   449                                  
   450                                  .put_other:                                 ; 显示字符
   451 00000517 66D1E3                      shl bx, 1                               ; 在文本模式下, 显存中每个字符占用 2 个字节, 左移 1 位相当于将 bx 的值乘以 2, 从而将光标位置从字符索引转换为显存中的字节偏移量。
   452 0000051A 888B00800B00                mov [0xb8000 + ebx], cl                 ; 0xb800:0000(0xb8000) 是显存的起始地址
   453                                  
   454 00000520 66D1EB                      shr bx, 1                               ; 将光标位置移到下一个字符
   455 00000523 6643                        inc bx      
   456                                  
   457                                  .roll_screen:
   458 00000525 6681FBD007                  cmp bx, 2000                            ; 超出屏幕外? 
   459 0000052A 7C2F                        jl .set_cursor                          ; 设置光标
   460                                  
   461                                      ; 滚屏处理
   462 0000052C 53                          push ebx                                ; 保存光标位置               
   463                                  
   464 0000052D FC                          cld                                     ; 清除方向标志
   465 0000052E BEA0800B00                  mov esi, 0xb80a0                        ; 0xb80a0 是显存中第 2 行字符的起始地址。源地址
   466 00000533 BF00800B00                  mov edi, 0xb8000                        ; 0xb8000 是显存起始地址。目标地址
   467 00000538 B9C0030000                  mov ecx, 960                            ; 960 == 24 x 80 x 2 / 4, 滚屏操作需要将第 2 行到第 25 行的内容向上移动一行, 覆盖第 1 行的内容。
   468 0000053D F3A5                        rep movsd                               ; rep movsd 会根据 ecx 的值重复移动数据, 直到 ecx 为 0。每次移动 4 个字节
   469                                      
   470                                      ; 清除屏幕最后一行
   471 0000053F BB000F0000                  mov ebx, 3840                           ; 3840 == 24 x 80 x 2, 设置光标位置为屏幕最后一行的起始位置。
   472 00000544 B950000000                  mov ecx, 80                             ; ecx 是循环次数
   473                                  
   474                                  .cls:
   475 00000549 66C78300800B002007          mov word[0xb8000 + ebx], 0x0720         ; 0x0720 是空格字符, 黑色背景
   476 00000552 83C302                      add ebx, 2
   477 00000555 E2F2                        loop .cls 
   478                                  
   479 00000557 5B                          pop ebx                                 ; 恢复光标
   480 00000558 83EB50                      sub ebx, 80                             ; 上移一行
   481                                  
   482                                  .set_cursor:                                ; 设置光标
   483 0000055B 66BAD403                    mov dx, 0x3d4
   484 0000055F B00E                        mov al, 0x0e
   485 00000561 EE                          out dx, al
   486 00000562 6642                        inc dx 
   487 00000564 88F8                        mov al, bh 
   488 00000566 EE                          out dx, al 
   489                                  
   490 00000567 664A                        dec dx 
   491 00000569 B00F                        mov al, 0x0f
   492 0000056B EE                          out dx, al 
   493 0000056C 6642                        inc dx 
   494 0000056E 88D8                        mov al, bl 
   495 00000570 EE                          out dx, al 
   496                                  
   497 00000571 61                          popad 
   498 00000572 C3                          ret 
   499                                  
   500                                  ; ------------------------------------------------------------
   501                                  ; read_hard_disk_0
   502                                  ; 功能: 从硬盘中读取一个扇区
   503                                  ; 输入: eax=逻辑扇区号, ebx=目标缓冲区地址
   504                                  ; 返回: ebx = ebx + 512
   505                                  ; ------------------------------------------------------------
   506                                  read_hard_disk_0:
   507 00000573 50                          push eax
   508 00000574 51                          push ecx
   509 00000575 52                          push edx 
   510                                  
   511 00000576 50                          push eax 
   512                                  
   513 00000577 66BAF201                    mov dx, 0x1f2                           ; 0x1f2 是硬盘控制器的一个端口地址, 用于指定要读取的扇区数量。
   514 0000057B B001                        mov al, 1
   515 0000057D EE                          out dx, al                              ; 将 1 写入到硬盘控制器的端口 0x1f2, 告诉硬盘控制器接下来要读取一个扇区。
   516                                  
   517 0000057E 6642                        inc dx                                  ; 0x1f3
   518 00000580 58                          pop eax 
   519 00000581 EE                          out dx, al                              ; LBA 地址 7 ~ 0
   520                                  
   521 00000582 6642                        inc dx                                  ; 0x1f4
   522 00000584 B108                        mov cl, 8
   523 00000586 D3E8                        shr eax, cl 
   524 00000588 EE                          out dx, al                              ; LBA 地址 15 ~ 8
   525                                  
   526 00000589 6642                        inc dx                                  ; 0x1f5
   527 0000058B D3E8                        shr eax, cl 
   528 0000058D EE                          out dx, al                              ; LBA 地址 23 ~ 16
   529                                  
   530 0000058E 6642                        inc dx                                  ; 0x1f6
   531 00000590 D3E8                        shr eax, cl 
   532 00000592 0CE0                        or al, 0xe0                             ; 第一硬盘
   533 00000594 EE                          out dx, al                              ; LBA 地址 27 ~ 24
   534                                  
   535 00000595 6642                        inc dx                                  ; 0x1f7
   536 00000597 B020                        mov al, 0x20    
   537 00000599 EE                          out dx, al                              ; 读命令
   538                                  
   539                                  .waits:
   540 0000059A EC                          in al, dx 
   541 0000059B A808                        test al, 8
   542 0000059D 74FB                        jz .waits                               ; 忙或数据还没准备好, 循环查询
   543                                  
   544 0000059F B900010000                  mov ecx, 256                            ; 总共要读取的字数, 循环次数
   545 000005A4 66BAF001                    mov dx, 0x1f0
   546                                  
   547                                  .readw:
   548 000005A8 66ED                        in ax, dx                               ; 循环去读硬盘数据写入指定内存
   549 000005AA 668903                      mov [ebx], ax 
   550 000005AD 83C302                      add ebx, 2
   551 000005B0 E2F6                        loop .readw
   552                                  
   553 000005B2 5A                          pop edx 
   554 000005B3 59                          pop ecx 
   555 000005B4 58                          pop eax 
   556                                  
   557 000005B5 C3                          ret 
   558                                  
   559                                  SECTION trail
   560                                      ldr_end:
