     1                                  ; 内核加载器
     2                                  
     3                                  %include "./common/global_defs.asm"
     1                              <1> ; 全局常量定义
     2                              <1> 
     3                              <1> %ifndef _GLOBAL_DEFS_
     4                              <1>     %define _GLOBAL_DEFS_
     5                              <1> 
     6                              <1>     SDA_PHY_ADDR        equ     0x00007e00	; 系统数据区的起始物理地址
     7                              <1>     PML5_PHY_ADDR       equ     0x00009000	; 内核 5 级头表物理地址
     8                              <1>     PML4_PHY_ADDR       equ     0x0000a000	; 内核 4 级头表物理地址
     9                              <1>     PDPT_PHY_ADDR       equ     0x0000b000	; 对应于低端 2MB 的内核页目录指针表物理地址
    10                              <1>     PDT_PHY_ADDR        equ     0x0000c000	; 对应于低端 2MB 的页目录表物理地址
    11                              <1>     PT_PHY_ADDR         equ     0x0000d000	; 对应于低端 2MB 的内核页表的物理地址
    12                              <1>     IDT_PHY_ADDR        equ     0x0000e000	; 中断描述符表的物理地址
    13                              <1>     LDR_PHY_ADDR        equ     0x0000f000	; 用于安装内核加载器的起始物理地址
    14                              <1>     GDT_PHY_ADDR        equ     0x00010000	; 全局描述符表 GDT 的物理地址
    15                              <1>     CORE_PHY_ADDR       equ     0x00020000	; 内核的起始物理地址
    16                              <1>     COR_PDPT_ADDR       equ     0x00100000	; 从这个物理地址开始的 1MB 是内核的 254 个页目录指针表
    17                              <1> 
    18                              <1>     LDR_START_SECTOR    equ     1      	        ; 内核加载器在硬盘上的起始逻辑扇区号
    19                              <1>     COR_START_SECTOR    equ     9      	        ; 内核程序在硬盘上的起始逻辑扇区号
    20                              <1> 
    21                              <1>     ; 虚拟内存空间的高端起始于线性地址 0xffff800000000000
    22                              <1>     UPPER_LINEAR_START  equ     0xffff800000000000  
    23                              <1>     UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	    ; 内核的高端线性地址
    24                              <1>     UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ; 文本显示缓冲区的高端起始线性地址
    25                              <1>     UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	    ; 系统数据区的高端线性地址
    26                              <1>     UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	    ; GDT 的高端线性地址
    27                              <1>     UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	    ; IDT 的高端线性地址
    28                              <1> 
    29                              <1>     ; 与全局描述符表有关的选择子定义, 及内存管理有关的常量定义
    30                              <1>     CORE_CODE64_SEL     equ     0x0018	; 内核代码段的描述符选择子(RPL=00)
    31                              <1>     CORE_STACK64_SEL    equ     0x0020	; 内核栈段的描述符选择子(RPL=00)
    32                              <1>     RESVD_DESC_SEL      equ     0x002b	; 保留的描述符选择子
    33                              <1>     USER_CODE64_SEL     equ     0x003b	; 3 特权级代码段的描述符选择子(RPL=11)
    34                              <1>     USER_STACK64_SEL    equ     0x0033	; 3 特权级栈段的描述符选择子(RPL=11)
    35                              <1> 
    36                              <1>     PHY_MEMORY_SIZE     equ     32    	            ; 物理内存大小(MB), 要求至少 3MB
    37                              <1>     CORE_ALLOC_START    equ     0xffff800000200000	; 在虚拟地址空间高端(内核)分配内存时的起始地址
    38                              <1>     USER_ALLOC_START    equ     0x0000000000000000	; 在每个任务虚拟地址空间低端分配内存时的起始地址
    39                              <1> 
    40                              <1>     ; 创建任务时, 需要分配一个物理页作为新任务的 4 级头表, 并分配一个临时的线性地址来初始化这个页
    41                              <1>     NEW_PML4_LINEAR     equ     0xffffff7ffffff000	; 用来映射新任务 4 级头表的线性地址
    42                              <1>     LAPIC_START_ADDR    equ     0xffffff7fffffe000	; LOCAL APIC 寄存器的起始线性地址
    43                              <1>     IOAPIC_START_ADDR   equ     0xffffff7fffffd000	; I/O APIC 寄存器的起始线性地址
    44                              <1>     AP_START_UP_ADDR    equ     0x0000f000 	        ; 应用处理器(AP)启动代码的物理地址
    45                              <1>     SUGG_PREEM_SLICE    equ     55          	    ; 推荐的任务/线程抢占时间片长度(毫秒)
    46                              <1> 
    47                              <1>     ; 多处理器环境下的自旋锁加锁宏。需要两个参数: 寄存器, 以及一个对应宽度的锁变量
    48                              <1>     %macro  SET_SPIN_LOCK 2             ; 两个参数, 分别是寄存器 %1 和锁变量 %2
    49                              <1>             %%spin_lock:
    50                              <1>                     cmp %2, 0           ; 看一眼锁现在是不是 0
    51                              <1>                     je %%get_lock      	; 如果是 0，说明没人占，跳过去抢
    52                              <1>                     pause				; 不是 0，先喘口气（降低 CPU 占用）
    53                              <1>                     jmp %%spin_lock    	; 继续看
    54                              <1>             %%get_lock:
    55                              <1>                     mov %1, 1
    56                              <1>                     xchg %1, %2         ; 用 xchg 的“原子交换”能力抢锁，抢不到就一直循环（自旋）
    57                              <1>                     cmp %1, 0          	; 交换回来的 %2 旧值是 0 吗？
    58                              <1>                     jne %%spin_lock   	; 不是 0 说明别人先插了旗，回到开头重抢
    59                              <1>     %endmacro
    60                              <1> 
    61                              <1> %endif
     4                                  
     5                                  SECTION loader
     6 00000000 6C696E6F                    marker          dd "lino"           ; 内核加载器有效标志    +00 将老师的 lizh, 改为了 lino, hh
     7 00000004 [00000000]                  length          dd ldr_end          ; 内核加载器的长度      +04
<<<<<<< HEAD
     8 00000008 [9C010000]                  entry           dd start            ; 内核加载器的入口点    +08
=======
     8 00000008 [A8010000]                  entry           dd start            ; 内核加载器的入口点    +08
>>>>>>> 83ea3db (fix: 第三章终于跑通! 还是在 windows, 虚拟机上没法用 virtual-box)
     9                                  
    10 0000000C 4D6F7573654865726F-         msg0            db "MouseHero x64 course learning.", 0x0d, 0x0a
    10 00000015 2078363420636F7572-
    10 0000001E 7365206C6561726E69-
    10 00000027 6E672E0D0A         
    11                                  
    12 0000002C 78363420617661696C-         arch0           db "x64 available(64-bit processor installed).", 0x0d, 0x0a
    12 00000035 61626C652836342D62-
    12 0000003E 69742070726F636573-
    12 00000047 736F7220696E737461-
    12 00000050 6C6C6564292E0D0A   
    13 00000058 783634206E6F742061-         arch1           db "x64 not available(64-bit processor not installed).", 0x0d, 0x0a
    13 00000061 7661696C61626C6528-
    13 0000006A 36342D626974207072-
    13 00000073 6F636573736F72206E-
    13 0000007C 6F7420696E7374616C-
    13 00000085 6C6564292E0D0A     
    14                                  
    15                                      ; 汇编版格式化字符串
    16 0000008C 50726F636573736F72-         brand_mag       db "Processor:"
    16 00000095 3A                 
    17 00000096 00<rep 30h>                     brand       times 48 db 0
    18 000000C6 0D0A                                        db 0x0d, 0x0a
    19                                  
    20 000000C8 506879736963616C20-         cpu_addr        db "Physical address size:"
    20 000000D1 616464726573732073-
    20 000000DA 697A653A           
    21 000000DE 20<rep 3h>                      paddr       times 3 db " "
    22 000000E1 2C                                          db ","
    23 000000E2 4C696E656172206164-                         db "Linear address size:"
    23 000000EB 64726573732073697A-
    23 000000F4 653A               
    24 000000F6 20<rep 3h>                      laddr       times 3 db " "
    25 000000F9 0D0A                                        db 0x0d, 0x0a
    26                                  
    27 000000FB 50726F74656374206D-         protect         db "Protect mode has been entered to prepare for IA-32e mode.", 0x0d, 0x0a, 0
    27 00000104 6F6465206861732062-
    27 0000010D 65656E20656E746572-
    27 00000116 656420746F20707265-
    27 0000011F 7061726520666F7220-
    27 00000128 49412D333265206D6F-
    27 00000131 64652E0D0A00       
    28                                  
    29 00000137 49412D333265206D6F-         ia_32e          db "IA-32e mode(aka,long mode) is active.Specifically,"
    29 00000140 646528616B612C6C6F-
    29 00000149 6E67206D6F64652920-
    29 00000152 697320616374697665-
    29 0000015B 2E5370656369666963-
    29 00000164 616C6C792C         
    30 00000169 636F6D706174696269-                         db "compatibility mode.", 0x0d, 0x0a, 0
    30 00000172 6C697479206D6F6465-
    30 0000017B 2E0D0A00           
    31                                  
    32                                  ; ------------------------------------------------------------
    33                                  ; put_string_by_bios
<<<<<<< HEAD
    34                                  ; 功能: 在光标当前位置按指定颜色打印字符串
    35                                  ; 输入: bp = 字符串地址, cx = 长度, bl = 颜色属性
    36                                  ; 输出: 无(光标自动后移)
    37                                  ; ------------------------------------------------------------
    38                                  put_string_by_bios:
    39 0000017F 60                          pusha                               ; 保存全部通用寄存器
    40                                  
    41 00000180 B403                        mov ah, 0x03                        ; 获取光标位置
    42 00000182 B700                        mov bh, 0x00
    43 00000184 CD10                        int 0x10                            ; 返回 dh=行, dl=列
    44                                  
    45 00000186 B80113                      mov ax, 0x1301                      ; 写字符串, 光标移动
    46 00000189 B700                        mov bh, 0
    47 0000018B CD10                        int 0x10
    48                                  
    49 0000018D 61                          popa                                ; 恢复全部通用寄存器
    50 0000018E C3                          ret
    51                                  
    52                                  no_ia_32e:
    53 0000018F BD[5800]                    mov bp, arch1
    54 00000192 B93400                      mov cx, brand_mag - arch1
    55 00000195 B34F                        mov bl, 0x4f
    56 00000197 E8E5FF                      call put_string_by_bios
    57                                  
    58 0000019A FA                          cli
    59 0000019B F4                          hlt
    60                                  
    61                                  
    62                                  start:
    63 0000019C BD[0C00]                    mov bp, msg0
    64 0000019F B92000                      mov cx, arch0 - msg0
    65 000001A2 B34F                        mov bl, 0x4f                        ; 红底亮白字
    66 000001A4 E8D8FF                      call put_string_by_bios
    67                                  
    68                                      ; 检查处理器是否支持 ia-32e 模式
    69 000001A7 66B800000080                mov eax, 0x80000000                 ; 返回处理器支持的最大扩展功能号
    70 000001AD 0FA2                        cpuid                               ; 返回值在 eax 中
    71 000001AF 663D01000080                cmp eax, 0x80000001
    72 000001B5 72D8                        jb no_ia_32e                        ; 不支持就到 no_ia_32e 处执行
    73                                  
    74 000001B7 66B801000080                mov eax, 0x80000001                 ; edx 返回扩展的签名和特性标志位
    75 000001BD 0FA2                        cpuid
    76 000001BF 660FBAE21D                  bt edx, 29                          ; 低 29 位是 IA-32e 模式支持标志, bt 指令会影响 cf  标志位
    77 000001C4 73C9                        jnc no_ia_32e                       ; 不支持就到 no_ia_32e 处执行
    78                                  
    79 000001C6 BD[2C00]                    mov bp, arch0
    80 000001C9 B92C00                      mov cx, arch1 - arch0
    81 000001CC B307                        mov bl, 0x07                        ; 黑底白字
    82 000001CE E8AEFF                      call put_string_by_bios
    83                                  
    84                                      ; 显示处理器商标信息
    85 000001D1 66B800000080                mov eax, 0x80000000 
    86 000001D7 0FA2                        cpuid
    87 000001D9 663D04000080                cmp eax, 0x80000004
    88 000001DF 725C                        jb .no_brand
    89                                  
    90 000001E1 66B802000080                mov eax, 0x80000002
    91 000001E7 0FA2                        cpuid
    92 000001E9 66A3[9600]                  mov [brand + 0x00], eax
    93 000001ED 66891E[9A00]                mov [brand + 0x04], ebx
    94 000001F2 66890E[9E00]                mov [brand + 0x08], ecx
    95 000001F7 668916[A200]                mov [brand + 0x0c], edx
    96                                  
    97 000001FC 66B803000080                mov eax, 0x80000003
    98 00000202 0FA2                        cpuid
    99 00000204 66A3[A600]                  mov [brand + 0x10], eax
   100 00000208 66891E[AA00]                mov [brand + 0x14], ebx
   101 0000020D 66890E[AE00]                mov [brand + 0x18], ecx
   102 00000212 668916[B200]                mov [brand + 0x1c], edx
   103                                  
   104 00000217 66B804000080                mov eax, 0x80000004
   105 0000021D 0FA2                        cpuid
   106 0000021F 66A3[B600]                  mov [brand + 0x20], eax
   107 00000223 66891E[BA00]                mov [brand + 0x24], ebx
   108 00000228 66890E[BE00]                mov [brand + 0x28], ecx
   109 0000022D 668916[C200]                mov [brand + 0x2c], edx
   110                                  
   111 00000232 BD[8C00]                    mov bp, brand_mag
   112 00000235 B93C00                      mov cx, cpu_addr - brand_mag
   113 00000238 B307                        mov bl, 0x07
   114 0000023A E842FF                      call put_string_by_bios
   115                                  
   116                                      ; 第五章再回来填坑----
   117                                  .no_brand:
   118                                      ; 获取当前系统的物理内存布局信息(使用 int 0x15, E820 功能。俗称 E820 内存)
   119 0000023D 06                          push es 
   120                                  
   121 0000023E BBE007                      mov bx, SDA_PHY_ADDR >> 4               ; 切换到系统数据区
   122 00000241 8EC3                        mov es, bx 
   123 00000243 26C70616000000              mov word [es:0x16], 0
   124 0000024A 6631DB                      xor ebx, ebx                            ; 首次调用 int 0x15 时必须为 0
   125 0000024D BF1800                      mov di, 0x18                            ; 系统数据区内的偏移
   126                                  
   127                                  .mlookup:
   128 00000250 66B820E80000                mov eax, 0xe820
   129 00000256 66B920000000                mov ecx, 32
   130 0000025C 66BA50414D53                mov edx, "PAMS"
   131 00000262 CD15                        int 0x15
   132 00000264 83C720                      add di, 32
   133 00000267 26FF061600                  inc word [es:0x16]
   134 0000026C 6609DB                      or ebx, ebx
   135 0000026F 75DF                        jnz .mlookup
   136                                  
   137 00000271 07                          pop es
   138                                      ; 第五章再回来填坑----
   139                                      ; 获取存储处理器的物理/虚拟地址尺寸信息
   140 00000272 66B800000080                mov eax, 0x80000000                     
   141 00000278 0FA2                        cpuid
   142 0000027A 663D08000080                cmp eax, 0x80000008
   143 00000280 B82430                      mov ax, 0x3024                          ; 设置默认的处理器物理/逻辑地址位数 36(0x24) 和 48(0x30)
   144 00000283 7208                        jb .no_plsize
   145                                  
   146 00000285 66B808000080                mov eax, 0x80000008                     ; 执行后, ax 中 0-7 位(al)是物理地址尺寸, 8-15 位(ah)是虚拟地址尺寸
   147 0000028B 0FA2                        cpuid
   148                                  
   149                                  .no_plsize:
   150                                      ; 保存物理和虚拟地址尺寸到系统数据区
   151 0000028D 1E                          push ds 
   152 0000028E BBE007                      mov bx, SDA_PHY_ADDR >> 4               ; 切换到系统数据区
   153 00000291 8EDB                        mov ds, bx 
   154 00000293 A30000                      mov word [0], ax                        ; 记录处理器的物理/虚拟地址尺寸
   155 00000296 1F                          pop ds 
   156                                  
   157                                      ; 准备显示存储器的物理地址尺寸信息
   158 00000297 50                          push ax                                 ; 备份 ax
   159                                  
   160 00000298 25FF00                      and ax, 0x00ff                          ; 只要 al 中的物理地址
   161 0000029B BE0200                      mov si, 2
   162 0000029E B30A                        mov bl, 10
   163                                  
   164                                  .re_div0:
   165 000002A0 F6F3                        div bl                                  ; 16 位除法, 商在 al 中, 余数在 ah 里
   166 000002A2 80C430                      add ah, 0x30                            ; ASCII 码
   167 000002A5 88A4[DE00]                  mov [paddr + si], ah                    ; 低位在高地址
   168 000002A9 4E                          dec si 
   169 000002AA 05FF00                      add ax, 0x00ff
   170 000002AD 75F1                        jnz .re_div0
   171                                  
   172                                      ; 准备显示处理器的虚拟地址尺寸信息
   173 000002AF 58                          pop ax 
   174                                  
   175 000002B0 C1E808                      shr ax, 8                               ; 将虚拟地址移到 al 重复上边的逻辑
   176 000002B3 BE0200                      mov si, 2
   177 000002B6 B30A                        mov bl, 10
   178                                  .re_div1:
   179 000002B8 F6F3                        div bl 
   180 000002BA 80C430                      add ah, 0x30 
   181 000002BD 88A4[F600]                  mov [laddr + si], ah 
   182 000002C1 4E                          dec si 
   183 000002C2 05FF00                      add ax, 0x00ff
   184 000002C5 75F1                        jnz .re_div1
   185                                  
   186                                      ; 显示处理器的物理/虚拟地址尺寸信息
   187 000002C7 BD[C800]                    mov bp, cpu_addr
   188 000002CA B93300                      mov cx, protect - cpu_addr
   189 000002CD B307                        mov bl, 0x07   
   190 000002CF E8ADFE                      call put_string_by_bios
   191                                  
   192                                      ; 以下开始进入保护模式, 为 IA-32e 模式做必要的准备工作
   193 000002D2 B80010                      mov ax, GDT_PHY_ADDR >> 4               ; 计算 GDT 所在的逻辑段地址
   194 000002D5 8ED8                        mov ds, ax 
   195                                  
   196                                      ; 跳过 0# 号描述符的槽位, 处理器规定 0# 号描述符为空
   197                                      
   198                                      ; 创建 1# 描述符, 保护模式下的代码段描述符
   199 000002D7 66C7060800FFFF0000          mov dword [0x08], 0x0000ffff            ; 基地址为0, 界限0xFFFFF, DPL=00, 4KB 粒度, 代码段描述符, 向上扩展
   200 000002E0 66C7060C000098CF00          mov dword [0x0c], 0x00cf9800
   201                                      
   202                                      ; 创建 2# 描述符, 保护模式下的数据段和堆栈段描述符
   203 000002E9 66C7061000FFFF0000          mov dword [0x10], 0x0000ffff            ; 基地址为0, 界限0xFFFFF, DPL=00, 4KB 粒度, 数据段描述符, 向上扩展
   204 000002F2 66C70614000092CF00          mov dword [0x14], 0x00cf9200
   205                                  
   206                                      ; 创建 3# 描述符, 64 位模式下的代码段描述符。为进入 64 位提前作准备, 其 L 位是 1
   207 000002FB 66C7061800FFFF0000          mov dword [0x18], 0x0000ffff            ; 基地址为0, 界限0xFFFFF, DPL=00, 4KB 粒度, L=1, 代码段描述符, 向上扩展
   208 00000304 66C7061C000098AF00          mov dword [0x1c], 0x00af9800
   209                                  
   210                                      ; 记录 GDT 的基地址和界限值
   211 0000030D B8E007                      mov ax, SDA_PHY_ADDR >> 4               ; 切换到系统数据区
   212 00000310 8ED8                        mov ds, ax  
   213                                  
   214 00000312 C70602001F00                mov word[2], 0x1f                       ; 描述符表的界限
   215 00000318 66C706040000000100          mov dword[4], GDT_PHY_ADDR              ; GDT 的线性基地址
   216                                  
   217                                      ; 加载描述符表寄存器 GDTR
   218 00000321 0F01160200                  lgdt [2]
   219                                  
   220 00000326 E492                        in al, 0x92                             ; 南桥芯片内的端口
   221 00000328 0C02                        or al, 0000_0010B
   222 0000032A E692                        out 0x92, al                            ; 打开处理器的第 21 根地址线 A20
   223                                  
   224 0000032C FA                          cli                                     ; 关闭中断
   225                                  
   226 0000032D 0F20C0                      mov eax, cr0                            ; 设置控制寄存器 CR0 的 PE 位, 将处理器从实模式切换到保护模式。
   227 00000330 6683C801                    or eax, 1
   228 00000334 0F22C0                      mov cr0, eax 
   229                                  
   230                                      ; 以下进入保护模式
   231 00000337 66EA[3FF30000]0800          jmp 0x0008: dword LDR_PHY_ADDR + flush  ; 0x0008 是 16 位描述符选择子, 从 GDT 中选择第二个描述符。jmp 后清流水线并串行化处理器, 跳转到 flush
   232                                  
   233                                      [bits 32]
   234                                  flush:
   235 0000033F B810000000                  mov eax, 0x0010                         ; 加载数据段(4GB)选择子
   236 00000344 8ED8                        mov ds, eax
   237 00000346 8EC0                        mov es, eax
   238 00000348 8EE0                        mov fs, eax
   239 0000034A 8EE8                        mov gs, eax
   240 0000034C 8ED0                        mov ss, eax  
   241 0000034E BC007C0000                  mov esp, 0x7c00                         ; 堆栈指针
   242                                  
   243                                      ; 显示信息, 在保护模式下位进入 IA-32e 模式做准备
   244 00000353 BB[FBF00000]                mov ebx, LDR_PHY_ADDR + protect
   245 00000358 E863010000                  call put_string_flat32
   246                                  
   247                                      ; 以下加载系统核心程序
   248 0000035D BF00000200                  mov edi, CORE_PHY_ADDR
   249                                  
   250 00000362 B809000000                  mov eax, COR_START_SECTOR
   251 00000367 89FB                        mov ebx, edi                            ; 起始地址
   252 00000369 E8FD010000                  call read_hard_disk_0                   ; 读取程序起始第一扇区
   253                                  
   254                                      ; 判断程序大小
   255 0000036E 8B07                        mov eax, [edi]                          ; 内核程序大小
   256 00000370 31D2                        xor edx, edx 
   257 00000372 B900020000                  mov ecx, 512                            ; 每个扇区大小为 512
   258 00000377 F7F1                        div ecx                                 ; 商存储在 eax 中, 余数存储在 edx 中
   259                                  
   260                                      ; 处理长度 < 512 字节的情况
   261 00000379 09C0                        or eax, eax 
   262 0000037B 7419                        jz pge
   263                                      ; 处理长度 >= 512 字节的情况
   264 0000037D 09D2                        or edx, edx 
   265 0000037F 7505                        jnz @1
   266 00000381 48                          dec eax 
   267 00000382 09C0                        or eax, eax                             ; 正好为 512 时, 单独处理
   268 00000384 7410                        jz pge
   269                                  @1:
   270                                      ; 读取剩余扇区
   271 00000386 89C1                        mov ecx, eax                            ; 循环次数
   272 00000388 B809000000                  mov eax, COR_START_SECTOR
   273 0000038D 40                          inc eax 
   274                                  @2:
   275 0000038E E8D8010000                  call read_hard_disk_0
   276 00000393 40                          inc eax
   277 00000394 E2F8                        loop @2
   278                                  
   279                                  pge:
   280                                      ; 回填内核加载地址的物理地址到内核程序头部
   281 00000396 C70508000200000002-         mov dword [CORE_PHY_ADDR + 0x08], CORE_PHY_ADDR
   281 0000039F 00                 
   282 000003A0 C7050C000200000000-         mov dword [CORE_PHY_ADDR + 0x0c], 0
   282 000003A9 00                 
   283                                  
   284                                      ; 创建 4 级分页系统, 只包含基本部分, 覆盖低端 1 MB物理内存
   285 000003AA BB00A00000                  mov ebx, PML4_PHY_ADDR                  ; 找个地方存四级页表
   286                                  
   287                                      ; 4 级页表清零
   288 000003AF B900040000                  mov ecx, 1024
   289 000003B4 31F6                        xor esi, esi 
   290                                  .cls0:
   291 000003B6 C7043300000000              mov dword [ebx + esi], 0
   292 000003BD 83C604                      add esi, 4
   293 000003C0 E2F4                        loop .cls0
   294                                  
   295                                      ; 在 4 级页表内最后一项存放自身地址, 这样可以通过虚拟地址访问表中最后一项来获取页表的真实地址
   296 000003C2 C783F80F000003A000-         mov dword [ebx + 511 * 8], PML4_PHY_ADDR | 3    ; 添加属性
   296 000003CB 00                 
   297 000003CC C783FC0F0000000000-         mov dword [ebx + 511 * 8 + 4], 0
   297 000003D5 00                 
   298                                  
   299                                      ; 映射虚拟地址与物理地址的低端 2 MB, 确保开启分页后也可以正常访问, 即地址经过页表转换后不变。
   300                                      ; 0x0000000000000000--0x00000000001FFFFF 低 48 位按 9 9 9 9 12 分割进行四级分页查表。而高 16 位无效, 填充符号位
   301 000003D6 C70303B00000                mov dword [ebx + 0 * 8], PDPT_PHY_ADDR  | 3     ; 添加属性
   302 000003DC C7430400000000              mov dword [ebx + 0 * 8 + 4], 0
   303                                  
   304                                      ; 将页目录指针表中的内容清 0
   305 000003E3 BB00B00000                  mov ebx, PDPT_PHY_ADDR
   306                                  
   307 000003E8 B900040000                  mov ecx, 1024
   308 000003ED 31F6                        xor esi, esi 
   309                                  .cls1:
   310 000003EF C7043300000000              mov dword [ebx + esi], 0
   311 000003F6 83C604                      add esi, 4
   312 000003F9 E2F4                        loop .cls1
   313                                  
   314                                      ; 套娃, 创建下一级页表
   315 000003FB C70303C00000                mov dword [ebx + 0 * 8], PDT_PHY_ADDR | 3
   316 00000401 C7430400000000              mov dword [ebx + 0 * 8 + 4], 0
   317                                  
   318                                      ; 清 0
   319 00000408 BB00C00000                  mov ebx, PDT_PHY_ADDR
   320                                  
   321 0000040D B900040000                  mov ecx, 1024
   322 00000412 31F6                        xor esi, esi
   323                                  .cls2:
   324 00000414 C7043300000000              mov dword [ebx + esi], 0
   325 0000041B 83C604                      add esi, 4
   326 0000041E E2F4                        loop .cls2
   327                                  
   328                                      ; 在页目录表内创建与低端 2MB 对应的表项
   329 00000420 C70383000000                mov dword [ebx + 0 * 8], 0 | 0x83       ; 位 7、R/W 位、P 位是 1, 其他全是 0
   330 00000426 C7430400000000              mov dword [ebx + 0 * 8 + 4], 0
   331                                  
   332                                      ; 将物理内存的低端 2MB 映射到线性地址空间的高端, 内核处于高地址, 要做一次重复映射。0xFFFF800000000000--0xFFFF8000001FFFFF
   333 0000042D BB00A00000                  mov ebx, PML4_PHY_ADDR
   334                                  
   335 00000432 C7830008000003B000-         mov dword [ebx + 256 * 8], PDPT_PHY_ADDR | 3 ; 页目录表
   335 0000043B 00                 
   336 0000043C C78304080000000000-         mov dword [ebx + 256 * 8 + 4], 0
   336 00000445 00                 
   337                                  
   338                                      ; 因为要为每个进程都给予一个独立的 4 级头表(可以理解为指针数组), 而内核空间是所有进程共享的, 要在每个进程独立
   339                                      ; 的 4 级头表中内核公共部分填入一样的数据。页表机制的一个特点是 就是动态分配, 用时间换空间, 为了避免此特性使
   340                                      ; 每个进程不停的去同步 4 级头表中内核公共部分, 索性直接将 4 级头表中内核公共部分全部预分配好。详细解释见书中 135 页。
   341 00000446 B801010000                  mov eax, 257
   342 0000044B BA03001000                  mov edx, COR_PDPT_ADDR | 3
   343                                  .fill_pml4:
   344 00000450 8914C3                      mov dword [ebx + eax * 8], edx 
   345 00000453 C744C30400000000            mov dword [ebx + eax * 8 + 4], 0
   346 0000045B 81C200100000                add edx, 0x1000
   347 00000461 40                          inc eax 
   348 00000462 3DFF010000                  cmp eax, 511
   349 00000467 72E7                        jb .fill_pml4
   350                                  
   351                                      ; 将预分配的页目录指针表全部清零
   352 00000469 B800001000                  mov eax, COR_PDPT_ADDR
   353                                  .zero_pdpt:
   354 0000046E C70000000000                mov dword [eax], 0
   355 00000474 83C004                      add eax, 4
   356 00000477 3D00E01F00                  cmp eax, COR_PDPT_ADDR + 0x1000 * 254
   357 0000047C 72F0                        jb .zero_pdpt
   358                                  
   359                                      ; 将 cr3 寄存器指向 4 级头表
   360 0000047E B800A00000                  mov eax, PML4_PHY_ADDR
   361 00000483 0F22D8                      mov cr3, eax 
   362                                  
   363                                      ; 开启物理扩展 PAE
   364 00000486 0F20E0                      mov eax, cr4 
   365 00000489 0FBAE805                    bts eax, 5                              ; 位测试并置位
   366 0000048D 0F22E0                      mov cr4, eax 
   367                                  
   368                                      ; 设置型号专属寄存器 IA32_EFER.LME, 允许 IA_32e 模式
   369 00000490 B9800000C0                  mov ecx, 0x0c0000080                    ; 指定型号专属寄存器 IA32_EFER
   370 00000495 0F32                        rdmsr
   371 00000497 0FBAE808                    bts eax, 8                              ; 设置 LME 位
   372 0000049B 0F30                        wrmsr 
   373                                  
   374                                      ; 开启分页功能
   375 0000049D 0F20C0                      mov eax, cr0 
   376 000004A0 0FBAE81F                    bts eax, 31                             ; 置位 cr0.PG
   377 000004A4 0F22C0                      mov cr0, eax 
   378                                  
   379                                      ; 打印 IA_32e 激活信息
   380 000004A7 BB[37F10000]                mov ebx, ia_32e + LDR_PHY_ADDR
   381 000004AC E80F000000                  call put_string_flat32
   382                                  
   383                                      ; 通过原返回的方式进入 64 位模式内核
   384 000004B1 666A18                      push word CORE_CODE64_SEL
   385 000004B4 A104000200                  mov eax, dword [CORE_PHY_ADDR + 4]
   386 000004B9 0500000200                  add eax, CORE_PHY_ADDR
   387 000004BE 50                          push eax 
   388 000004BF CB                          retf                                    ; 压入 GDT 选择子和地址
   389                                  
   390                                  ; ------------------------------------------------------------
   391                                  ; put_string_flat32
   392                                  ; 功能: 显示 0 终止的字符串并移动光标。只运行在32位保护模式下, 且使用平坦模型。
   393                                  ; 输入: EBX=字符串的线性地址
   394                                  ; ------------------------------------------------------------
   395                                  put_string_flat32:
   396 000004C0 53                          push ebx 
   397 000004C1 51                          push ecx 
   398                                  .getc:
   399 000004C2 8A0B                        mov cl, [ebx]
   400 000004C4 08C9                        or cl, cl                               ; 检测串结束标志 0
   401 000004C6 7408                        jz .exit                                
   402 000004C8 E806000000                  call put_char
   403 000004CD 43                          inc ebx 
   404 000004CE EBF2                        jmp .getc
   405                                  
   406                                  .exit:
   407 000004D0 59                          pop ecx 
   408 000004D1 5B                          pop ebx 
   409                                  
   410 000004D2 C3                          ret 
   411                                  
   412                                  ; ------------------------------------------------------------
   413                                  ; put_char
   414                                  ; 功能: 在当前光标处显示一个字符, 并推进光标, 仅用于段内调用
   415                                  ; 输入: CL=字符ASCII码
   416                                  ; ------------------------------------------------------------
   417                                  put_char:
   418 000004D3 60                          pushad 
   419                                  
   420 000004D4 66BAD403                    mov dx, 0x3d4                           ; 0x3d4 是 VGA 显卡的索引寄存器端口地址, 用于指定要操作的显卡寄存器。
   421 000004D8 B00E                        mov al, 0xe                             ; 0xe 是显卡的光标位置寄存器的索引值, 用于读取光标的高字节位置。
   422 000004DA EE                          out dx, al                              ; 将 0xe 输出到端口 0x3d4, 
   423 000004DB 6642                        inc dx                                  ; 0x3d5 是显卡的数据寄存器端口地址, 用于读取或写入显卡寄存器的实际数据。
   424 000004DD EC                          in al, dx                               ; 从端口 0x3d5 读取数据到 al, 读取了光标位置的高字节
   425                                  
   426 000004DE 88C4                        mov ah, al                              ; 存入 ah 
   427                                  
   428 000004E0 664A                        dec dx                                  ; 同上, 再获取低字节
   429 000004E2 B00F                        mov al, 0x0f                            ; 0x0f 是显卡的光标位置寄存器的索引值, 用于读取光标的低字节位置。
   430 000004E4 EE                          out dx, al 
   431 000004E5 6642                        inc dx 
   432 000004E7 EC                          in al, dx 
   433                                  
   434 000004E8 6689C3                      mov bx, ax                              ; 此时 bx 中存储了字符的数目, 一个字符占两个字节
   435 000004EB 81E2FFFF0000                and edx, 0x0000ffff
   436                                  
   437 000004F1 80F90D                      cmp cl, 0x0d                            ; 回车符?
   438 000004F4 750E                        jnz .put_0a                             ; 不是回车符检查是不是换行符(0x0a)
   439                                  
   440 000004F6 6689D8                      mov ax, bx                              ; 处理回车符
   441 000004F9 B350                        mov bl, 80                              ; 行宽 80
   442 000004FB F6F3                        div bl 
   443 000004FD F6E3                        mul bl                                  ; 移到本行起始
   444 000004FF 6689C3                      mov bx, ax 
   445 00000502 EB19                        jmp .roll_screen
   446                                  
   447                                  .put_0a:
   448 00000504 80F90A                      cmp cl, 0x0a                            ; 换行符?
   449 00000507 7506                        jnz .put_other
   450                                  
   451 00000509 6683C350                    add bx, 80                              ; 处理换行符
   452 0000050D EB0E                        jmp .roll_screen
   453                                  
   454                                  .put_other:                                 ; 显示字符
   455 0000050F 66D1E3                      shl bx, 1                               ; 在文本模式下, 显存中每个字符占用 2 个字节, 左移 1 位相当于将 bx 的值乘以 2, 从而将光标位置从字符索引转换为显存中的字节偏移量。
   456 00000512 888B00800B00                mov [0xb8000 + ebx], cl                 ; 0xb800:0000(0xb8000) 是显存的起始地址
   457                                  
   458 00000518 66D1EB                      shr bx, 1                               ; 将光标位置移到下一个字符
   459 0000051B 6643                        inc bx      
   460                                  
   461                                  .roll_screen:
   462 0000051D 6681FBD007                  cmp bx, 2000                            ; 超出屏幕外? 
   463 00000522 7C2F                        jl .set_cursor                          ; 设置光标
   464                                  
   465                                      ; 滚屏处理
   466 00000524 53                          push ebx                                ; 保存光标位置               
   467                                  
   468 00000525 FC                          cld                                     ; 清除方向标志
   469 00000526 BEA0800B00                  mov esi, 0xb80a0                        ; 0xb80a0 是显存中第 2 行字符的起始地址。源地址
   470 0000052B BF00800B00                  mov edi, 0xb8000                        ; 0xb8000 是显存起始地址。目标地址
   471 00000530 B9C0030000                  mov ecx, 960                            ; 960 == 24 x 80 x 2 / 4, 滚屏操作需要将第 2 行到第 25 行的内容向上移动一行, 覆盖第 1 行的内容。
   472 00000535 F3A5                        rep movsd                               ; rep movsd 会根据 ecx 的值重复移动数据, 直到 ecx 为 0。每次移动 4 个字节
   473                                      
   474                                      ; 清除屏幕最后一行
   475 00000537 BB000F0000                  mov ebx, 3840                           ; 3840 == 24 x 80 x 2, 设置光标位置为屏幕最后一行的起始位置。
   476 0000053C B950000000                  mov ecx, 80                             ; ecx 是循环次数
   477                                  
   478                                  .cls:
   479 00000541 66C78300800B002007          mov word[0xb8000 + ebx], 0x0720         ; 0x0720 是空格字符, 黑色背景
   480 0000054A 83C302                      add ebx, 2
   481 0000054D E2F2                        loop .cls 
   482                                  
   483 0000054F 5B                          pop ebx                                 ; 恢复光标
   484 00000550 83EB50                      sub ebx, 80                             ; 上移一行
   485                                  
   486                                  .set_cursor:                                ; 设置光标
   487 00000553 66BAD403                    mov dx, 0x3d4
   488 00000557 B00E                        mov al, 0x0e
   489 00000559 EE                          out dx, al
   490 0000055A 6642                        inc dx 
   491 0000055C 88F8                        mov al, bh 
   492 0000055E EE                          out dx, al 
   493                                  
   494 0000055F 664A                        dec dx 
   495 00000561 B00F                        mov al, 0x0f
   496 00000563 EE                          out dx, al 
   497 00000564 6642                        inc dx 
   498 00000566 88D8                        mov al, bl 
   499 00000568 EE                          out dx, al 
   500                                  
   501 00000569 61                          popad 
   502 0000056A C3                          ret 
   503                                  
   504                                  ; ------------------------------------------------------------
   505                                  ; read_hard_disk_0
   506                                  ; 功能: 从硬盘中读取一个扇区
   507                                  ; 输入: eax=逻辑扇区号, ebx=目标缓冲区地址
   508                                  ; 返回: ebx = ebx + 512
   509                                  ; ------------------------------------------------------------
   510                                  read_hard_disk_0:
   511 0000056B 50                          push eax
   512 0000056C 51                          push ecx
   513 0000056D 52                          push edx 
   514                                  
   515 0000056E 50                          push eax 
   516                                  
   517 0000056F 66BAF201                    mov dx, 0x1f2                           ; 0x1f2 是硬盘控制器的一个端口地址, 用于指定要读取的扇区数量。
   518 00000573 B001                        mov al, 1
   519 00000575 EE                          out dx, al                              ; 将 1 写入到硬盘控制器的端口 0x1f2, 告诉硬盘控制器接下来要读取一个扇区。
   520                                  
   521 00000576 6642                        inc dx                                  ; 0x1f3
   522 00000578 58                          pop eax 
   523 00000579 EE                          out dx, al                              ; LBA 地址 7 ~ 0
   524                                  
   525 0000057A 6642                        inc dx                                  ; 0x1f4
   526 0000057C B108                        mov cl, 8
   527 0000057E D3E8                        shr eax, cl 
   528 00000580 EE                          out dx, al                              ; LBA 地址 15 ~ 8
   529                                  
   530 00000581 6642                        inc dx                                  ; 0x1f5
   531 00000583 D3E8                        shr eax, cl 
   532 00000585 EE                          out dx, al                              ; LBA 地址 23 ~ 16
   533                                  
   534 00000586 6642                        inc dx                                  ; 0x1f6
   535 00000588 D3E8                        shr eax, cl 
   536 0000058A 0CE0                        or al, 0xe0                             ; 第一硬盘
   537 0000058C EE                          out dx, al                              ; LBA 地址 27 ~ 24
   538                                  
   539 0000058D 6642                        inc dx                                  ; 0x1f7
   540 0000058F B020                        mov al, 0x20    
   541 00000591 EE                          out dx, al                              ; 读命令
   542                                  
   543                                  .waits:
   544 00000592 EC                          in al, dx 
   545 00000593 A808                        test al, 8
   546 00000595 74FB                        jz .waits                               ; 忙或数据还没准备好, 循环查询
   547                                  
   548 00000597 B900010000                  mov ecx, 256                            ; 总共要读取的字数, 循环次数
   549 0000059C 66BAF001                    mov dx, 0x1f0
   550                                  
   551                                  .readw:
   552 000005A0 66ED                        in ax, dx                               ; 循环去读硬盘数据写入指定内存
   553 000005A2 668903                      mov [ebx], ax 
   554 000005A5 83C302                      add ebx, 2
   555 000005A8 E2F6                        loop .readw
   556                                  
   557 000005AA 5A                          pop edx 
   558 000005AB 59                          pop ecx 
   559 000005AC 58                          pop eax 
   560                                  
   561 000005AD C3                          ret 
   562                                  
   563                                  SECTION trail
   564                                      ldr_end:
=======
    34                                  ; 功能: 在光标当前位置按指定颜色打印字符串, 内平栈
    35                                  ; 输入: 字符串地址, 长度, 颜色属性
    36                                  ; ------------------------------------------------------------
    37                                  put_string_by_bios:
    38 0000017F B403                        mov ah, 0x03                        ; 获取光标位置
    39 00000181 B700                        mov bh, 0x00
    40 00000183 CD10                        int 0x10                            ; 返回 dh=行, dl=列
    41                                  
    42 00000185 678B6C2402                  mov bp, [esp + 2]                   ; 字符串地址       
    43 0000018A 678B4C2404                  mov cx, [esp + 4]                   ; 长度    
    44 0000018F 678B5C2406                  mov bx, [esp + 6]                   ; 颜色属性
    45 00000194 B80113                      mov ax, 0x1301                      ; 写字符串, 光标移动
    46 00000197 CD10                        int 0x10
    47                                  
    48 00000199 C20600                      ret 6
    49                                  
    50                                  no_ia_32e:
    51 0000019C 6A4F                        push 0x004f
    52 0000019E 6A34                        push brand_mag - arch1
    53 000001A0 68[5800]                    push arch1
    54 000001A3 E8D9FF                      call put_string_by_bios
    55                                  
    56 000001A6 FA                          cli
    57 000001A7 F4                          hlt
    58                                  
    59                                  start:
    60 000001A8 6A4F                        push 0x004f
    61 000001AA 6A20                        push arch0 - msg0
    62 000001AC 68[0C00]                    push msg0
    63 000001AF E8CDFF                      call put_string_by_bios
    64                                  
    65                                      ; 检查处理器是否支持 ia-32e 模式
    66 000001B2 66B800000080                mov eax, 0x80000000                 ; 返回处理器支持的最大扩展功能号
    67 000001B8 0FA2                        cpuid                               ; 返回值在 eax 中
    68 000001BA 663D01000080                cmp eax, 0x80000001
    69 000001C0 72DA                        jb no_ia_32e                        ; 不支持就到 no_ia_32e 处执行
    70                                  
    71 000001C2 66B801000080                mov eax, 0x80000001                 ; edx 返回扩展的签名和特性标志位
    72 000001C8 0FA2                        cpuid
    73 000001CA 660FBAE21D                  bt edx, 29                          ; 低 29 位是 IA-32e 模式支持标志, bt 指令会影响 cf  标志位
    74 000001CF 73CB                        jnc no_ia_32e                       ; 不支持就到 no_ia_32e 处执行
    75                                  
    76 000001D1 6A07                        push 0x0007                         ; 黑底白字
    77 000001D3 6A2C                        push arch1 - arch0
    78 000001D5 68[2C00]                    push arch0
    79 000001D8 E8A4FF                      call put_string_by_bios
    80                                  
    81                                      ; 显示处理器商标信息
    82 000001DB 66B800000080                mov eax, 0x80000000 
    83 000001E1 0FA2                        cpuid
    84 000001E3 663D04000080                cmp eax, 0x80000004
    85 000001E9 725B                        jb .no_brand
    86                                  
    87 000001EB 66B802000080                mov eax, 0x80000002
    88 000001F1 0FA2                        cpuid
    89 000001F3 66A3[9600]                  mov [brand + 0x00], eax
    90 000001F7 66891E[9A00]                mov [brand + 0x04], ebx
    91 000001FC 66890E[9E00]                mov [brand + 0x08], ecx
    92 00000201 668916[A200]                mov [brand + 0x0c], edx
    93                                  
    94 00000206 66B803000080                mov eax, 0x80000003
    95 0000020C 0FA2                        cpuid
    96 0000020E 66A3[A600]                  mov [brand + 0x10], eax
    97 00000212 66891E[AA00]                mov [brand + 0x14], ebx
    98 00000217 66890E[AE00]                mov [brand + 0x18], ecx
    99 0000021C 668916[B200]                mov [brand + 0x1c], edx
   100                                  
   101 00000221 66B804000080                mov eax, 0x80000004
   102 00000227 0FA2                        cpuid
   103 00000229 66A3[B600]                  mov [brand + 0x20], eax
   104 0000022D 66891E[BA00]                mov [brand + 0x24], ebx
   105 00000232 66890E[BE00]                mov [brand + 0x28], ecx
   106 00000237 668916[C200]                mov [brand + 0x2c], edx
   107                                  
   108 0000023C 6A07                        push 0x0007
   109 0000023E 6A3C                        push cpu_addr - brand_mag
   110 00000240 68[8C00]                    push brand_mag
   111 00000243 E839FF                      call put_string_by_bios
   112                                  
   113                                      ; 第五章再回来填坑----
   114                                  .no_brand:
   115                                      ; 获取当前系统的物理内存布局信息(使用 int 0x15, E820 功能。俗称 E820 内存)
   116 00000246 06                          push es 
   117                                  
   118 00000247 BBE007                      mov bx, SDA_PHY_ADDR >> 4               ; 切换到系统数据区
   119 0000024A 8EC3                        mov es, bx 
   120 0000024C 26C70616000000              mov word [es:0x16], 0
   121 00000253 6631DB                      xor ebx, ebx                            ; 首次调用 int 0x15 时必须为 0
   122 00000256 BF1800                      mov di, 0x18                            ; 系统数据区内的偏移
   123                                  
   124                                  .mlookup:
   125 00000259 66B820E80000                mov eax, 0xe820
   126 0000025F 66B920000000                mov ecx, 32
   127 00000265 66BA50414D53                mov edx, "PAMS"
   128 0000026B CD15                        int 0x15
   129 0000026D 83C720                      add di, 32
   130 00000270 26FF061600                  inc word [es:0x16]
   131 00000275 6609DB                      or ebx, ebx
   132 00000278 75DF                        jnz .mlookup
   133                                  
   134 0000027A 07                          pop es
   135                                  
   136                                      ; 第五章再回来填坑----
   137                                      ; 获取存储处理器的物理/虚拟地址尺寸信息
   138 0000027B 66B800000080                mov eax, 0x80000000                     
   139 00000281 0FA2                        cpuid
   140 00000283 663D08000080                cmp eax, 0x80000008
   141 00000289 B82430                      mov ax, 0x3024                          ; 设置默认的处理器物理/逻辑地址位数 36(0x24) 和 48(0x30)
   142 0000028C 7208                        jb .no_plsize
   143                                  
   144 0000028E 66B808000080                mov eax, 0x80000008                     ; 执行后, ax 中 0-7 位(al)是物理地址尺寸, 8-15 位(ah)是虚拟地址尺寸
   145 00000294 0FA2                        cpuid
   146                                  
   147                                  .no_plsize:
   148                                      ; 保存物理和虚拟地址尺寸到系统数据区
   149 00000296 1E                          push ds 
   150 00000297 BBE007                      mov bx, SDA_PHY_ADDR >> 4               ; 切换到系统数据区
   151 0000029A 8EDB                        mov ds, bx 
   152 0000029C A30000                      mov word [0], ax                        ; 记录处理器的物理/虚拟地址尺寸
   153 0000029F 1F                          pop ds 
   154                                  
   155                                      ; 准备显示存储器的物理地址尺寸信息
   156 000002A0 50                          push ax                                 ; 备份 ax
   157                                  
   158 000002A1 25FF00                      and ax, 0x00ff                          ; 只要 al 中的物理地址
   159 000002A4 BE0200                      mov si, 2
   160 000002A7 B30A                        mov bl, 10
   161                                  
   162                                  .re_div0:
   163 000002A9 F6F3                        div bl                                  ; 16 位除法, 商在 al 中, 余数在 ah 里
   164 000002AB 80C430                      add ah, 0x30                            ; ASCII 码
   165 000002AE 88A4[DE00]                  mov [paddr + si], ah                    ; 低位在高地址
   166 000002B2 4E                          dec si 
   167 000002B3 25FF00                      and ax, 0x00ff
   168 000002B6 75F1                        jnz .re_div0
   169                                  
   170                                      ; 准备显示处理器的虚拟地址尺寸信息
   171 000002B8 58                          pop ax 
   172                                  
   173 000002B9 C1E808                      shr ax, 8                               ; 将虚拟地址移到 al 重复上边的逻辑
   174 000002BC BE0200                      mov si, 2
   175 000002BF B30A                        mov bl, 10
   176                                  .re_div1:
   177 000002C1 F6F3                        div bl 
   178 000002C3 80C430                      add ah, 0x30 
   179 000002C6 88A4[F600]                  mov [laddr + si], ah 
   180 000002CA 4E                          dec si 
   181 000002CB 25FF00                      and ax, 0x00ff
   182 000002CE 75F1                        jnz .re_div1
   183                                  
   184                                      ; 显示处理器的物理/虚拟地址尺寸信息 
   185 000002D0 6A07                        push 0x0007
   186 000002D2 6A33                        push protect - cpu_addr
   187 000002D4 68[C800]                    push cpu_addr
   188 000002D7 E8A5FE                      call put_string_by_bios
   189                                  
   190                                      ; 以下开始进入保护模式, 为 IA-32e 模式做必要的准备工作
   191 000002DA B80010                      mov ax, GDT_PHY_ADDR >> 4               ; 计算 GDT 所在的逻辑段地址
   192 000002DD 8ED8                        mov ds, ax 
   193                                  
   194                                      ; 跳过 0# 号描述符的槽位, 处理器规定 0# 号描述符为空
   195                                      
   196                                      ; 创建 1# 描述符, 保护模式下的代码段描述符
   197 000002DF 66C7060800FFFF0000          mov dword [0x08], 0x0000ffff            ; 基地址为0, 界限0xFFFFF, DPL=00, 4KB 粒度, 代码段描述符, 向上扩展
   198 000002E8 66C7060C000098CF00          mov dword [0x0c], 0x00cf9800
   199                                      
   200                                      ; 创建 2# 描述符, 保护模式下的数据段和堆栈段描述符
   201 000002F1 66C7061000FFFF0000          mov dword [0x10], 0x0000ffff            ; 基地址为0, 界限0xFFFFF, DPL=00, 4KB 粒度, 数据段描述符, 向上扩展
   202 000002FA 66C70614000092CF00          mov dword [0x14], 0x00cf9200
   203                                  
   204                                      ; 创建 3# 描述符, 64 位模式下的代码段描述符。为进入 64 位提前作准备, 其 L 位是 1
   205 00000303 66C7061800FFFF0000          mov dword [0x18], 0x0000ffff            ; 基地址为0, 界限0xFFFFF, DPL=00, 4KB 粒度, L=1, 代码段描述符, 向上扩展
   206 0000030C 66C7061C000098AF00          mov dword [0x1c], 0x00af9800
   207                                  
   208                                      ; 记录 GDT 的基地址和界限值
   209 00000315 B8E007                      mov ax, SDA_PHY_ADDR >> 4               ; 切换到系统数据区
   210 00000318 8ED8                        mov ds, ax  
   211                                  
   212 0000031A C70602001F00                mov word[2], 0x1f                       ; 描述符表的界限
   213 00000320 66C706040000000100          mov dword[4], GDT_PHY_ADDR              ; GDT 的线性基地址
   214                                  
   215                                      ; 加载描述符表寄存器 GDTR
   216 00000329 0F01160200                  lgdt [2]
   217                                  
   218 0000032E E492                        in al, 0x92                             ; 南桥芯片内的端口
   219 00000330 0C02                        or al, 0000_0010B
   220 00000332 E692                        out 0x92, al                            ; 打开处理器的第 21 根地址线 A20
   221                                  
   222 00000334 FA                          cli                                     ; 关闭中断
   223                                  
   224 00000335 0F20C0                      mov eax, cr0                            ; 设置控制寄存器 CR0 的 PE 位, 将处理器从实模式切换到保护模式。
   225 00000338 6683C801                    or eax, 1
   226 0000033C 0F22C0                      mov cr0, eax 
   227                                  
   228                                      ; 以下进入保护模式
   229 0000033F 66EA[47F30000]0800          jmp 0x0008: dword LDR_PHY_ADDR + flush  ; 0x0008 是 16 位描述符选择子, 从 GDT 中选择第二个描述符。jmp 后清流水线并串行化处理器, 跳转到 flush
   230                                  
   231                                      [bits 32]
   232                                  flush:
   233 00000347 B810000000                  mov eax, 0x0010                         ; 加载数据段(4GB)选择子
   234 0000034C 8ED8                        mov ds, eax
   235 0000034E 8EC0                        mov es, eax
   236 00000350 8EE0                        mov fs, eax
   237 00000352 8EE8                        mov gs, eax
   238 00000354 8ED0                        mov ss, eax  
   239 00000356 BC007C0000                  mov esp, 0x7c00                         ; 堆栈指针
   240                                  
   241                                      ; 显示信息, 在保护模式下位进入 IA-32e 模式做准备
   242 0000035B BB[FBF00000]                mov ebx, LDR_PHY_ADDR + protect
   243 00000360 E863010000                  call put_string_flat32
   244                                  
   245                                      ; 以下加载系统核心程序
   246 00000365 BF00000200                  mov edi, CORE_PHY_ADDR
   247                                  
   248 0000036A B809000000                  mov eax, COR_START_SECTOR
   249 0000036F 89FB                        mov ebx, edi                            ; 起始地址
   250 00000371 E8FD010000                  call read_hard_disk_0                   ; 读取程序起始第一扇区
   251                                  
   252                                      ; 判断程序大小
   253 00000376 8B07                        mov eax, [edi]                          ; 内核程序大小
   254 00000378 31D2                        xor edx, edx 
   255 0000037A B900020000                  mov ecx, 512                            ; 每个扇区大小为 512
   256 0000037F F7F1                        div ecx                                 ; 商存储在 eax 中, 余数存储在 edx 中
   257                                  
   258                                      ; 处理长度 < 512 字节的情况
   259 00000381 09C0                        or eax, eax 
   260 00000383 7419                        jz pge
   261                                      ; 处理长度 >= 512 字节的情况
   262 00000385 09D2                        or edx, edx 
   263 00000387 7505                        jnz @1
   264 00000389 48                          dec eax 
   265 0000038A 09C0                        or eax, eax                             ; 正好为 512 时, 单独处理
   266 0000038C 7410                        jz pge
   267                                  @1:
   268                                      ; 读取剩余扇区
   269 0000038E 89C1                        mov ecx, eax                            ; 循环次数
   270 00000390 B809000000                  mov eax, COR_START_SECTOR
   271 00000395 40                          inc eax 
   272                                  @2:
   273 00000396 E8D8010000                  call read_hard_disk_0
   274 0000039B 40                          inc eax
   275 0000039C E2F8                        loop @2
   276                                  
   277                                  pge:
   278                                      ; 回填内核加载地址的物理地址到内核程序头部
   279 0000039E C70508000200000002-         mov dword [CORE_PHY_ADDR + 0x08], CORE_PHY_ADDR
   279 000003A7 00                 
   280 000003A8 C7050C000200000000-         mov dword [CORE_PHY_ADDR + 0x0c], 0
   280 000003B1 00                 
   281                                  
   282                                      ; 创建 4 级分页系统, 只包含基本部分, 覆盖低端 1 MB物理内存
   283 000003B2 BB00A00000                  mov ebx, PML4_PHY_ADDR                  ; 找个地方存四级页表
   284                                  
   285                                      ; 4 级页表清零
   286 000003B7 B900040000                  mov ecx, 1024
   287 000003BC 31F6                        xor esi, esi 
   288                                  .cls0:
   289 000003BE C7043300000000              mov dword [ebx + esi], 0
   290 000003C5 83C604                      add esi, 4
   291 000003C8 E2F4                        loop .cls0
   292                                  
   293                                      ; 在 4 级页表内最后一项存放自身地址, 这样可以通过虚拟地址访问表中最后一项来获取页表的真实地址
   294 000003CA C783F80F000003A000-         mov dword [ebx + 511 * 8], PML4_PHY_ADDR | 3    ; 添加属性
   294 000003D3 00                 
   295 000003D4 C783FC0F0000000000-         mov dword [ebx + 511 * 8 + 4], 0
   295 000003DD 00                 
   296                                  
   297                                      ; 映射虚拟地址与物理地址的低端 2 MB, 确保开启分页后也可以正常访问, 即地址经过页表转换后不变。
   298                                      ; 0x0000000000000000--0x00000000001FFFFF 低 48 位按 9 9 9 9 12 分割进行四级分页查表。而高 16 位无效, 填充符号位
   299 000003DE C70303B00000                mov dword [ebx + 0 * 8], PDPT_PHY_ADDR  | 3     ; 添加属性
   300 000003E4 C7430400000000              mov dword [ebx + 0 * 8 + 4], 0
   301                                  
   302                                      ; 将页目录指针表中的内容清 0
   303 000003EB BB00B00000                  mov ebx, PDPT_PHY_ADDR
   304                                  
   305 000003F0 B900040000                  mov ecx, 1024
   306 000003F5 31F6                        xor esi, esi 
   307                                  .cls1:
   308 000003F7 C7043300000000              mov dword [ebx + esi], 0
   309 000003FE 83C604                      add esi, 4
   310 00000401 E2F4                        loop .cls1
   311                                  
   312                                      ; 套娃, 创建下一级页表
   313 00000403 C70303C00000                mov dword [ebx + 0 * 8], PDT_PHY_ADDR | 3
   314 00000409 C7430400000000              mov dword [ebx + 0 * 8 + 4], 0
   315                                  
   316                                      ; 清 0
   317 00000410 BB00C00000                  mov ebx, PDT_PHY_ADDR
   318                                  
   319 00000415 B900040000                  mov ecx, 1024
   320 0000041A 31F6                        xor esi, esi
   321                                  .cls2:
   322 0000041C C7043300000000              mov dword [ebx + esi], 0
   323 00000423 83C604                      add esi, 4
   324 00000426 E2F4                        loop .cls2
   325                                  
   326                                      ; 在页目录表内创建与低端 2MB 对应的表项
   327 00000428 C70383000000                mov dword [ebx + 0 * 8], 0 | 0x83       ; 位 7、R/W 位、P 位是 1, 其他全是 0
   328 0000042E C7430400000000              mov dword [ebx + 0 * 8 + 4], 0
   329                                  
   330                                      ; 将物理内存的低端 2MB 映射到线性地址空间的高端, 内核处于高地址, 要做一次重复映射。0xFFFF800000000000--0xFFFF8000001FFFFF
   331 00000435 BB00A00000                  mov ebx, PML4_PHY_ADDR
   332                                  
   333 0000043A C7830008000003B000-         mov dword [ebx + 256 * 8], PDPT_PHY_ADDR | 3 ; 页目录表
   333 00000443 00                 
   334 00000444 C78304080000000000-         mov dword [ebx + 256 * 8 + 4], 0
   334 0000044D 00                 
   335                                  
   336                                      ; 因为要为每个进程都给予一个独立的 4 级头表(可以理解为指针数组), 而内核空间是所有进程共享的, 要在每个进程独立
   337                                      ; 的 4 级头表中内核公共部分填入一样的数据。页表机制的一个特点是 就是动态分配, 用时间换空间, 为了避免此特性使
   338                                      ; 每个进程不停的去同步 4 级头表中内核公共部分, 索性直接将 4 级头表中内核公共部分全部预分配好。详细解释见书中 135 页。
   339 0000044E B801010000                  mov eax, 257
   340 00000453 BA03001000                  mov edx, COR_PDPT_ADDR | 3
   341                                  .fill_pml4:
   342 00000458 8914C3                      mov dword [ebx + eax * 8], edx 
   343 0000045B C744C30400000000            mov dword [ebx + eax * 8 + 4], 0
   344 00000463 81C200100000                add edx, 0x1000
   345 00000469 40                          inc eax 
   346 0000046A 3DFF010000                  cmp eax, 511
   347 0000046F 72E7                        jb .fill_pml4
   348                                  
   349                                      ; 将预分配的页目录指针表全部清零
   350 00000471 B800001000                  mov eax, COR_PDPT_ADDR
   351                                  .zero_pdpt:
   352 00000476 C70000000000                mov dword [eax], 0
   353 0000047C 83C004                      add eax, 4
   354 0000047F 3D00E01F00                  cmp eax, COR_PDPT_ADDR + 0x1000 * 254
   355 00000484 72F0                        jb .zero_pdpt
   356                                  
   357                                      ; 将 cr3 寄存器指向 4 级头表
   358 00000486 B800A00000                  mov eax, PML4_PHY_ADDR
   359 0000048B 0F22D8                      mov cr3, eax 
   360                                  
   361                                      ; 开启物理扩展 PAE
   362 0000048E 0F20E0                      mov eax, cr4 
   363 00000491 0FBAE805                    bts eax, 5                              ; 位测试并置位
   364 00000495 0F22E0                      mov cr4, eax 
   365                                  
   366                                      ; 设置型号专属寄存器 IA32_EFER.LME, 允许 IA_32e 模式
   367 00000498 B9800000C0                  mov ecx, 0x0c0000080                    ; 指定型号专属寄存器 IA32_EFER
   368 0000049D 0F32                        rdmsr
   369 0000049F 0FBAE808                    bts eax, 8                              ; 设置 LME 位
   370 000004A3 0F30                        wrmsr 
   371                                  
   372                                      ; 开启分页功能
   373 000004A5 0F20C0                      mov eax, cr0 
   374 000004A8 0FBAE81F                    bts eax, 31                             ; 置位 cr0.PG
   375 000004AC 0F22C0                      mov cr0, eax 
   376                                  
   377                                      ; 打印 IA_32e 激活信息
   378 000004AF BB[37F10000]                mov ebx, ia_32e + LDR_PHY_ADDR
   379 000004B4 E80F000000                  call put_string_flat32
   380                                  
   381                                      ; 通过原返回的方式进入 64 位模式内核
   382 000004B9 666A18                      push word CORE_CODE64_SEL
   383 000004BC A104000200                  mov eax, dword [CORE_PHY_ADDR + 4]
   384 000004C1 0500000200                  add eax, CORE_PHY_ADDR
   385 000004C6 50                          push eax 
   386 000004C7 CB                          retf                                    ; 压入 GDT 选择子和地址
   387                                  
   388                                  ; ------------------------------------------------------------
   389                                  ; put_string_flat32
   390                                  ; 功能: 显示 0 终止的字符串并移动光标。只运行在32位保护模式下, 且使用平坦模型。
   391                                  ; 输入: EBX=字符串的线性地址
   392                                  ; ------------------------------------------------------------
   393                                  put_string_flat32:
   394 000004C8 53                          push ebx 
   395 000004C9 51                          push ecx 
   396                                  .getc:
   397 000004CA 8A0B                        mov cl, [ebx]
   398 000004CC 08C9                        or cl, cl                               ; 检测串结束标志 0
   399 000004CE 7408                        jz .exit                                
   400 000004D0 E806000000                  call put_char
   401 000004D5 43                          inc ebx 
   402 000004D6 EBF2                        jmp .getc
   403                                  
   404                                  .exit:
   405 000004D8 59                          pop ecx 
   406 000004D9 5B                          pop ebx 
   407                                  
   408 000004DA C3                          ret 
   409                                  
   410                                  ; ------------------------------------------------------------
   411                                  ; put_char
   412                                  ; 功能: 在当前光标处显示一个字符, 并推进光标, 仅用于段内调用
   413                                  ; 输入: CL=字符ASCII码
   414                                  ; ------------------------------------------------------------
   415                                  put_char:
   416 000004DB 60                          pushad 
   417                                  
   418 000004DC 66BAD403                    mov dx, 0x3d4                           ; 0x3d4 是 VGA 显卡的索引寄存器端口地址, 用于指定要操作的显卡寄存器。
   419 000004E0 B00E                        mov al, 0xe                             ; 0xe 是显卡的光标位置寄存器的索引值, 用于读取光标的高字节位置。
   420 000004E2 EE                          out dx, al                              ; 将 0xe 输出到端口 0x3d4, 
   421 000004E3 6642                        inc dx                                  ; 0x3d5 是显卡的数据寄存器端口地址, 用于读取或写入显卡寄存器的实际数据。
   422 000004E5 EC                          in al, dx                               ; 从端口 0x3d5 读取数据到 al, 读取了光标位置的高字节
   423                                  
   424 000004E6 88C4                        mov ah, al                              ; 存入 ah 
   425                                  
   426 000004E8 664A                        dec dx                                  ; 同上, 再获取低字节
   427 000004EA B00F                        mov al, 0x0f                            ; 0x0f 是显卡的光标位置寄存器的索引值, 用于读取光标的低字节位置。
   428 000004EC EE                          out dx, al 
   429 000004ED 6642                        inc dx 
   430 000004EF EC                          in al, dx 
   431                                  
   432 000004F0 6689C3                      mov bx, ax                              ; 此时 bx 中存储了字符的数目, 一个字符占两个字节
   433 000004F3 81E2FFFF0000                and edx, 0x0000ffff
   434                                  
   435 000004F9 80F90D                      cmp cl, 0x0d                            ; 回车符?
   436 000004FC 750E                        jnz .put_0a                             ; 不是回车符检查是不是换行符(0x0a)
   437                                  
   438 000004FE 6689D8                      mov ax, bx                              ; 处理回车符
   439 00000501 B350                        mov bl, 80                              ; 行宽 80
   440 00000503 F6F3                        div bl 
   441 00000505 F6E3                        mul bl                                  ; 移到本行起始
   442 00000507 6689C3                      mov bx, ax 
   443 0000050A EB19                        jmp .roll_screen
   444                                  
   445                                  .put_0a:
   446 0000050C 80F90A                      cmp cl, 0x0a                            ; 换行符?
   447 0000050F 7506                        jnz .put_other
   448                                  
   449 00000511 6683C350                    add bx, 80                              ; 处理换行符
   450 00000515 EB0E                        jmp .roll_screen
   451                                  
   452                                  .put_other:                                 ; 显示字符
   453 00000517 66D1E3                      shl bx, 1                               ; 在文本模式下, 显存中每个字符占用 2 个字节, 左移 1 位相当于将 bx 的值乘以 2, 从而将光标位置从字符索引转换为显存中的字节偏移量。
   454 0000051A 888B00800B00                mov [0xb8000 + ebx], cl                 ; 0xb800:0000(0xb8000) 是显存的起始地址
   455                                  
   456 00000520 66D1EB                      shr bx, 1                               ; 将光标位置移到下一个字符
   457 00000523 6643                        inc bx      
   458                                  
   459                                  .roll_screen:
   460 00000525 6681FBD007                  cmp bx, 2000                            ; 超出屏幕外? 
   461 0000052A 7C2F                        jl .set_cursor                          ; 设置光标
   462                                  
   463                                      ; 滚屏处理
   464 0000052C 53                          push ebx                                ; 保存光标位置               
   465                                  
   466 0000052D FC                          cld                                     ; 清除方向标志
   467 0000052E BEA0800B00                  mov esi, 0xb80a0                        ; 0xb80a0 是显存中第 2 行字符的起始地址。源地址
   468 00000533 BF00800B00                  mov edi, 0xb8000                        ; 0xb8000 是显存起始地址。目标地址
   469 00000538 B9C0030000                  mov ecx, 960                            ; 960 == 24 x 80 x 2 / 4, 滚屏操作需要将第 2 行到第 25 行的内容向上移动一行, 覆盖第 1 行的内容。
   470 0000053D F3A5                        rep movsd                               ; rep movsd 会根据 ecx 的值重复移动数据, 直到 ecx 为 0。每次移动 4 个字节
   471                                      
   472                                      ; 清除屏幕最后一行
   473 0000053F BB000F0000                  mov ebx, 3840                           ; 3840 == 24 x 80 x 2, 设置光标位置为屏幕最后一行的起始位置。
   474 00000544 B950000000                  mov ecx, 80                             ; ecx 是循环次数
   475                                  
   476                                  .cls:
   477 00000549 66C78300800B002007          mov word[0xb8000 + ebx], 0x0720         ; 0x0720 是空格字符, 黑色背景
   478 00000552 83C302                      add ebx, 2
   479 00000555 E2F2                        loop .cls 
   480                                  
   481 00000557 5B                          pop ebx                                 ; 恢复光标
   482 00000558 83EB50                      sub ebx, 80                             ; 上移一行
   483                                  
   484                                  .set_cursor:                                ; 设置光标
   485 0000055B 66BAD403                    mov dx, 0x3d4
   486 0000055F B00E                        mov al, 0x0e
   487 00000561 EE                          out dx, al
   488 00000562 6642                        inc dx 
   489 00000564 88F8                        mov al, bh 
   490 00000566 EE                          out dx, al 
   491                                  
   492 00000567 664A                        dec dx 
   493 00000569 B00F                        mov al, 0x0f
   494 0000056B EE                          out dx, al 
   495 0000056C 6642                        inc dx 
   496 0000056E 88D8                        mov al, bl 
   497 00000570 EE                          out dx, al 
   498                                  
   499 00000571 61                          popad 
   500 00000572 C3                          ret 
   501                                  
   502                                  ; ------------------------------------------------------------
   503                                  ; read_hard_disk_0
   504                                  ; 功能: 从硬盘中读取一个扇区
   505                                  ; 输入: eax=逻辑扇区号, ebx=目标缓冲区地址
   506                                  ; 返回: ebx = ebx + 512
   507                                  ; ------------------------------------------------------------
   508                                  read_hard_disk_0:
   509 00000573 50                          push eax
   510 00000574 51                          push ecx
   511 00000575 52                          push edx 
   512                                  
   513 00000576 50                          push eax 
   514                                  
   515 00000577 66BAF201                    mov dx, 0x1f2                           ; 0x1f2 是硬盘控制器的一个端口地址, 用于指定要读取的扇区数量。
   516 0000057B B001                        mov al, 1
   517 0000057D EE                          out dx, al                              ; 将 1 写入到硬盘控制器的端口 0x1f2, 告诉硬盘控制器接下来要读取一个扇区。
   518                                  
   519 0000057E 6642                        inc dx                                  ; 0x1f3
   520 00000580 58                          pop eax 
   521 00000581 EE                          out dx, al                              ; LBA 地址 7 ~ 0
   522                                  
   523 00000582 6642                        inc dx                                  ; 0x1f4
   524 00000584 B108                        mov cl, 8
   525 00000586 D3E8                        shr eax, cl 
   526 00000588 EE                          out dx, al                              ; LBA 地址 15 ~ 8
   527                                  
   528 00000589 6642                        inc dx                                  ; 0x1f5
   529 0000058B D3E8                        shr eax, cl 
   530 0000058D EE                          out dx, al                              ; LBA 地址 23 ~ 16
   531                                  
   532 0000058E 6642                        inc dx                                  ; 0x1f6
   533 00000590 D3E8                        shr eax, cl 
   534 00000592 0CE0                        or al, 0xe0                             ; 第一硬盘
   535 00000594 EE                          out dx, al                              ; LBA 地址 27 ~ 24
   536                                  
   537 00000595 6642                        inc dx                                  ; 0x1f7
   538 00000597 B020                        mov al, 0x20    
   539 00000599 EE                          out dx, al                              ; 读命令
   540                                  
   541                                  .waits:
   542 0000059A EC                          in al, dx 
   543 0000059B A808                        test al, 8
   544 0000059D 74FB                        jz .waits                               ; 忙或数据还没准备好, 循环查询
   545                                  
   546 0000059F B900010000                  mov ecx, 256                            ; 总共要读取的字数, 循环次数
   547 000005A4 66BAF001                    mov dx, 0x1f0
   548                                  
   549                                  .readw:
   550 000005A8 66ED                        in ax, dx                               ; 循环去读硬盘数据写入指定内存
   551 000005AA 668903                      mov [ebx], ax 
   552 000005AD 83C302                      add ebx, 2
   553 000005B0 E2F6                        loop .readw
   554                                  
   555 000005B2 5A                          pop edx 
   556 000005B3 59                          pop ecx 
   557 000005B4 58                          pop eax 
   558                                  
   559 000005B5 C3                          ret 
   560                                  
   561                                  SECTION trail
   562                                      ldr_end:
>>>>>>> 83ea3db (fix: 第三章终于跑通! 还是在 windows, 虚拟机上没法用 virtual-box)
