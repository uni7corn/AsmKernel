     1                                  ; 内核加载器
     2                                  
     3                                  %include "./common/global_defs.asm"
     1                              <1> ; 全局常量定义
     2                              <1> 
     3                              <1> %ifndef _GLOBAL_DEFS_
     4                              <1>     %define _GLOBAL_DEFS_
     5                              <1> 
     6                              <1>     SDA_PHY_ADDR        equ     0x00007e00	; 系统数据区的起始物理地址
     7                              <1>     PML5_PHY_ADDR       equ     0x00009000	; 内核 5 级头表物理地址
     8                              <1>     PML4_PHY_ADDR       equ     0x0000a000	; 内核 4 级头表物理地址
     9                              <1>     PDPT_PHY_ADDR       equ     0x0000b000	; 对应于低端 2MB 的内核页目录指针表物理地址
    10                              <1>     PDT_PHY_ADDR        equ     0x0000c000	; 对应于低端 2MB 的页目录表物理地址
    11                              <1>     PT_PHY_ADDR         equ     0x0000d000	; 对应于低端 2MB 的内核页表的物理地址
    12                              <1>     IDT_PHY_ADDR        equ     0x0000e000	; 中断描述符表的物理地址
    13                              <1>     LDR_PHY_ADDR        equ     0x0000f000	; 用于安装内核加载器的起始物理地址
    14                              <1>     GDT_PHY_ADDR        equ     0x00010000	; 全局描述符表 GDT 的物理地址
    15                              <1>     CORE_PHY_ADDR       equ     0x00020000	; 内核的起始物理地址
    16                              <1>     COR_PDPT_ADDR       equ     0x00100000	; 从这个物理地址开始的 1MB 是内核的 254 个页目录指针表
    17                              <1> 
    18                              <1>     LDR_START_SECTOR    equ     1      	        ; 内核加载器在硬盘上的起始逻辑扇区号
    19                              <1>     COR_START_SECTOR    equ     9      	        ; 内核程序在硬盘上的起始逻辑扇区号
    20                              <1> 
    21                              <1>     ; 虚拟内存空间的高端起始于线性地址 0xffff800000000000
    22                              <1>     UPPER_LINEAR_START  equ     0xffff800000000000  
    23                              <1>     UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	    ; 内核的高端线性地址
    24                              <1>     UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ; 文本显示缓冲区的高端起始线性地址
    25                              <1>     UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	    ; 系统数据区的高端线性地址
    26                              <1>     UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	    ; GDT 的高端线性地址
    27                              <1>     UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	    ; IDT 的高端线性地址
    28                              <1> 
    29                              <1>     ; 与全局描述符表有关的选择子定义, 及内存管理有关的常量定义
    30                              <1>     CORE_CODE64_SEL     equ     0x0018	; 内核代码段的描述符选择子(RPL=00)
    31                              <1>     CORE_STACK64_SEL    equ     0x0020	; 内核栈段的描述符选择子(RPL=00)
    32                              <1>     RESVD_DESC_SEL      equ     0x002b	; 保留的描述符选择子
    33                              <1>     USER_CODE64_SEL     equ     0x003b	; 3 特权级代码段的描述符选择子(RPL=11)
    34                              <1>     USER_STACK64_SEL    equ     0x0033	; 3 特权级栈段的描述符选择子(RPL=11)
    35                              <1> 
    36                              <1>     PHY_MEMORY_SIZE     equ     32    	            ; 物理内存大小(MB), 要求至少 3MB
    37                              <1>     CORE_ALLOC_START    equ     0xffff800000200000	; 在虚拟地址空间高端(内核)分配内存时的起始地址
    38                              <1>     USER_ALLOC_START    equ     0x0000000000000000	; 在每个任务虚拟地址空间低端分配内存时的起始地址
    39                              <1> 
    40                              <1>     ; 创建任务时, 需要分配一个物理页作为新任务的 4 级头表, 并分配一个临时的线性地址来初始化这个页
    41                              <1>     NEW_PML4_LINEAR     equ     0xffffff7ffffff000	; 用来映射新任务 4 级头表的线性地址
    42                              <1>     LAPIC_START_ADDR    equ     0xffffff7fffffe000	; LOCAL APIC 寄存器的起始线性地址
    43                              <1>     IOAPIC_START_ADDR   equ     0xffffff7fffffd000	; I/O APIC 寄存器的起始线性地址
    44                              <1>     AP_START_UP_ADDR    equ     0x0000f000 	        ; 应用处理器(AP)启动代码的物理地址
    45                              <1>     SUGG_PREEM_SLICE    equ     55          	    ; 推荐的任务/线程抢占时间片长度(毫秒)
    46                              <1> 
    47                              <1>     ; 多处理器环境下的自旋锁加锁宏。需要两个参数: 寄存器, 以及一个对应宽度的锁变量
    48                              <1>     %macro  SET_SPIN_LOCK 2             ; 两个参数, 分别是寄存器 %1 和锁变量 %2
    49                              <1>             %%spin_lock:
    50                              <1>                     cmp %2, 0           ; 看一眼锁现在是不是 0
    51                              <1>                     je %%get_lock      	; 如果是 0，说明没人占，跳过去抢
    52                              <1>                     pause				; 不是 0，先喘口气（降低 CPU 占用）
    53                              <1>                     jmp %%spin_lock    	; 继续看
    54                              <1>             %%get_lock:
    55                              <1>                     mov %1, 1
    56                              <1>                     xchg %1, %2         ; 用 xchg 的“原子交换”能力抢锁，抢不到就一直循环（自旋）
    57                              <1>                     cmp %1, 0          	; 交换回来的 %2 旧值是 0 吗？
    58                              <1>                     jne %%spin_lock   	; 不是 0 说明别人先插了旗，回到开头重抢
    59                              <1>     %endmacro
    60                              <1> 
    61                              <1> %endif
     4                                  
     5                                  SECTION loader
     6 00000000 6C696E6F                    marker          dd "lino"           ; 内核加载器有效标志    +00 将老师的 lizh, 改为了 lino, hh
     7 00000004 [00000000]                  length          dd ldr_end          ; 内核加载器的长度      +04
     8 00000008 [A8010000]                  entry           dd start            ; 内核加载器的入口点    +08
     9                                  
    10 0000000C 4D6F7573654865726F-         msg0            db "MouseHero x64 course learning.", 0x0d, 0x0a
    10 00000015 2078363420636F7572-
    10 0000001E 7365206C6561726E69-
    10 00000027 6E672E0D0A         
    11                                  
    12 0000002C 78363420617661696C-         arch0           db "x64 available(64-bit processor installed).", 0x0d, 0x0a
    12 00000035 61626C652836342D62-
    12 0000003E 69742070726F636573-
    12 00000047 736F7220696E737461-
    12 00000050 6C6C6564292E0D0A   
    13 00000058 783634206E6F742061-         arch1           db "x64 not available(64-bit processor not installed).", 0x0d, 0x0a
    13 00000061 7661696C61626C6528-
    13 0000006A 36342D626974207072-
    13 00000073 6F636573736F72206E-
    13 0000007C 6F7420696E7374616C-
    13 00000085 6C6564292E0D0A     
    14                                  
    15                                      ; 汇编版格式化字符串
    16 0000008C 50726F636573736F72-         brand_mag       db "Processor:"
    16 00000095 3A                 
    17 00000096 00<rep 30h>                     brand       times 48 db 0
    18 000000C6 0D0A                                        db 0x0d, 0x0a
    19                                  
    20 000000C8 506879736963616C20-         cpu_addr        db "Physical address size:"
    20 000000D1 616464726573732073-
    20 000000DA 697A653A           
    21 000000DE 20<rep 3h>                      paddr       times 3 db " "
    22 000000E1 2C                                          db ","
    23 000000E2 4C696E656172206164-                         db "Linear address size:"
    23 000000EB 64726573732073697A-
    23 000000F4 653A               
    24 000000F6 20<rep 3h>                      laddr       times 3 db " "
    25 000000F9 0D0A                                        db 0x0d, 0x0a
    26                                  
    27 000000FB 50726F74656374206D-         protect         db "Protect mode has been entered to prepare for IA-32e mode.", 0x0d, 0x0a, 0
    27 00000104 6F6465206861732062-
    27 0000010D 65656E20656E746572-
    27 00000116 656420746F20707265-
    27 0000011F 7061726520666F7220-
    27 00000128 49412D333265206D6F-
    27 00000131 64652E0D0A00       
    28                                  
    29 00000137 49412D333265206D6F-         ia_32e          db "IA-32e mode(aka,long mode) is active.Specifically,"
    29 00000140 646528616B612C6C6F-
    29 00000149 6E67206D6F64652920-
    29 00000152 697320616374697665-
    29 0000015B 2E5370656369666963-
    29 00000164 616C6C792C         
    30 00000169 636F6D706174696269-                         db "compatibility mode.", 0x0d, 0x0a, 0
    30 00000172 6C697479206D6F6465-
    30 0000017B 2E0D0A00           
    31                                  
    32                                  ; ------------------------------------------------------------
    33                                  ; put_string_by_bios
    34                                  ; 功能: 在光标当前位置按指定颜色打印字符串, 内平栈
    35                                  ; 输入: 字符串地址, 长度, 颜色属性
    36                                  ; ------------------------------------------------------------
    37                                  put_string_by_bios:
    38 0000017F B403                        mov ah, 0x03                        ; 获取光标位置
    39 00000181 B700                        mov bh, 0x00
    40 00000183 CD10                        int 0x10                            ; 返回 dh=行, dl=列
    41                                  
    42 00000185 678B6C2402                  mov bp, [esp + 2]                   ; 字符串地址       
    43 0000018A 678B4C2404                  mov cx, [esp + 4]                   ; 长度    
    44 0000018F 678B5C2406                  mov bx, [esp + 6]                   ; 颜色属性
    45 00000194 B80113                      mov ax, 0x1301                      ; 写字符串, 光标移动
    46 00000197 CD10                        int 0x10
    47                                  
    48 00000199 C20600                      ret 6
    49                                  
    50                                  no_ia_32e:
    51 0000019C 6A4F                        push 0x004f
    52 0000019E 6A34                        push brand_mag - arch1
    53 000001A0 68[5800]                    push arch1
    54 000001A3 E8D9FF                      call put_string_by_bios
    55                                  
    56 000001A6 FA                          cli
    57 000001A7 F4                          hlt
    58                                  
    59                                  start:
    60 000001A8 6A4F                        push 0x004f
    61 000001AA 6A20                        push arch0 - msg0
    62 000001AC 68[0C00]                    push msg0
    63 000001AF E8CDFF                      call put_string_by_bios
    64                                  
    65                                      ; 检查处理器是否支持 ia-32e 模式
    66 000001B2 66B800000080                mov eax, 0x80000000                 ; 返回处理器支持的最大扩展功能号
    67 000001B8 0FA2                        cpuid                               ; 返回值在 eax 中
    68 000001BA 663D01000080                cmp eax, 0x80000001
    69 000001C0 72DA                        jb no_ia_32e                        ; 不支持就到 no_ia_32e 处执行
    70                                  
    71 000001C2 66B801000080                mov eax, 0x80000001                 ; edx 返回扩展的签名和特性标志位
    72 000001C8 0FA2                        cpuid
    73 000001CA 660FBAE21D                  bt edx, 29                          ; 低 29 位是 IA-32e 模式支持标志, bt 指令会影响 cf  标志位
    74 000001CF 73CB                        jnc no_ia_32e                       ; 不支持就到 no_ia_32e 处执行
    75                                  
    76 000001D1 6A07                        push 0x0007                         ; 黑底白字
    77 000001D3 6A2C                        push arch1 - arch0
    78 000001D5 68[2C00]                    push arch0
    79 000001D8 E8A4FF                      call put_string_by_bios
    80                                  
    81                                      ; 显示处理器商标信息
    82 000001DB 66B800000080                mov eax, 0x80000000 
    83 000001E1 0FA2                        cpuid
    84 000001E3 663D04000080                cmp eax, 0x80000004
    85 000001E9 725B                        jb .no_brand
    86                                  
    87 000001EB 66B802000080                mov eax, 0x80000002
    88 000001F1 0FA2                        cpuid
    89 000001F3 66A3[9600]                  mov [brand + 0x00], eax
    90 000001F7 66891E[9A00]                mov [brand + 0x04], ebx
    91 000001FC 66890E[9E00]                mov [brand + 0x08], ecx
    92 00000201 668916[A200]                mov [brand + 0x0c], edx
    93                                  
    94 00000206 66B803000080                mov eax, 0x80000003
    95 0000020C 0FA2                        cpuid
    96 0000020E 66A3[A600]                  mov [brand + 0x10], eax
    97 00000212 66891E[AA00]                mov [brand + 0x14], ebx
    98 00000217 66890E[AE00]                mov [brand + 0x18], ecx
    99 0000021C 668916[B200]                mov [brand + 0x1c], edx
   100                                  
   101 00000221 66B804000080                mov eax, 0x80000004
   102 00000227 0FA2                        cpuid
   103 00000229 66A3[B600]                  mov [brand + 0x20], eax
   104 0000022D 66891E[BA00]                mov [brand + 0x24], ebx
   105 00000232 66890E[BE00]                mov [brand + 0x28], ecx
   106 00000237 668916[C200]                mov [brand + 0x2c], edx
   107                                  
   108 0000023C 6A07                        push 0x0007
   109 0000023E 6A3C                        push cpu_addr - brand_mag
   110 00000240 68[8C00]                    push brand_mag
   111 00000243 E839FF                      call put_string_by_bios
   112                                  
   113                                      ; 第五章再回来填坑----
   114                                  .no_brand:
   115                                      ; 获取当前系统的物理内存布局信息(使用 int 0x15, E820 功能。俗称 E820 内存)
   116 00000246 06                          push es 
   117                                  
   118 00000247 BBE007                      mov bx, SDA_PHY_ADDR >> 4               ; 切换到系统数据区
   119 0000024A 8EC3                        mov es, bx 
   120 0000024C 26C70616000000              mov word [es:0x16], 0
   121 00000253 6631DB                      xor ebx, ebx                            ; 首次调用 int 0x15 时必须为 0
   122 00000256 BF1800                      mov di, 0x18                            ; 系统数据区内的偏移
   123                                  
   124                                  .mlookup:
   125 00000259 66B820E80000                mov eax, 0xe820
   126 0000025F 66B920000000                mov ecx, 32
   127 00000265 66BA50414D53                mov edx, "PAMS"
   128 0000026B CD15                        int 0x15
   129 0000026D 83C720                      add di, 32
   130 00000270 26FF061600                  inc word [es:0x16]
   131 00000275 6609DB                      or ebx, ebx
   132 00000278 75DF                        jnz .mlookup
   133                                  
   134 0000027A 07                          pop es
   135                                  
   136                                      ; 第五章再回来填坑----
   137                                      ; 获取存储处理器的物理/虚拟地址尺寸信息
   138 0000027B 66B800000080                mov eax, 0x80000000                     
   139 00000281 0FA2                        cpuid
   140 00000283 663D08000080                cmp eax, 0x80000008
   141 00000289 B82430                      mov ax, 0x3024                          ; 设置默认的处理器物理/逻辑地址位数 36(0x24) 和 48(0x30)
   142 0000028C 7208                        jb .no_plsize
   143                                  
   144 0000028E 66B808000080                mov eax, 0x80000008                     ; 执行后, ax 中 0-7 位(al)是物理地址尺寸, 8-15 位(ah)是虚拟地址尺寸
   145 00000294 0FA2                        cpuid
   146                                  
   147                                  .no_plsize:
   148                                      ; 保存物理和虚拟地址尺寸到系统数据区
   149 00000296 1E                          push ds 
   150 00000297 BBE007                      mov bx, SDA_PHY_ADDR >> 4               ; 切换到系统数据区
   151 0000029A 8EDB                        mov ds, bx 
   152 0000029C A30000                      mov word [0], ax                        ; 记录处理器的物理/虚拟地址尺寸
   153 0000029F 1F                          pop ds 
   154                                  
   155                                      ; 准备显示存储器的物理地址尺寸信息
   156 000002A0 50                          push ax                                 ; 备份 ax
   157                                  
   158 000002A1 25FF00                      and ax, 0x00ff                          ; 只要 al 中的物理地址
   159 000002A4 BE0200                      mov si, 2
   160 000002A7 B30A                        mov bl, 10
   161                                  
   162                                  .re_div0:
   163 000002A9 F6F3                        div bl                                  ; 16 位除法, 商在 al 中, 余数在 ah 里
   164 000002AB 80C430                      add ah, 0x30                            ; ASCII 码
   165 000002AE 88A4[DE00]                  mov [paddr + si], ah                    ; 低位在高地址
   166 000002B2 4E                          dec si 
   167 000002B3 25FF00                      and ax, 0x00ff
   168 000002B6 75F1                        jnz .re_div0
   169                                  
   170                                      ; 准备显示处理器的虚拟地址尺寸信息
   171 000002B8 58                          pop ax 
   172                                  
   173 000002B9 C1E808                      shr ax, 8                               ; 将虚拟地址移到 al 重复上边的逻辑
   174 000002BC BE0200                      mov si, 2
   175 000002BF B30A                        mov bl, 10
   176                                  .re_div1:
   177 000002C1 F6F3                        div bl 
   178 000002C3 80C430                      add ah, 0x30 
   179 000002C6 88A4[F600]                  mov [laddr + si], ah 
   180 000002CA 4E                          dec si 
   181 000002CB 25FF00                      and ax, 0x00ff
   182 000002CE 75F1                        jnz .re_div1
   183                                  
   184                                      ; 显示处理器的物理/虚拟地址尺寸信息 
   185 000002D0 6A07                        push 0x0007
   186 000002D2 6A33                        push protect - cpu_addr
   187 000002D4 68[C800]                    push cpu_addr
   188 000002D7 E8A5FE                      call put_string_by_bios
   189                                  
   190                                      ; 以下开始进入保护模式, 为 IA-32e 模式做必要的准备工作
   191 000002DA B80010                      mov ax, GDT_PHY_ADDR >> 4               ; 计算 GDT 所在的逻辑段地址
   192 000002DD 8ED8                        mov ds, ax 
   193                                  
   194                                      ; 跳过 0# 号描述符的槽位, 处理器规定 0# 号描述符为空
   195                                      
   196                                      ; 创建 1# 描述符, 保护模式下的代码段描述符
   197 000002DF 66C7060800FFFF0000          mov dword [0x08], 0x0000ffff            ; 基地址为0, 界限0xFFFFF, DPL=00, 4KB 粒度, 代码段描述符, 向上扩展
   198 000002E8 66C7060C000098CF00          mov dword [0x0c], 0x00cf9800
   199                                      
   200                                      ; 创建 2# 描述符, 保护模式下的数据段和堆栈段描述符
   201 000002F1 66C7061000FFFF0000          mov dword [0x10], 0x0000ffff            ; 基地址为0, 界限0xFFFFF, DPL=00, 4KB 粒度, 数据段描述符, 向上扩展
   202 000002FA 66C70614000092CF00          mov dword [0x14], 0x00cf9200
   203                                  
   204                                      ; 创建 3# 描述符, 64 位模式下的代码段描述符。为进入 64 位提前作准备, 其 L 位是 1
   205 00000303 66C7061800FFFF0000          mov dword [0x18], 0x0000ffff            ; 基地址为0, 界限0xFFFFF, DPL=00, 4KB 粒度, L=1, 代码段描述符, 向上扩展
   206 0000030C 66C7061C000098AF00          mov dword [0x1c], 0x00af9800
   207                                  
   208                                      ; 记录 GDT 的基地址和界限值
   209 00000315 B8E007                      mov ax, SDA_PHY_ADDR >> 4               ; 切换到系统数据区
   210 00000318 8ED8                        mov ds, ax  
   211                                  
   212 0000031A C70602001F00                mov word[2], 0x1f                       ; 描述符表的界限
   213 00000320 66C706040000000100          mov dword[4], GDT_PHY_ADDR              ; GDT 的线性基地址
   214                                  
   215                                      ; 将 gdt 表的地址加载到 GDTR 寄存器
   216 00000329 0F01160200                  lgdt [2]
   217                                  
   218 0000032E E492                        in al, 0x92                             ; 南桥芯片内的端口
   219 00000330 0C02                        or al, 0000_0010B
   220 00000332 E692                        out 0x92, al                            ; 打开处理器的第 21 根地址线 A20
   221                                  
   222 00000334 FA                          cli                                     ; 关闭中断
   223                                  
   224 00000335 0F20C0                      mov eax, cr0                            ; 设置控制寄存器 CR0 的 PE 位, 将处理器从实模式切换到保护模式。
   225 00000338 6683C801                    or eax, 1
   226 0000033C 0F22C0                      mov cr0, eax 
   227                                  
   228                                      ; 以下进入保护模式
   229 0000033F 66EA[47F30000]0800          jmp 0x0008: dword LDR_PHY_ADDR + flush  ; 0x0008 是 16 位描述符选择子, 从 GDT 中选择第二个描述符。jmp 后清流水线并串行化处理器, 跳转到 flush
   230                                  
   231                                      [bits 32]
   232                                  flush:
   233 00000347 B810000000                  mov eax, 0x0010                         ; 加载数据段(4GB)选择子
   234 0000034C 8ED8                        mov ds, eax
   235 0000034E 8EC0                        mov es, eax
   236 00000350 8EE0                        mov fs, eax
   237 00000352 8EE8                        mov gs, eax
   238 00000354 8ED0                        mov ss, eax  
   239 00000356 BC007C0000                  mov esp, 0x7c00                         ; 堆栈指针
   240                                  
   241                                      ; 显示信息, 在保护模式下位进入 IA-32e 模式做准备
   242 0000035B BB[FBF00000]                mov ebx, LDR_PHY_ADDR + protect
   243 00000360 E863010000                  call put_string_flat32
   244                                  
   245                                      ; 以下加载系统核心程序
   246 00000365 BF00000200                  mov edi, CORE_PHY_ADDR
   247                                  
   248 0000036A B809000000                  mov eax, COR_START_SECTOR
   249 0000036F 89FB                        mov ebx, edi                            ; 起始地址
   250 00000371 E8FD010000                  call read_hard_disk_0                   ; 读取程序起始第一个扇区
   251                                  
   252                                      ; 判断程序大小
   253 00000376 8B07                        mov eax, [edi]                          ; 内核程序大小
   254 00000378 31D2                        xor edx, edx 
   255 0000037A B900020000                  mov ecx, 512                            ; 每个扇区大小为 512
   256 0000037F F7F1                        div ecx                                 ; 商存储在 eax 中, 余数存储在 edx 中
   257                                  
   258                                      ; 处理长度 < 512 字节的情况
   259 00000381 09C0                        or eax, eax 
   260 00000383 7419                        jz pge
   261                                      ; 处理长度 >= 512 字节的情况
   262 00000385 09D2                        or edx, edx 
   263 00000387 7505                        jnz @1
   264 00000389 48                          dec eax 
   265 0000038A 09C0                        or eax, eax                             ; 正好为 512 时, 单独处理
   266 0000038C 7410                        jz pge
   267                                  @1:
   268                                      ; 读取剩余扇区
   269 0000038E 89C1                        mov ecx, eax                            ; 循环次数
   270 00000390 B809000000                  mov eax, COR_START_SECTOR
   271 00000395 40                          inc eax 
   272                                  @2:
   273 00000396 E8D8010000                  call read_hard_disk_0
   274 0000039B 40                          inc eax
   275 0000039C E2F8                        loop @2
   276                                  
   277                                  pge:
   278                                      ; 回填内核加载地址的物理地址到内核程序头部
   279 0000039E C70508000200000002-         mov dword [CORE_PHY_ADDR + 0x08], CORE_PHY_ADDR
   279 000003A7 00                 
   280 000003A8 C7050C000200000000-         mov dword [CORE_PHY_ADDR + 0x0c], 0
   280 000003B1 00                 
   281                                  
   282                                      ; 创建 4 级分页系统, 只包含基本部分, 覆盖低端 1 MB物理内存
   283 000003B2 BB00A00000                  mov ebx, PML4_PHY_ADDR                  ; 找个地方存四级页表
   284                                  
   285                                      ; 4 级页表清零
   286 000003B7 B900040000                  mov ecx, 1024
   287 000003BC 31F6                        xor esi, esi 
   288                                  .cls0:
   289 000003BE C7043300000000              mov dword [ebx + esi], 0
   290 000003C5 83C604                      add esi, 4
   291 000003C8 E2F4                        loop .cls0
   292                                  
   293                                      ; 在 4 级页表内最后一项存放自身地址, 这样可以通过虚拟地址访问表中最后一项来获取页表的真实地址
   294 000003CA C783F80F000003A000-         mov dword [ebx + 511 * 8], PML4_PHY_ADDR | 3    ; 添加属性
   294 000003D3 00                 
   295 000003D4 C783FC0F0000000000-         mov dword [ebx + 511 * 8 + 4], 0
   295 000003DD 00                 
   296                                  
   297                                      ; 映射虚拟地址与物理地址的低端 2 MB, 确保开启分页后也可以正常访问, 即地址经过页表转换后不变。
   298                                      ; 0x0000000000000000--0x00000000001FFFFF 低 48 位按 9 9 9 9 12 分割进行四级分页查表。而高 16 位无效, 填充符号位
   299 000003DE C70303B00000                mov dword [ebx + 0 * 8], PDPT_PHY_ADDR  | 3     ; 添加属性
   300 000003E4 C7430400000000              mov dword [ebx + 0 * 8 + 4], 0
   301                                  
   302                                      ; 将页目录指针表中的内容清 0
   303 000003EB BB00B00000                  mov ebx, PDPT_PHY_ADDR
   304                                  
   305 000003F0 B900040000                  mov ecx, 1024
   306 000003F5 31F6                        xor esi, esi 
   307                                  .cls1:
   308 000003F7 C7043300000000              mov dword [ebx + esi], 0
   309 000003FE 83C604                      add esi, 4
   310 00000401 E2F4                        loop .cls1
   311                                  
   312                                      ; 套娃, 创建下一级页表
   313 00000403 C70303C00000                mov dword [ebx + 0 * 8], PDT_PHY_ADDR | 3
   314 00000409 C7430400000000              mov dword [ebx + 0 * 8 + 4], 0
   315                                  
   316                                      ; 清 0
   317 00000410 BB00C00000                  mov ebx, PDT_PHY_ADDR
   318                                  
   319 00000415 B900040000                  mov ecx, 1024
   320 0000041A 31F6                        xor esi, esi
   321                                  .cls2:
   322 0000041C C7043300000000              mov dword [ebx + esi], 0
   323 00000423 83C604                      add esi, 4
   324 00000426 E2F4                        loop .cls2
   325                                  
   326                                      ; 在页目录表内创建与低端 2MB 对应的表项
   327 00000428 C70383000000                mov dword [ebx + 0 * 8], 0 | 0x83       ; 位 7、R/W 位、P 位是 1, 其他全是 0
   328 0000042E C7430400000000              mov dword [ebx + 0 * 8 + 4], 0
   329                                  
   330                                      ; 将物理内存的低端 2MB 映射到线性地址空间的高端, 内核处于高地址, 要做一次重复映射。0xFFFF800000000000--0xFFFF8000001FFFFF
   331 00000435 BB00A00000                  mov ebx, PML4_PHY_ADDR
   332                                  
   333 0000043A C7830008000003B000-         mov dword [ebx + 256 * 8], PDPT_PHY_ADDR | 3 ; 页目录表
   333 00000443 00                 
   334 00000444 C78304080000000000-         mov dword [ebx + 256 * 8 + 4], 0
   334 0000044D 00                 
   335                                  
   336                                      ; 因为要为每个进程都给予一个独立的 4 级头表(可以理解为指针数组), 而内核空间是所有进程共享的, 要在每个进程独立
   337                                      ; 的 4 级头表中内核公共部分填入一样的数据。页表机制的一个特点是 就是动态分配, 用时间换空间, 为了避免此特性使
   338                                      ; 每个进程不停的去同步 4 级头表中内核公共部分, 索性直接将 4 级头表中内核公共部分全部预分配好。详细解释见书中 135 页。
   339 0000044E B801010000                  mov eax, 257
   340 00000453 BA03001000                  mov edx, COR_PDPT_ADDR | 3
   341                                  .fill_pml4:
   342 00000458 8914C3                      mov dword [ebx + eax * 8], edx 
   343 0000045B C744C30400000000            mov dword [ebx + eax * 8 + 4], 0
   344 00000463 81C200100000                add edx, 0x1000
   345 00000469 40                          inc eax 
   346 0000046A 3DFF010000                  cmp eax, 511
   347 0000046F 72E7                        jb .fill_pml4
   348                                  
   349                                      ; 将预分配的页目录指针表全部清零
   350 00000471 B800001000                  mov eax, COR_PDPT_ADDR
   351                                  .zero_pdpt:
   352 00000476 C70000000000                mov dword [eax], 0
   353 0000047C 83C004                      add eax, 4
   354 0000047F 3D00E01F00                  cmp eax, COR_PDPT_ADDR + 0x1000 * 254
   355 00000484 72F0                        jb .zero_pdpt
   356                                  
   357                                      ; 将 cr3 寄存器指向 4 级头表
   358 00000486 B800A00000                  mov eax, PML4_PHY_ADDR
   359 0000048B 0F22D8                      mov cr3, eax 
   360                                  
   361                                      ; 开启物理扩展 PAE
   362 0000048E 0F20E0                      mov eax, cr4 
   363 00000491 0FBAE805                    bts eax, 5                              ; 位测试并置位
   364 00000495 0F22E0                      mov cr4, eax 
   365                                  
   366                                      ; 设置型号专属寄存器 IA32_EFER.LME, 允许 IA_32e 模式
   367 00000498 B9800000C0                  mov ecx, 0x0c0000080                    ; 指定型号专属寄存器 IA32_EFER
   368 0000049D 0F32                        rdmsr
   369 0000049F 0FBAE808                    bts eax, 8                              ; 设置 LME 位
   370 000004A3 0F30                        wrmsr 
   371                                  
   372                                      ; 开启分页功能
   373 000004A5 0F20C0                      mov eax, cr0 
   374 000004A8 0FBAE81F                    bts eax, 31                             ; 置位 cr0.PG
   375 000004AC 0F22C0                      mov cr0, eax 
   376                                  
   377                                      ; 打印 IA_32e 激活信息
   378 000004AF BB[37F10000]                mov ebx, ia_32e + LDR_PHY_ADDR
   379 000004B4 E80F000000                  call put_string_flat32
   380                                  
   381                                      ; 通过远返回的方式进入 64 位模式内核
   382 000004B9 666A18                      push word CORE_CODE64_SEL
   383 000004BC A104000200                  mov eax, dword [CORE_PHY_ADDR + 4]
   384 000004C1 0500000200                  add eax, CORE_PHY_ADDR
   385 000004C6 50                          push eax 
   386 000004C7 CB                          retf                                    ; 压入 GDT 选择子和地址
   387                                  
   388                                  ; ------------------------------------------------------------
   389                                  ; put_string_flat32
   390                                  ; 功能: 显示 0 终止的字符串并移动光标。只运行在32位保护模式下, 且使用平坦模型。
   391                                  ; 输入: EBX=字符串的线性地址
   392                                  ; ------------------------------------------------------------
   393                                  put_string_flat32:
   394 000004C8 53                          push ebx 
   395 000004C9 51                          push ecx 
   396                                  .getc:
   397 000004CA 8A0B                        mov cl, [ebx]
   398 000004CC 08C9                        or cl, cl                               ; 检测串结束标志 0
   399 000004CE 7408                        jz .exit                                
   400 000004D0 E806000000                  call put_char
   401 000004D5 43                          inc ebx 
   402 000004D6 EBF2                        jmp .getc
   403                                  
   404                                  .exit:
   405 000004D8 59                          pop ecx 
   406 000004D9 5B                          pop ebx 
   407                                  
   408 000004DA C3                          ret 
   409                                  
   410                                  ; ------------------------------------------------------------
   411                                  ; put_char
   412                                  ; 功能: 在当前光标处显示一个字符, 并推进光标, 仅用于段内调用
   413                                  ; 输入: CL=字符ASCII码
   414                                  ; ------------------------------------------------------------
   415                                  put_char:
   416 000004DB 60                          pushad 
   417                                  
   418 000004DC 66BAD403                    mov dx, 0x3d4                           ; 0x3d4 是 VGA 显卡的索引寄存器端口地址, 用于指定要操作的显卡寄存器。
   419 000004E0 B00E                        mov al, 0xe                             ; 0xe 是显卡的光标位置寄存器的索引值, 用于读取光标的高字节位置。
   420 000004E2 EE                          out dx, al                              ; 将 0xe 输出到端口 0x3d4, 
   421 000004E3 6642                        inc dx                                  ; 0x3d5 是显卡的数据寄存器端口地址, 用于读取或写入显卡寄存器的实际数据。
   422 000004E5 EC                          in al, dx                               ; 从端口 0x3d5 读取数据到 al, 读取了光标位置的高字节
   423                                  
   424 000004E6 88C4                        mov ah, al                              ; 存入 ah 
   425                                  
   426 000004E8 664A                        dec dx                                  ; 同上, 再获取低字节
   427 000004EA B00F                        mov al, 0x0f                            ; 0x0f 是显卡的光标位置寄存器的索引值, 用于读取光标的低字节位置。
   428 000004EC EE                          out dx, al 
   429 000004ED 6642                        inc dx 
   430 000004EF EC                          in al, dx 
   431                                  
   432 000004F0 6689C3                      mov bx, ax                              ; 此时 bx 中存储了字符的数目, 一个字符占两个字节
   433 000004F3 81E2FFFF0000                and edx, 0x0000ffff
   434                                  
   435 000004F9 80F90D                      cmp cl, 0x0d                            ; 回车符?
   436 000004FC 750E                        jnz .put_0a                             ; 不是回车符检查是不是换行符(0x0a)
   437                                  
   438 000004FE 6689D8                      mov ax, bx                              ; 处理回车符
   439 00000501 B350                        mov bl, 80                              ; 行宽 80
   440 00000503 F6F3                        div bl 
   441 00000505 F6E3                        mul bl                                  ; 移到本行起始
   442 00000507 6689C3                      mov bx, ax 
   443 0000050A EB19                        jmp .roll_screen
   444                                  
   445                                  .put_0a:
   446 0000050C 80F90A                      cmp cl, 0x0a                            ; 换行符?
   447 0000050F 7506                        jnz .put_other
   448                                  
   449 00000511 6683C350                    add bx, 80                              ; 处理换行符
   450 00000515 EB0E                        jmp .roll_screen
   451                                  
   452                                  .put_other:                                 ; 显示字符
   453 00000517 66D1E3                      shl bx, 1                               ; 在文本模式下, 显存中每个字符占用 2 个字节, 左移 1 位相当于将 bx 的值乘以 2, 从而将光标位置从字符索引转换为显存中的字节偏移量。
   454 0000051A 888B00800B00                mov [0xb8000 + ebx], cl                 ; 0xb800:0000(0xb8000) 是显存的起始地址
   455                                  
   456 00000520 66D1EB                      shr bx, 1                               ; 将光标位置移到下一个字符
   457 00000523 6643                        inc bx      
   458                                  
   459                                  .roll_screen:
   460 00000525 6681FBD007                  cmp bx, 2000                            ; 超出屏幕外? 
   461 0000052A 7C2F                        jl .set_cursor                          ; 设置光标
   462                                  
   463                                      ; 滚屏处理
   464 0000052C 53                          push ebx                                ; 保存光标位置               
   465                                  
   466 0000052D FC                          cld                                     ; 清除方向标志
   467 0000052E BEA0800B00                  mov esi, 0xb80a0                        ; 0xb80a0 是显存中第 2 行字符的起始地址。源地址
   468 00000533 BF00800B00                  mov edi, 0xb8000                        ; 0xb8000 是显存起始地址。目标地址
   469 00000538 B9C0030000                  mov ecx, 960                            ; 960 == 24 x 80 x 2 / 4, 滚屏操作需要将第 2 行到第 25 行的内容向上移动一行, 覆盖第 1 行的内容。
   470 0000053D F3A5                        rep movsd                               ; rep movsd 会根据 ecx 的值重复移动数据, 直到 ecx 为 0。每次移动 4 个字节
   471                                      
   472                                      ; 清除屏幕最后一行
   473 0000053F BB000F0000                  mov ebx, 3840                           ; 3840 == 24 x 80 x 2, 设置光标位置为屏幕最后一行的起始位置。
   474 00000544 B950000000                  mov ecx, 80                             ; ecx 是循环次数
   475                                  
   476                                  .cls:
   477 00000549 66C78300800B002007          mov word[0xb8000 + ebx], 0x0720         ; 0x0720 是空格字符, 黑色背景
   478 00000552 83C302                      add ebx, 2
   479 00000555 E2F2                        loop .cls 
   480                                  
   481 00000557 5B                          pop ebx                                 ; 恢复光标
   482 00000558 83EB50                      sub ebx, 80                             ; 上移一行
   483                                  
   484                                  .set_cursor:                                ; 设置光标
   485 0000055B 66BAD403                    mov dx, 0x3d4
   486 0000055F B00E                        mov al, 0x0e
   487 00000561 EE                          out dx, al
   488 00000562 6642                        inc dx 
   489 00000564 88F8                        mov al, bh 
   490 00000566 EE                          out dx, al 
   491                                  
   492 00000567 664A                        dec dx 
   493 00000569 B00F                        mov al, 0x0f
   494 0000056B EE                          out dx, al 
   495 0000056C 6642                        inc dx 
   496 0000056E 88D8                        mov al, bl 
   497 00000570 EE                          out dx, al 
   498                                  
   499 00000571 61                          popad 
   500 00000572 C3                          ret 
   501                                  
   502                                  ; ------------------------------------------------------------
   503                                  ; read_hard_disk_0
   504                                  ; 功能: 从硬盘中读取一个扇区
   505                                  ; 输入: eax=逻辑扇区号, ebx=目标缓冲区地址
   506                                  ; 返回: ebx = ebx + 512
   507                                  ; ------------------------------------------------------------
   508                                  read_hard_disk_0:
   509 00000573 50                          push eax
   510 00000574 51                          push ecx
   511 00000575 52                          push edx 
   512                                  
   513 00000576 50                          push eax 
   514                                  
   515 00000577 66BAF201                    mov dx, 0x1f2                           ; 0x1f2 是硬盘控制器的一个端口地址, 用于指定要读取的扇区数量。
   516 0000057B B001                        mov al, 1
   517 0000057D EE                          out dx, al                              ; 将 1 写入到硬盘控制器的端口 0x1f2, 告诉硬盘控制器接下来要读取一个扇区。
   518                                  
   519 0000057E 6642                        inc dx                                  ; 0x1f3
   520 00000580 58                          pop eax 
   521 00000581 EE                          out dx, al                              ; LBA 地址 7 ~ 0
   522                                  
   523 00000582 6642                        inc dx                                  ; 0x1f4
   524 00000584 B108                        mov cl, 8
   525 00000586 D3E8                        shr eax, cl 
   526 00000588 EE                          out dx, al                              ; LBA 地址 15 ~ 8
   527                                  
   528 00000589 6642                        inc dx                                  ; 0x1f5
   529 0000058B D3E8                        shr eax, cl 
   530 0000058D EE                          out dx, al                              ; LBA 地址 23 ~ 16
   531                                  
   532 0000058E 6642                        inc dx                                  ; 0x1f6
   533 00000590 D3E8                        shr eax, cl 
   534 00000592 0CE0                        or al, 0xe0                             ; 第一硬盘
   535 00000594 EE                          out dx, al                              ; LBA 地址 27 ~ 24
   536                                  
   537 00000595 6642                        inc dx                                  ; 0x1f7
   538 00000597 B020                        mov al, 0x20    
   539 00000599 EE                          out dx, al                              ; 读命令
   540                                  
   541                                  .waits:
   542 0000059A EC                          in al, dx 
   543 0000059B A808                        test al, 8
   544 0000059D 74FB                        jz .waits                               ; 忙或数据还没准备好, 循环查询
   545                                  
   546 0000059F B900010000                  mov ecx, 256                            ; 总共要读取的字数, 循环次数
   547 000005A4 66BAF001                    mov dx, 0x1f0
   548                                  
   549                                  .readw:
   550 000005A8 66ED                        in ax, dx                               ; 循环去读硬盘数据写入指定内存
   551 000005AA 668903                      mov [ebx], ax 
   552 000005AD 83C302                      add ebx, 2
   553 000005B0 E2F6                        loop .readw
   554                                  
   555 000005B2 5A                          pop edx 
   556 000005B3 59                          pop ecx 
   557 000005B4 58                          pop eax 
   558                                  
   559 000005B5 C3                          ret 
   560                                  
   561                                  SECTION trail
   562                                      ldr_end:
