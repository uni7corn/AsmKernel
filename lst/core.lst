     1                                  ; 内核
     2                                  
     3                                  %include "./common/global_defs.asm"
     1                              <1> ; 全局常量定义
     2                              <1> 
     3                              <1> %ifndef _GLOBAL_DEFS_
     4                              <1>     %define _GLOBAL_DEFS_
     5                              <1> 
     6                              <1>     SDA_PHY_ADDR        equ     0x00007e00	; 系统数据区的起始物理地址
     7                              <1>     PML5_PHY_ADDR       equ     0x00009000	; 内核 5 级头表物理地址
     8                              <1>     PML4_PHY_ADDR       equ     0x0000a000	; 内核 4 级头表物理地址
     9                              <1>     PDPT_PHY_ADDR       equ     0x0000b000	; 对应于低端 2MB 的内核页目录指针表物理地址
    10                              <1>     PDT_PHY_ADDR        equ     0x0000c000	; 对应于低端 2MB 的页目录表物理地址
    11                              <1>     PT_PHY_ADDR         equ     0x0000d000	; 对应于低端 2MB 的内核页表的物理地址
    12                              <1>     IDT_PHY_ADDR        equ     0x0000e000	; 中断描述符表的物理地址
    13                              <1>     LDR_PHY_ADDR        equ     0x0000f000	; 用于安装内核加载器的起始物理地址
    14                              <1>     GDT_PHY_ADDR        equ     0x00010000	; 全局描述符表 GDT 的物理地址
    15                              <1>     CORE_PHY_ADDR       equ     0x00020000	; 内核的起始物理地址
    16                              <1>     COR_PDPT_ADDR       equ     0x00100000	; 从这个物理地址开始的 1MB 是内核的 254 个页目录指针表
    17                              <1> 
    18                              <1>     LDR_START_SECTOR    equ     1      	        ; 内核加载器在硬盘上的起始逻辑扇区号
    19                              <1>     COR_START_SECTOR    equ     9      	        ; 内核程序在硬盘上的起始逻辑扇区号
    20                              <1> 
    21                              <1>     ; 虚拟内存空间的高端起始于线性地址 0xffff800000000000
    22                              <1>     UPPER_LINEAR_START  equ     0xffff800000000000  
    23                              <1>     UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	    ; 内核的高端线性地址
    24                              <1>     UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ; 文本显示缓冲区的高端起始线性地址
    25                              <1>     UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	    ; 系统数据区的高端线性地址
    26                              <1>     UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	    ; GDT 的高端线性地址
    27                              <1>     UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	    ; IDT 的高端线性地址
    28                              <1> 
    29                              <1>     ; 与全局描述符表有关的选择子定义, 及内存管理有关的常量定义
    30                              <1>     CORE_CODE64_SEL     equ     0x0018	; 内核代码段的描述符选择子(RPL=00)
    31                              <1>     CORE_STACK64_SEL    equ     0x0020	; 内核栈段的描述符选择子(RPL=00)
    32                              <1>     RESVD_DESC_SEL      equ     0x002b	; 保留的描述符选择子
    33                              <1>     USER_CODE64_SEL     equ     0x003b	; 3 特权级代码段的描述符选择子(RPL=11)
    34                              <1>     USER_STACK64_SEL    equ     0x0033	; 3 特权级栈段的描述符选择子(RPL=11)
    35                              <1> 
    36                              <1>     PHY_MEMORY_SIZE     equ     32    	            ; 物理内存大小(MB), 要求至少 3MB
    37                              <1>     CORE_ALLOC_START    equ     0xffff800000200000	; 在虚拟地址空间高端(内核)分配内存时的起始地址
    38                              <1>     USER_ALLOC_START    equ     0x0000000000000000	; 在每个任务虚拟地址空间低端分配内存时的起始地址
    39                              <1> 
    40                              <1>     ; 创建任务时, 需要分配一个物理页作为新任务的 4 级头表, 并分配一个临时的线性地址来初始化这个页
    41                              <1>     NEW_PML4_LINEAR     equ     0xffffff7ffffff000	; 用来映射新任务 4 级头表的线性地址
    42                              <1>     LAPIC_START_ADDR    equ     0xffffff7fffffe000	; LOCAL APIC 寄存器的起始线性地址
    43                              <1>     IOAPIC_START_ADDR   equ     0xffffff7fffffd000	; I/O APIC 寄存器的起始线性地址
    44                              <1>     AP_START_UP_ADDR    equ     0x0000f000 	        ; 应用处理器(AP)启动代码的物理地址
    45                              <1>     SUGG_PREEM_SLICE    equ     55          	    ; 推荐的任务/线程抢占时间片长度(毫秒)
    46                              <1> 
    47                              <1>     ; 多处理器环境下的自旋锁加锁宏。需要两个参数: 寄存器, 以及一个对应宽度的锁变量
    48                              <1>     %macro  SET_SPIN_LOCK 2             ; 两个参数, 分别是寄存器 %1 和锁变量 %2
    49                              <1>             %%spin_lock:
    50                              <1>                     cmp %2, 0           ; 看一眼锁现在是不是 0
    51                              <1>                     je %%get_lock      	; 如果是 0，说明没人占，跳过去抢
    52                              <1>                     pause				; 不是 0，先喘口气（降低 CPU 占用）
    53                              <1>                     jmp %%spin_lock    	; 继续看
    54                              <1>             %%get_lock:
    55                              <1>                     mov %1, 1
    56                              <1>                     xchg %1, %2         ; 用 xchg 的“原子交换”能力抢锁，抢不到就一直循环（自旋）
    57                              <1>                     cmp %1, 0          	; 交换回来的 %2 旧值是 0 吗？
    58                              <1>                     jne %%spin_lock   	; 不是 0 说明别人先插了旗，回到开头重抢
    59                              <1>     %endmacro
    60                              <1> 
    61                              <1> %endif
     4                                  
     5                                  SECTION core_header                                 ; 内核头部
     6 00000000 [980E0000]                  length      dd core_end                         ; 内核总长度
     7 00000004 [620C0000]                  init_entry  dd init                             ; 内核入口点
     8 00000008 0000000000000000            position    dq 0                                ; 内核加载虚拟地址
     9                                  
    10                                  SECTION core_data                                   ; 内核数据段
    11 00000000 457865637574696E67-         welcome     db "Executing in 64-bit mode.", 0x0d, 0x0a, 0   
    11 00000009 20696E2036342D6269-
    11 00000012 74206D6F64652E0D0A-
    11 0000001B 00                 
    12 0000001C 0000000000000000            tss_ptr     dq 0                                ; 任务状态段 TSS 从此处开始
    13 00000024 [0609000000000000]          sys_entry   dq get_screen_row                   ; syscall 支持的功能
    14 0000002C [8208000000000000]                      dq get_cmos_time
    15 00000034 [DE00000000000000]                      dq put_cstringxy64
    16 0000003C [110B000000000000]                      dq create_process
    17 00000044 [F00A000000000000]                      dq get_current_pid
    18 0000004C [FC0A000000000000]                      dq terminate_process
    19 00000054 0000000000000000            pcb_ptr     dq 0                                ; 进程控制块 PCB 首节点的线性地址
    20 0000005C 0000000000000000            cur_pcb     dq 0                                ; 当前任务的 PCB 线性地址    
    21                                  SECTION core_code                                   ; 内核代码段
    22                                  
    23                                  %include "./common/core_utils64.asm"
     1                              <1> ; 内核通用代码
     2                              <1> 
     3                              <1> ; 在多处理器环境中使用时, 需要在内核程序中定义宏 __MP__
     4                              <1> 
     5                              <1> %include "./common/global_defs.asm"
     1                              <2> ; 全局常量定义
     2                              <2> 
     3                              <2> %ifndef _GLOBAL_DEFS_
     4                              <2>     %define _GLOBAL_DEFS_
     5                              <2> 
     6                              <2>     SDA_PHY_ADDR        equ     0x00007e00	; 系统数据区的起始物理地址
     7                              <2>     PML5_PHY_ADDR       equ     0x00009000	; 内核 5 级头表物理地址
     8                              <2>     PML4_PHY_ADDR       equ     0x0000a000	; 内核 4 级头表物理地址
     9                              <2>     PDPT_PHY_ADDR       equ     0x0000b000	; 对应于低端 2MB 的内核页目录指针表物理地址
    10                              <2>     PDT_PHY_ADDR        equ     0x0000c000	; 对应于低端 2MB 的页目录表物理地址
    11                              <2>     PT_PHY_ADDR         equ     0x0000d000	; 对应于低端 2MB 的内核页表的物理地址
    12                              <2>     IDT_PHY_ADDR        equ     0x0000e000	; 中断描述符表的物理地址
    13                              <2>     LDR_PHY_ADDR        equ     0x0000f000	; 用于安装内核加载器的起始物理地址
    14                              <2>     GDT_PHY_ADDR        equ     0x00010000	; 全局描述符表 GDT 的物理地址
    15                              <2>     CORE_PHY_ADDR       equ     0x00020000	; 内核的起始物理地址
    16                              <2>     COR_PDPT_ADDR       equ     0x00100000	; 从这个物理地址开始的 1MB 是内核的 254 个页目录指针表
    17                              <2> 
    18                              <2>     LDR_START_SECTOR    equ     1      	        ; 内核加载器在硬盘上的起始逻辑扇区号
    19                              <2>     COR_START_SECTOR    equ     9      	        ; 内核程序在硬盘上的起始逻辑扇区号
    20                              <2> 
    21                              <2>     ; 虚拟内存空间的高端起始于线性地址 0xffff800000000000
    22                              <2>     UPPER_LINEAR_START  equ     0xffff800000000000  
    23                              <2>     UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	    ; 内核的高端线性地址
    24                              <2>     UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ; 文本显示缓冲区的高端起始线性地址
    25                              <2>     UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	    ; 系统数据区的高端线性地址
    26                              <2>     UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	    ; GDT 的高端线性地址
    27                              <2>     UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	    ; IDT 的高端线性地址
    28                              <2> 
    29                              <2>     ; 与全局描述符表有关的选择子定义, 及内存管理有关的常量定义
    30                              <2>     CORE_CODE64_SEL     equ     0x0018	; 内核代码段的描述符选择子(RPL=00)
    31                              <2>     CORE_STACK64_SEL    equ     0x0020	; 内核栈段的描述符选择子(RPL=00)
    32                              <2>     RESVD_DESC_SEL      equ     0x002b	; 保留的描述符选择子
    33                              <2>     USER_CODE64_SEL     equ     0x003b	; 3 特权级代码段的描述符选择子(RPL=11)
    34                              <2>     USER_STACK64_SEL    equ     0x0033	; 3 特权级栈段的描述符选择子(RPL=11)
    35                              <2> 
    36                              <2>     PHY_MEMORY_SIZE     equ     32    	            ; 物理内存大小(MB), 要求至少 3MB
    37                              <2>     CORE_ALLOC_START    equ     0xffff800000200000	; 在虚拟地址空间高端(内核)分配内存时的起始地址
    38                              <2>     USER_ALLOC_START    equ     0x0000000000000000	; 在每个任务虚拟地址空间低端分配内存时的起始地址
    39                              <2> 
    40                              <2>     ; 创建任务时, 需要分配一个物理页作为新任务的 4 级头表, 并分配一个临时的线性地址来初始化这个页
    41                              <2>     NEW_PML4_LINEAR     equ     0xffffff7ffffff000	; 用来映射新任务 4 级头表的线性地址
    42                              <2>     LAPIC_START_ADDR    equ     0xffffff7fffffe000	; LOCAL APIC 寄存器的起始线性地址
    43                              <2>     IOAPIC_START_ADDR   equ     0xffffff7fffffd000	; I/O APIC 寄存器的起始线性地址
    44                              <2>     AP_START_UP_ADDR    equ     0x0000f000 	        ; 应用处理器(AP)启动代码的物理地址
    45                              <2>     SUGG_PREEM_SLICE    equ     55          	    ; 推荐的任务/线程抢占时间片长度(毫秒)
    46                              <2> 
    47                              <2>     ; 多处理器环境下的自旋锁加锁宏。需要两个参数: 寄存器, 以及一个对应宽度的锁变量
    48                              <2>     %macro  SET_SPIN_LOCK 2             ; 两个参数, 分别是寄存器 %1 和锁变量 %2
    49                              <2>             %%spin_lock:
    50                              <2>                     cmp %2, 0           ; 看一眼锁现在是不是 0
    51                              <2>                     je %%get_lock      	; 如果是 0，说明没人占，跳过去抢
    52                              <2>                     pause				; 不是 0，先喘口气（降低 CPU 占用）
    53                              <2>                     jmp %%spin_lock    	; 继续看
    54                              <2>             %%get_lock:
    55                              <2>                     mov %1, 1
    56                              <2>                     xchg %1, %2         ; 用 xchg 的“原子交换”能力抢锁，抢不到就一直循环（自旋）
    57                              <2>                     cmp %1, 0          	; 交换回来的 %2 旧值是 0 吗？
    58                              <2>                     jne %%spin_lock   	; 不是 0 说明别人先插了旗，回到开头重抢
    59                              <2>     %endmacro
    60                              <2> 
    61                              <2> %endif
     6                              <1> 
     7                              <1> 	[bits 64]
     8                              <1> 
     9                              <1> ; ------------------------------------------------------------
    10                              <1> ; put_string64
    11                              <1> ; 功能: 显示 0 终止的字符串并移动光标
    12                              <1> ; 输入: rbx=字符串的线性地址
    13                              <1> ; ------------------------------------------------------------
    14                              <1> %ifdef __MP__
    15                              <1> _prn_str_locker dq 0
    16                              <1> %endif
    17                              <1> 
    18                              <1> put_string64:
    19 00000000 53                  <1> 	push rbx 
    20 00000001 51                  <1> 	push rcx 
    21                              <1> 
    22 00000002 9C                  <1> 	pushfq 
    23 00000003 FA                  <1> 	cli 
    24                              <1> %ifdef __MP__
    25                              <1> 	SET_SPIN_LOCK rcx, qword [rel _prn_str_locker]		; 上锁
    26                              <1> %endif 
    27                              <1> 
    28                              <1> .getc:
    29 00000004 8A0B                <1> 	mov cl, [rbx]
    30 00000006 08C9                <1> 	or cl, cl 							; 检查是不是 0
    31 00000008 740A                <1> 	jz .exit 							; 如果是 0 跳转到退出代码
    32 0000000A E809000000          <1> 	call put_char 
    33 0000000F 48FFC3              <1> 	inc rbx 
    34 00000012 EBF0                <1> 	jmp .getc
    35                              <1> 
    36                              <1> .exit:
    37                              <1> %ifdef __MP__ 
    38                              <1> 	mov qword [rel _prn_str_locker], 0					; 释放锁
    39                              <1> %endif
    40 00000014 9D                  <1> 	popfq
    41                              <1> 
    42 00000015 59                  <1> 	pop rcx 
    43 00000016 5B                  <1> 	pop rbx 
    44                              <1> 
    45 00000017 C3                  <1> 	ret 
    46                              <1> 	
    47                              <1> ; ------------------------------------------------------------
    48                              <1> ; put_char
    49                              <1> ; 功能: 在屏幕上的当前光标处显示一个字符并推进光标(ldr.asm 中 put_char 的 64 位版本)
    50                              <1> ; 输入: cl=字符ASCII码
    51                              <1> ; ------------------------------------------------------------
    52                              <1> put_char:
    53 00000018 50                  <1> 	push rax 
    54 00000019 53                  <1> 	push rbx 
    55 0000001A 51                  <1> 	push rcx 
    56 0000001B 52                  <1> 	push rdx 
    57 0000001C 56                  <1> 	push rsi 
    58 0000001D 57                  <1> 	push rdi 
    59                              <1> 
    60                              <1> 	; 获取光标位置
    61 0000001E 66BAD403            <1> 	mov dx, 0x3d4
    62 00000022 B00E                <1> 	mov al, 0x0e 
    63 00000024 EE                  <1> 	out dx, al 
    64 00000025 66FFC2              <1> 	inc dx 
    65 00000028 EC                  <1> 	in al, dx 								; 高字
    66 00000029 88C4                <1> 	mov ah, al 
    67                              <1> 
    68 0000002B 66FFCA              <1> 	dec dx 
    69 0000002E B00F                <1> 	mov al, 0x0f 
    70 00000030 EE                  <1> 	out dx, al 
    71 00000031 66FFC2              <1> 	inc dx 
    72 00000034 EC                  <1> 	in al, dx 								; 低字
    73 00000035 6689C3              <1> 	mov bx, ax 								; 此时 bx 中存储了字符的数目, 一个字符占两个字节
    74 00000038 4881E3FFFF0000      <1> 	and rbx, 0x000000000000ffff 			; 准备使用 64 位寻址方式访问显存
    75                              <1> 
    76 0000003F 80F90D              <1> 	cmp cl, 0x0d							; 回车符?
    77 00000042 750E                <1> 	jnz .put_0a
    78 00000044 6689D8              <1> 	mov ax, bx 
    79 00000047 B350                <1> 	mov bl, 80
    80 00000049 F6F3                <1> 	div bl 
    81 0000004B F6E3                <1> 	mul bl 									; 移到本行起始
    82 0000004D 6689C3              <1> 	mov bx, ax 	
    83 00000050 EB6C                <1> 	jmp .set_cursor
    84                              <1> 
    85                              <1> .put_0a:
    86 00000052 80F90A              <1> 	cmp cl, 0x0a 							; 换行符?
    87 00000055 7506                <1> 	jnz .put_other
    88 00000057 6683C350            <1> 	add bx, 80								; 平移一行
    89 0000005B EB16                <1> 	jmp .roll_screen
    90                              <1> 
    91                              <1> .put_other:						
    92 0000005D 66D1E3              <1> 	shl bx, 1								; 转换成字节数
    93 00000060 48B800800B000080FF- <1> 	mov rax, UPPER_TEXT_VIDEO
    93 00000069 FF                  <1>
    94 0000006A 880C18              <1> 	mov [rax + rbx], cl 					; 写入字符
    95                              <1> 
    96 0000006D 66D1EB              <1> 	shr bx, 1								; 转回字符数
    97 00000070 66FFC3              <1> 	inc bx 
    98                              <1> 
    99                              <1> .roll_screen:
   100 00000073 6681FBD007          <1> 	cmp bx, 2000							; 光标超出屏幕? 滚屏
   101 00000078 7C44                <1> 	jl .set_cursor 
   102                              <1> 	
   103 0000007A 6653                <1> 	push bx 
   104                              <1> 
   105 0000007C FC                  <1> 	cld 									; 清除方向标志位
   106 0000007D 48BEA0800B000080FF- <1> 	mov rsi, UPPER_TEXT_VIDEO + 0xa0		; 源地址
   106 00000086 FF                  <1>
   107 00000087 48BF00800B000080FF- <1> 	mov rdi, UPPER_TEXT_VIDEO				; 目标地址
   107 00000090 FF                  <1>
   108 00000091 B9E0010000          <1> 	mov rcx, 480							; 480 == 24 x 80 x 2 / 8。前 24 行向上平移一行
   109 00000096 F348A5              <1> 	rep movsq								
   110                              <1> 
   111 00000099 66BB000F            <1> 	mov bx, 3840							; 24 x 80 x 2。清除最后一行
   112 0000009D B950000000          <1> 	mov rcx, 80
   113                              <1> .cls:
   114 000000A2 48B800800B000080FF- <1> 	mov rax, UPPER_TEXT_VIDEO
   114 000000AB FF                  <1>
   115 000000AC 66C704182007        <1> 	mov word [rax + rbx], 0x0720
   116 000000B2 6683C302            <1> 	add bx, 2 
   117 000000B6 E2EA                <1> 	loop .cls 
   118                              <1> 
   119 000000B8 665B                <1> 	pop bx 									; 考虑换行符
   120 000000BA 6683EB50            <1> 	sub bx, 80
   121                              <1> 
   122                              <1> .set_cursor:
   123 000000BE 66BAD403            <1> 	mov dx, 0x3d4
   124 000000C2 B00E                <1> 	mov al, 0x0e 
   125 000000C4 EE                  <1> 	out dx, al 
   126 000000C5 66FFC2              <1> 	inc dx 									; 0x3d5
   127 000000C8 88F8                <1> 	mov al, bh 
   128 000000CA EE                  <1> 	out dx, al 
   129                              <1> 
   130 000000CB 66FFCA              <1> 	dec dx 									; 0x3d4
   131 000000CE B00F                <1> 	mov al, 0x0f 
   132 000000D0 EE                  <1> 	out dx, al 
   133 000000D1 66FFC2              <1> 	inc dx 									; 0x3d5
   134 000000D4 88D8                <1> 	mov al, bl 
   135 000000D6 EE                  <1> 	out dx, al 
   136                              <1> 
   137 000000D7 5F                  <1> 	pop rdi 
   138 000000D8 5E                  <1> 	pop rsi 
   139 000000D9 5A                  <1> 	pop rdx 
   140 000000DA 59                  <1> 	pop rcx 
   141 000000DB 5B                  <1> 	pop rbx 
   142 000000DC 58                  <1> 	pop rax 
   143                              <1> 
   144 000000DD C3                  <1> 	ret 
   145                              <1> 
   146                              <1> ; ------------------------------------------------------------
   147                              <1> ; put_cstringxy64
   148                              <1> ; 功能: 在指定位置用指定颜色显示 0 终止的字符串，只适用于打印图形字符。由于各程序打印时的坐标位置不同，互不干扰，不需要加锁和互斥。
   149                              <1> ; 输入: rbx=字符串首地址, dh=行, dl=列, r9b=颜色属性
   150                              <1> ; ------------------------------------------------------------
   151                              <1> %ifdef __MP__ 
   152                              <1> _prnxy_locker dp 0
   153                              <1> %endif 
   154                              <1> 
   155                              <1> put_cstringxy64:
   156 000000DE 50                  <1> 	push rax 
   157 000000DF 53                  <1> 	push rbx 
   158 000000E0 51                  <1> 	push rcx 
   159 000000E1 52                  <1> 	push rdx 
   160 000000E2 4150                <1> 	push r8 
   161                              <1> 
   162                              <1> 	; 指定坐标位置在显存内的偏移量
   163 000000E4 88F0                <1> 	mov al, dh 
   164 000000E6 B5A0                <1> 	mov ch, 160									; 每行 80 个字符, 占用 160 字节
   165 000000E8 F6E5                <1> 	mul ch 
   166 000000EA D0E2                <1> 	shl dl, 1									; 每个字符占两字节
   167 000000EC 6681E2FF00          <1> 	and dx, 0x00ff
   168 000000F1 6601D0              <1> 	add ax, dx 									; 得到相应显存偏移
   169 000000F4 4825FFFF0000        <1> 	and rax, 0x000000000000ffff
   170                              <1> 
   171 000000FA 9C                  <1> 	pushfq										; 将 RFLAGS 寄存器的全部 64 位标志位压入当前栈顶
   172 000000FB FA                  <1> 	cli 
   173                              <1> 
   174                              <1> %ifdef __MP__									; 读写显存时加锁
   175                              <1> 	SET_SPIN_LOCK r8, qword [rel _prnxy_locker]
   176                              <1> %endif 
   177                              <1> 
   178 000000FC 49B800800B000080FF- <1> 	mov r8, UPPER_TEXT_VIDEO					; 显存起始线性地址
   178 00000105 FF                  <1>
   179                              <1> .nextc:
   180 00000106 8A13                <1> 	mov dl, [rbx]								; 获取将要显示的字符
   181 00000108 08D2                <1> 	or dl, dl 
   182 0000010A 7412                <1> 	jz .exit 
   183 0000010C 41881400            <1> 	mov byte [r8 + rax], dl 					; 字符内容
   184 00000110 45884C0001          <1> 	mov byte [r8 + rax + 1], r9b 				; 字符颜色
   185 00000115 48FFC3              <1> 	inc rbx 
   186 00000118 4883C002            <1> 	add rax, 2
   187 0000011C EBE8                <1> 	jmp .nextc
   188                              <1> .exit:
   189 0000011E 4D31C0              <1> 	xor r8, r8 
   190                              <1> 
   191                              <1> %ifdef __MP__									; 读写显存时释放锁
   192                              <1> 	mov qword [rel _prnxy_locker], 0
   193                              <1> %endif 
   194                              <1> 
   195 00000121 9D                  <1> 	popfq 
   196                              <1> 
   197 00000122 4158                <1> 	pop r8 
   198 00000124 5A                  <1> 	pop rdx 
   199 00000125 59                  <1> 	pop rcx 
   200 00000126 5B                  <1> 	pop rbx 
   201 00000127 58                  <1> 	pop rax 
   202                              <1> 
   203 00000128 C3                  <1> 	ret 
   204                              <1> 
   205                              <1> ; ------------------------------------------------------------
   206                              <1> ; make_interrupt_gate
   207                              <1> ; 功能: 创建 64 位的中断门
   208                              <1> ; 输入: rax=处理程序的线性地址
   209                              <1> ; 输出: rdi 与 rsi 组成中断门(中断门、陷阱门格式见书中 148 页)
   210                              <1> ; ------------------------------------------------------------
   211                              <1> make_interrupt_gate:
   212 00000129 4889C7              <1> 	mov rdi, rax 
   213 0000012C 48C1EF20            <1> 	shr rdi, 32 						; 门的高 64 位, 其中高 32 位是保留
   214                              <1> 
   215 00000130 50                  <1> 	push rax 							; 借助栈构造, 先压入完整 rax, 也就是门的低 64 位, 在对其修改
   216 00000131 66C74424021800      <1> 	mov word [rsp + 2], CORE_CODE64_SEL	; 填入选择子
   217 00000138 89442404            <1> 	mov [rsp + 4], eax 					; 填入线性地址 31~16 位
   218 0000013C 66C7442404008E      <1> 	mov word [rsp + 4], 0x8e00			; 填入属性, P=1, TYPE=64 的中断门, 覆盖填入
   219 00000143 5E                  <1> 	pop rsi 
   220                              <1> 
   221 00000144 C3                  <1> 	ret 								; 可以参考书中 155 页的图
   222                              <1> 
   223                              <1> ; ------------------------------------------------------------
   224                              <1> ; make_tss_descriptor
   225                              <1> ; 功能: 创建 64 位的 TSS 描述符
   226                              <1> ; 输入: rax=TSS 的线性地址
   227                              <1> ; 输出: rdi:rsi=TSS 描述符(LDT, TSS 描述符格式见书中 200 页)
   228                              <1> ; ------------------------------------------------------------
   229                              <1> make_tss_descriptor:
   230 00000145 50                  <1> 	push rax 
   231                              <1> 
   232 00000146 4889C7              <1> 	mov rdi, rax 
   233 00000149 48C1EF20            <1> 	shr rdi, 32							; 得到门高 64 位, 存在 rdi 中
   234                              <1> 
   235 0000014D 50                  <1> 	push rax 							; 借助栈构造, 先压入完整 rax, 也就是门的低 64 位, 在对其修改
   236 0000014E 48C1242410          <1> 	shl qword [rsp], 16 				; 将线性地址 23~0 位移到正确位置
   237 00000153 66C704246800        <1> 	mov word [rsp], 104					; 填入段界限标准长度
   238 00000159 8A442405            <1> 	mov al, [rsp + 5]
   239 0000015D 88442407            <1> 	mov [rsp + 7], al 					; 将线性地址 31~24 位移到正确位置
   240 00000161 C644240589          <1> 	mov byte [rsp + 5], 0x89 			; P=1, DPL=0, TYPE=0b1001(64 位 TSS)
   241 00000166 C644240600          <1> 	mov byte [rsp + 6], 0				; G, 0, 0, AVL, limit
   242 0000016B 5E                  <1> 	pop rsi								; 门低 64 位
   243                              <1> 
   244 0000016C 58                  <1> 	pop rax 
   245                              <1> 
   246 0000016D C3                  <1> 	ret 
   247                              <1> 
   248                              <1> ; ------------------------------------------------------------
   249                              <1> ; mount_idt_entry
   250                              <1> ; 功能: 在中断描述符表 IDT 中安装门描述符
   251                              <1> ; 输入: r8=中断向量, rdi 与 rsi 组成中断门
   252                              <1> ; ------------------------------------------------------------
   253                              <1> mount_idt_entry:
   254 0000016E 4150                <1> 	push r8
   255 00000170 4151                <1> 	push r9 
   256                              <1> 
   257 00000172 49C1E004            <1> 	shl r8, 4 							; 中断号乘以 16 得到表内偏移, 每个中断门 16 字节大小
   258 00000176 49B900E000000080FF- <1> 	mov r9, UPPER_IDT_LINEAR			; 中断描述符表的高端地址
   258 0000017F FF                  <1>
   259 00000180 4B893401            <1> 	mov [r9 + r8], rsi 
   260 00000184 4B897C0108          <1> 	mov [r9 + r8 + 8], rdi 
   261                              <1> 
   262 00000189 4159                <1> 	pop r9 
   263 0000018B 4158                <1> 	pop r8 
   264                              <1> 
   265 0000018D C3                  <1> 	ret  
   266                              <1> 
   267                              <1> ; ------------------------------------------------------------
   268                              <1> ; init_8259
   269                              <1> ; 功能: 初始化8259中断控制器，包括重新设置向量号
   270                              <1> ; ------------------------------------------------------------
   271                              <1> init_8259:
   272 0000018E 50                  <1> 	push rax
   273                              <1> 
   274 0000018F B011                <1> 	mov al, 0x11
   275 00000191 E620                <1> 	out 0x20, al                    	; ICW1: 边沿触发/级联方式
   276 00000193 B020                <1> 	mov al, 0x20
   277 00000195 E621                <1> 	out 0x21, al  						; ICW2: 起始中断向量（避开前31个异常的向量）
   278 00000197 B004                <1> 	mov al, 0x04
   279 00000199 E621                <1> 	out 0x21, al  						; ICW3: 从片级联到 IR2
   280 0000019B B001                <1> 	mov al, 0x01
   281 0000019D E621                <1> 	out 0x21, al                  		; ICW4: 非总线缓冲，全嵌套，正常 EOI
   282                              <1> 
   283 0000019F B011                <1> 	mov al, 0x11
   284 000001A1 E6A0                <1> 	out 0xa0, al                  		; ICW1: 边沿触发/级联方式
   285 000001A3 B028                <1> 	mov al, 0x28
   286 000001A5 E6A1                <1> 	out 0xa1, al                  		; ICW2: 起始中断向量-->0x28
   287 000001A7 B002                <1> 	mov al, 0x02
   288 000001A9 E6A1                <1> 	out 0xa1, al                  		; ICW3: 从片识别标志，级联到主片 IR2
   289 000001AB B001                <1> 	mov al, 0x01
   290 000001AD E6A1                <1> 	out 0xa1, al                  		; ICW4: 非总线缓冲，全嵌套，正常 EOI
   291                              <1> 
   292 000001AF 58                  <1> 	pop rax
   293 000001B0 C3                  <1> 	ret
   294                              <1> 
   295                              <1> ; ------------------------------------------------------------
   296                              <1> ; read_hard_disk_0
   297                              <1> ; 功能: 从硬盘读取一个逻辑扇区
   298                              <1> ; 输入: rax=逻辑扇区号, rbx=目标缓冲区线性地址
   299                              <1> ; 输出: rbx=rbx+512
   300                              <1> ; ------------------------------------------------------------
   301                              <1> %ifdef __MP__
   302                              <1> _read_hdd_locker dq 0						
   303                              <1> %endif
   304                              <1> 
   305                              <1> read_hard_disk_0:
   306 000001B1 50                  <1> 	push rax 
   307 000001B2 51                  <1> 	push rcx 
   308 000001B3 52                  <1> 	push rdx 
   309 000001B4 9C                  <1> 	pushfq
   310                              <1> 
   311 000001B5 FA                  <1> 	cli 
   312                              <1> 
   313                              <1> %ifdef __MP__
   314                              <1> 	SET_SPIN_LOCK rdx, qword [rel _read_hdd_locker]
   315                              <1> %endif
   316                              <1> 
   317 000001B6 50                  <1> 	push rax 
   318                              <1> 
   319 000001B7 66BAF201            <1> 	mov dx, 0x1f2 								; 0x1f2
   320 000001BB B001                <1> 	mov al, 1
   321 000001BD EE                  <1> 	out dx, al 									; 读取扇区数
   322                              <1> 
   323 000001BE 66FFC2              <1> 	inc dx 										; 0x1f3 
   324 000001C1 58                  <1> 	pop rax 
   325 000001C2 EE                  <1> 	out dx, al 									; LBA 地址 7~0
   326                              <1> 
   327 000001C3 B108                <1> 	mov cl, 8 
   328                              <1> 
   329 000001C5 66FFC2              <1> 	inc dx 										; 0x1f4
   330 000001C8 48D3E8              <1> 	shr rax, cl 
   331 000001CB EE                  <1> 	out dx, al 									; LBA 地址 15~8
   332                              <1> 
   333 000001CC 66FFC2              <1> 	inc dx 										; 0x1f5
   334 000001CF 48D3E8              <1> 	shr rax, cl 
   335 000001D2 EE                  <1> 	out dx, al 									; LBA 地址 23~16
   336                              <1> 
   337 000001D3 66FFC2              <1> 	inc dx 										; 0x1f6
   338 000001D6 48D3E8              <1> 	shr rax, cl 
   339 000001D9 0CE0                <1> 	or al, 0xe0 								; 第一硬盘, LBA 地址 27~24
   340 000001DB EE                  <1> 	out dx, al 
   341                              <1> 
   342 000001DC 66FFC2              <1> 	inc dx 										; 0x1f6
   343 000001DF B020                <1> 	mov al, 0x20 								; 读命令
   344 000001E1 EE                  <1> 	out dx, al 
   345                              <1> 
   346                              <1> .waits:
   347 000001E2 EC                  <1> 	in al, dx 
   348 000001E3 A808                <1> 	test al, 8
   349 000001E5 74FB                <1> 	jz .waits
   350                              <1> 	; 不忙且硬盘已经准备好传输数据
   351 000001E7 B900010000          <1> 	mov rcx, 256								; 总共要读的字数=2字节
   352 000001EC 66BAF001            <1> 	mov dx, 0x1f0 
   353                              <1> .readw:
   354 000001F0 66ED                <1> 	in ax, dx 
   355 000001F2 668903              <1> 	mov [rbx], ax 
   356 000001F5 4883C302            <1> 	add rbx, 2
   357 000001F9 E2F5                <1> 	loop .readw 
   358                              <1> 
   359                              <1> %ifdef __MP__
   360                              <1> 	mov qword [rel _read_hdd_locker], 0
   361                              <1> %endif
   362                              <1> 
   363 000001FB 9D                  <1> 	popfq
   364 000001FC 5A                  <1> 	pop rdx 
   365 000001FD 59                  <1> 	pop rcx 
   366 000001FE 58                  <1> 	pop rax 
   367                              <1> 
   368 000001FF C3                  <1> 	ret 
   369                              <1> 
   370                              <1> ; ------------------------------------------------------------
   371                              <1> ; allocate_a_4k_page
   372                              <1> ; 功能: 分配一个 4KB 的页
   373                              <1> ; 输出: rax=页的物理地址
   374                              <1> ; ------------------------------------------------------------	
   375 00000200 FF<rep 40h>         <1> _page_bit_map times 2 * 1024 / 4 / 8 db 0xff 		; 对应物理内存前 512 页(2MB), 见书中 193 页
   376 00000240 00<rep 3C0h>        <1> 	times (PHY_MEMORY_SIZE - 2) * 1024 / 4 / 8 db 0	; 存放后续的页面
   377                              <1> _page_map_len equ $ - _page_bit_map
   378                              <1> 
   379                              <1> allocate_a_4k_page:
   380 00000600 4831C0              <1> 	xor rax, rax 
   381                              <1> .b1:
   382 00000603 F0480FAB05F4FBFFFF  <1> 	lock bts [rel _page_bit_map], rax 				; 多处理器需要 lock, 这是一个指令前缀，用于将随后的指令变成原子操作
   383 0000060C 730B                <1> 	jnc .b2 
   384 0000060E 48FFC0              <1> 	inc rax 
   385 00000611 483D00200000        <1> 	cmp rax, _page_map_len * 8
   386 00000617 7CEA                <1> 	jl .b1 
   387                              <1> 
   388                              <1> 	; 对我们这个简单的系统来说，通常不存在页面不够分配的情况。对于一个流行的系统来说, 
   389                              <1> 	; 如果页面不够分配，需要在这里执行虚拟内存管理，即，回收已经注销的页面，或者执行页面的换入和换出。
   390                              <1> .b2:
   391 00000619 48C1E00C            <1> 	shl rax, 12										; rax 是位数, 转换为内存要乘 4098
   392                              <1> 
   393 0000061D C3                  <1> 	ret 
   394                              <1> 
   395                              <1> ; ------------------------------------------------------------
   396                              <1> ; lin_to_lin_of_pml4e
   397                              <1> ; 功能: 返回指定的线性地址所对应的 4 级头表项的线性地址
   398                              <1> ; 输入: r13=线性地址
   399                              <1> ; 输出: r14=对应的 4 级头表项的线性地址
   400                              <1> ; ------------------------------------------------------------
   401                              <1> lin_to_lin_of_pml4e:
   402 0000061E 4155                <1> 	push r13 
   403                              <1> 
   404 00000620 49BE0000000080FF00- <1> 	mov r14, 0x0000_ff80_0000_0000 			; 保留 4 级头表索引部分
   404 00000629 00                  <1>
   405 0000062A 4D21F5              <1> 	and r13, r14 	
   406 0000062D 49C1ED24            <1> 	shr r13, 36								; 右移到低位, 相当于偏移 = 索引 * 8
   407                              <1> 
   408                              <1> 	; 这个利用了递归映射, 还记得在 ldr.asm 中我们将 4 级头表中最后一个项填入了其本身的地址, 
   409                              <1> 	; 而 0xffff_ffff_ffff_f000 这个线性地址前缀会一直访问最后一个表项, 得到的也一直是 4 级头表的地址
   410 00000631 49C7C600F0FFFF      <1> 	mov r14, 0xffff_ffff_ffff_f000			; 访问 4 级头表所用的地址前缀
   411 00000638 4D01EE              <1> 	add r14, r13 							
   412                              <1> 
   413 0000063B 415D                <1> 	pop r13 
   414                              <1> 
   415 0000063D C3                  <1> 	ret 
   416                              <1> 
   417                              <1> ; ------------------------------------------------------------
   418                              <1> ; lin_to_lin_of_pdpte
   419                              <1> ; 功能: 返回指定的线性地址所对应的页目录指针项的线性地址
   420                              <1> ; 输入: r13=线性地址
   421                              <1> ; 输出: r14=对应的页目录指针项的线性地址
   422                              <1> ; ------------------------------------------------------------
   423                              <1> lin_to_lin_of_pdpte:
   424 0000063E 4155                <1> 	push r13 
   425                              <1> 
   426 00000640 49BE000000C0FFFF00- <1> 	mov r14, 0x0000_ffff_c000_0000			; 保留 4 级头表索引和页目录指针表索引部分
   426 00000649 00                  <1>
   427 0000064A 4D21F5              <1> 	and r13, r14 
   428 0000064D 49C1ED1B            <1> 	shr r13, 27								
   429                              <1> 
   430                              <1> 	; 同上
   431 00000651 49C7C60000E0FF      <1> 	mov r14, 0xffff_ffff_ffe0_0000
   432 00000658 4D01EE              <1> 	add r14, r13 
   433                              <1> 
   434 0000065B 415D                <1> 	pop r13
   435                              <1> 
   436 0000065D C3                  <1> 	ret 
   437                              <1> 
   438                              <1> ; ------------------------------------------------------------
   439                              <1> ; lin_to_lin_of_pdte
   440                              <1> ; 功能: 返回指定的线性地址所对应的页目录项的线性地址
   441                              <1> ; 输入: r13=线性地址
   442                              <1> ; 输出: r14=对应的页目录项的线性地址
   443                              <1> ; ------------------------------------------------------------
   444                              <1> lin_to_lin_of_pdte:
   445 0000065E 4155                <1> 	push r13 
   446                              <1> 
   447 00000660 49BE0000E0FFFFFF00- <1> 	mov r14, 0x0000_ffff_ffe0_0000			; 保留 4 级头表索引、页目录指针表索引和页目录表
   447 00000669 00                  <1>
   448 0000066A 4D21F5              <1> 	and r13, r14 
   449 0000066D 49C1ED12            <1> 	shr r13, 18								
   450                              <1> 
   451                              <1> 	; 同上
   452 00000671 49C7C6000000C0      <1> 	mov r14, 0xffff_ffff_c000_0000
   453 00000678 4D01EE              <1> 	add r14, r13 
   454                              <1> 
   455 0000067B 415D                <1> 	pop r13
   456                              <1> 
   457 0000067D C3                  <1> 	ret 
   458                              <1> 
   459                              <1> ; ------------------------------------------------------------
   460                              <1> ; lin_to_lin_of_pte
   461                              <1> ; 功能: 返回指定的线性地址所对应的页表项的线性地址
   462                              <1> ; 输入: r13=线性地址
   463                              <1> ; 输出: r14=对应的页表项的线性地址
   464                              <1> ; ------------------------------------------------------------
   465                              <1> lin_to_lin_of_pte:
   466 0000067E 4155                <1> 	push r13 
   467                              <1> 
   468 00000680 49BE00F0FFFFFFFF00- <1> 	mov r14, 0x0000_ffff_ffff_f000			; 保留 4 级头表、页目录指针表、页目录表和页表的索引部分
   468 00000689 00                  <1>
   469 0000068A 4D21F5              <1> 	and r13, r14 
   470 0000068D 49C1ED09            <1> 	shr r13, 9								
   471                              <1> 
   472                              <1> 	; 同上
   473 00000691 49BE0000000080FFFF- <1> 	mov r14, 0xffff_ff80_0000_0000
   473 0000069A FF                  <1>
   474 0000069B 4D01EE              <1> 	add r14, r13 
   475                              <1> 
   476 0000069E 415D                <1> 	pop r13
   477                              <1> 
   478 000006A0 C3                  <1> 	ret 
   479                              <1> 
   480                              <1> 
   481                              <1> ; ------------------------------------------------------------
   482                              <1> ; find_pte_for_laddr
   483                              <1> ; 功能: 为指定的线性地址寻找到页表项线性地址
   484                              <1> ; 注意: 不保证线程安全, 如果需要在外部加锁, 关中断. 使用了 rcx, rax, r14 寄存器, 但不负责维护内容不变, 如果需要在外部 push, pop
   485                              <1> ; 输入: r13=线性地址
   486                              <1> ; 输出: r14=页表项线性地址
   487                              <1> ; ------------------------------------------------------------
   488                              <1> find_pte_for_laddr:
   489                              <1> 	; 四级头表一定存在, 检查对应地址的四级头表项是否存在
   490 000006A1 E878FFFFFF          <1> 	call lin_to_lin_of_pml4e							; 得到四级头表项的线性地址
   491 000006A6 49F70601000000      <1> 	test qword [r14], 1									; 看 P 位是否为 1 判断表项是否存在
   492 000006AD 752B                <1> 	jnz .b0
   493                              <1> 
   494                              <1> 	; 创建并安装该线性地址所对应的 4 级头表项(创建页目录指针表)
   495 000006AF E84CFFFFFF          <1> 	call allocate_a_4k_page								; 分配一个页作为页目录指针表
   496 000006B4 4883C807            <1> 	or rax, 0x07										; rax 是分配页的物理地址, 添加属性位 U/S=R/W=P=1
   497 000006B8 498906              <1> 	mov [r14], rax 										; 在 4 级头表中登记 4 级头表项
   498                              <1> 
   499                              <1> 	; 清空刚分配的页目录指针表
   500 000006BB E87EFFFFFF          <1> 	call lin_to_lin_of_pdpte
   501 000006C0 49C1EE0C            <1> 	shr r14, 12
   502 000006C4 49C1E60C            <1> 	shl r14, 12											; 得到页目录指针表的线性地址, 低 12 位是页目录指针项在页目录指针表内的偏移
   503 000006C8 B900020000          <1> 	mov rcx, 512
   504                              <1> .cls0:
   505 000006CD 49C70600000000      <1> 	mov qword [r14], 0
   506 000006D4 4983C608            <1> 	add r14, 8
   507 000006D8 E2F3                <1> 	loop .cls0
   508                              <1> 
   509                              <1> .b0:
   510                              <1> 	; 检查该线性地址对应的页目录指针项是否存在
   511 000006DA E85FFFFFFF          <1> 	call lin_to_lin_of_pdpte 							; 得到页目录指针项的线性地址
   512 000006DF 49F70601000000      <1> 	test qword [r14], 1									; 看 P 位是否为 1 判断表项是否存在
   513 000006E6 752B                <1> 	jnz .b1 
   514                              <1> 
   515                              <1> 	; 创建并安装该线性地址对应的页目录指针项
   516 000006E8 E813FFFFFF          <1> 	call allocate_a_4k_page								; 分配一个页作为页目录表
   517 000006ED 4883C807            <1> 	or rax, 0x07
   518 000006F1 498906              <1> 	mov [r14], rax 
   519                              <1> 
   520                              <1> 	; 清空刚分配的页目录表
   521 000006F4 E865FFFFFF          <1> 	call lin_to_lin_of_pdte 
   522 000006F9 49C1EE0C            <1> 	shr r14, 12
   523 000006FD 49C1E60C            <1> 	shl r14, 12 
   524 00000701 B900020000          <1> 	mov rcx, 512 
   525                              <1> .cls1:
   526 00000706 49C70600000000      <1> 	mov qword [r14], 0
   527 0000070D 4983C608            <1> 	add r14, 8
   528 00000711 E2F3                <1> 	loop .cls1 
   529                              <1> 
   530                              <1> .b1:
   531                              <1> 	; 检查该线性地址对应的页目录指针项是否存在
   532 00000713 E846FFFFFF          <1> 	call lin_to_lin_of_pdte 
   533 00000718 49F70601000000      <1> 	test qword [r14], 1
   534 0000071F 752B                <1> 	jnz .b2 
   535                              <1> 
   536                              <1> 	; 创建并安装该线性地址对应的页目录项, 即分配页表
   537 00000721 E8DAFEFFFF          <1> 	call allocate_a_4k_page
   538 00000726 4883C807            <1> 	or rax, 0x07
   539 0000072A 498906              <1> 	mov [r14], rax 
   540                              <1> 
   541                              <1> 	; 清空刚分配的页表
   542 0000072D E84CFFFFFF          <1> 	call lin_to_lin_of_pte 
   543 00000732 49C1EE0C            <1> 	shr r14, 12
   544 00000736 49C1E60C            <1> 	shl r14, 12
   545 0000073A B900020000          <1> 	mov rcx, 512
   546                              <1> 
   547                              <1> .cls2:
   548 0000073F 49C70600000000      <1> 	mov qword [r14], 0
   549 00000746 4983C608            <1> 	add r14, 8
   550 0000074A E2F3                <1> 	loop .cls2 
   551                              <1> 
   552                              <1> .b2:
   553                              <1> 	; 检查该线性地址所对应的页表项是否存在
   554 0000074C E82DFFFFFF          <1> 	call lin_to_lin_of_pte 
   555                              <1> 
   556 00000751 C3                  <1> 	ret 
   557                              <1> 
   558                              <1> ; ------------------------------------------------------------
   559                              <1> ; setup_paging_for_laddr
   560                              <1> ; 功能: 为指定的线性地址安装分页
   561                              <1> ; 输入: r13=线性地址
   562                              <1> ; ------------------------------------------------------------
   563                              <1> %ifdef __MP__
   564                              <1> _spaging_locker dq 0
   565                              <1> %endif
   566                              <1> 
   567                              <1> setup_paging_for_laddr:
   568 00000752 51                  <1> 	push rcx 
   569 00000753 50                  <1> 	push rax 
   570 00000754 4156                <1> 	push r14 
   571 00000756 9C                  <1> 	pushfq
   572                              <1> 
   573 00000757 FA                  <1> 	cli 
   574                              <1> 
   575                              <1> %ifdef __MP__
   576                              <1> 	SET_SPIN_LOCK r14, qword [rel _spaging_locker]
   577                              <1> %endif 
   578                              <1> 
   579 00000758 E844FFFFFF          <1> 	call find_pte_for_laddr
   580 0000075D 49F70601000000      <1> 	test qword [r14], 1
   581 00000764 750C                <1> 	jnz .exit
   582                              <1> 
   583                              <1> 	; 创建并安装该地址对应的页表项, 即最终分配的页
   584 00000766 E895FEFFFF          <1> 	call allocate_a_4k_page
   585 0000076B 4883C807            <1> 	or rax, 0x07										; 设置属性
   586 0000076F 498906              <1> 	mov [r14], rax 
   587                              <1> 
   588                              <1> .exit:
   589                              <1> %ifdef __MP__
   590                              <1> 	mov qword [rel _spaging_locker], 0
   591                              <1> %endif
   592 00000772 9D                  <1> 	popfq 
   593                              <1> 
   594 00000773 415E                <1> 	pop r14 
   595 00000775 58                  <1> 	pop rax 
   596 00000776 59                  <1> 	pop rcx 
   597                              <1> 
   598 00000777 C3                  <1> 	ret 
   599                              <1> ; ------------------------------------------------------------
   600                              <1> ; mapping_laddr_to_page
   601                              <1> ; 功能: 建立线性地址到物理页的映射, 即, 为指定的线性地址安装指定的物理页
   602                              <1> ; 输入: r13=线性地址, rax=页的物理地址（含属性）
   603                              <1> ; ------------------------------------------------------------
   604                              <1> %ifdef __MP__
   605                              <1> _mapping_locker dq 0
   606                              <1> %endif
   607                              <1> 
   608                              <1> mapping_laddr_to_page:
   609 00000778 51                  <1> 	push rcx 
   610 00000779 4156                <1> 	push r14 
   611 0000077B 9C                  <1> 	pushfq
   612                              <1> 
   613 0000077C FA                  <1> 	cli 
   614                              <1> 
   615                              <1> %ifdef __MP__
   616                              <1> 	SET_SPIN_LOCK r14, qword [rel _mapping_locker]
   617                              <1> %endif
   618                              <1> 
   619 0000077D 50                  <1> 	push rax 
   620 0000077E E81EFFFFFF          <1> 	call find_pte_for_laddr								; 得到页表项的线性地址
   621 00000783 58                  <1> 	pop rax 
   622 00000784 498906              <1> 	mov [r14], rax 										; 在页表项中写入页的物理地址
   623                              <1> 
   624                              <1> %ifdef __MP__
   625                              <1> 	mov qword [rel _mapping_locker], 0
   626                              <1> %endif
   627                              <1> 
   628 00000787 9D                  <1> 	popfq
   629 00000788 415E                <1> 	pop r14 
   630 0000078A 59                  <1> 	pop rcx 
   631                              <1> 
   632 0000078B C3                  <1> 	ret 
   633                              <1> 	
   634                              <1> ; ------------------------------------------------------------
   635                              <1> ; core_memory_allocate
   636                              <1> ; 功能: 在虚拟地址空间的高端（内核）分配内存
   637                              <1> ; 输入: rcx=请求分配的字节数
   638                              <1> ; 输出: r13=本次分配的起始线性地址, r14=下次分配的起始线性地址
   639                              <1> ; ------------------------------------------------------------
   640 0000078C 000020000080FFFF    <1> _core_next_linear dq CORE_ALLOC_START
   641                              <1> 
   642                              <1> %ifdef __MP__
   643                              <1> _core_alloc_locker dq 0
   644                              <1> %endif
   645                              <1> 
   646                              <1> core_memory_allocate:
   647 00000794 9C                  <1> 	pushfq 
   648 00000795 FA                  <1> 	cli 
   649                              <1> %ifdef __MP__
   650                              <1> 	SET_SPIN_LOCK r14, qword [rel _core_alloc_locker]
   651                              <1> %endif
   652 00000796 4C8B2DEFFFFFFF      <1> 	mov r13, [rel _core_next_linear]					; 起始地址
   653 0000079D 4D8D740D00          <1> 	lea r14, [r13 + rcx]								; 下次分配的起始地址
   654                              <1> 
   655 000007A2 49F7C607000000      <1> 	test r14, 0x07 										; 进行 8 字节对齐处理
   656 000007A9 740C                <1> 	jz .algn
   657 000007AB 4983C608            <1> 	add r14, 0x08
   658 000007AF 49C1EE03            <1> 	shr r14, 3
   659 000007B3 49C1E603            <1> 	shl r14, 3											; 最低的 3 个比特变 0
   660                              <1> 
   661                              <1> .algn:
   662 000007B7 4C8935CEFFFFFF      <1> 	mov qword [rel _core_next_linear], r14 				; 写回, 保留, 下一次用
   663                              <1> 
   664                              <1> %ifdef __MP__
   665                              <1> 	mov qword [rel _core_alloc_locker], 0
   666                              <1> %endif
   667                              <1> 
   668 000007BE 9D                  <1> 	popfq
   669                              <1> 
   670 000007BF 4155                <1> 	push r13 
   671 000007C1 4156                <1> 	push r14 
   672                              <1> 
   673                              <1> 	; 以下为请求的内存分配页。R13 为本次分配的线性地址；R14 为下次分配的线性地址
   674 000007C3 49C1ED0C            <1> 	shr r13, 12
   675 000007C7 49C1E50C            <1> 	shl r13, 12											; 清除页内偏移
   676 000007CB 49C1EE0C            <1> 	shr r14, 12
   677 000007CF 49C1E60C            <1> 	shl r14, 12
   678                              <1> .next:
   679 000007D3 E87AFFFFFF          <1> 	call setup_paging_for_laddr							; 安装线性地址所在页
   680 000007D8 4981C500100000      <1> 	add r13, 0x1000
   681 000007DF 4D39F5              <1> 	cmp r13, r14 
   682 000007E2 7EEF                <1> 	jle .next 
   683                              <1> 
   684 000007E4 415E                <1> 	pop r14 
   685 000007E6 415D                <1> 	pop r13 
   686                              <1> 
   687 000007E8 C3                  <1> 	ret 
   688                              <1> 
   689                              <1> ; ------------------------------------------------------------
   690                              <1> ; user_memory_allocate
   691                              <1> ; 功能: 在用户任务的私有空间（低端）分配内存
   692                              <1> ; 输入: r11=任务控制块 PCB 的线性地址, rcx=希望分配的字节数
   693                              <1> ; 输出: r13=本次分配的起始线性地址, r14=下次分配的起始线性地址
   694                              <1> ; ------------------------------------------------------------
   695                              <1> user_memory_allocate:
   696 000007E9 4D8B6B18            <1> 	mov r13, [r11 + 24]								; 获得本次分配的起始线性地址
   697 000007ED 4D8D740D00          <1> 	lea r14, [r13 + rcx]							; 下次分配的起始线性地址
   698                              <1> 
   699 000007F2 49F7C607000000      <1> 	test r14, 0x07									; 是否按 8 字节对齐
   700 000007F9 740C                <1> 	jz .algn
   701 000007FB 49C1EE03            <1> 	shr r14, 3 										; 8 字节向上取整
   702 000007FF 49C1E603            <1> 	shl r14, 3 
   703 00000803 4983C608            <1> 	add r14, 0x08 
   704                              <1> 
   705                              <1> .algn:
   706 00000807 4D897318            <1> 	mov [r11 + 24], r14 							; 写回 PCB 中
   707                              <1> 
   708 0000080B 4155                <1> 	push r13 
   709 0000080D 4156                <1> 	push r14 
   710                              <1> 
   711                              <1> 	; 以下为请求的内存分配页
   712 0000080F 49C1ED0C            <1> 	shr r13, 12										; 清除页内便宜
   713 00000813 49C1E50C            <1> 	shl r13, 12
   714 00000817 49C1EE0C            <1> 	shr r14, 12
   715 0000081B 49C1E60C            <1> 	shl r14, 12
   716                              <1> 
   717                              <1> .next:
   718 0000081F E82EFFFFFF          <1> 	call setup_paging_for_laddr						; 为当前线性地址安装页
   719 00000824 4981C500100000      <1> 	add r13, 0x1000
   720 0000082B 4D39F5              <1> 	cmp r13, r14 
   721 0000082E 7EEF                <1> 	jle .next
   722                              <1> 
   723 00000830 415E                <1> 	pop r14
   724 00000832 415D                <1> 	pop r13 
   725                              <1> 
   726 00000834 C3                  <1> 	ret 
   727                              <1> 
   728                              <1> ; ------------------------------------------------------------
   729                              <1> ; copy_current_pml4
   730                              <1> ; 功能: 创建新的 4 级头表，并复制当前 4 级头表的内容
   731                              <1> ; 输出: rax=新 4 级头表的物理地址及属性
   732                              <1> ; ------------------------------------------------------------
   733                              <1> %ifdef __MP__
   734                              <1> _copy_locker dq 0
   735                              <1> %endif
   736                              <1> 
   737                              <1> copy_current_pml4:
   738 00000835 56                  <1> 	push rsi 
   739 00000836 57                  <1> 	push rdi 
   740 00000837 4155                <1> 	push r13 
   741 00000839 51                  <1> 	push rcx 
   742 0000083A 9C                  <1> 	pushfq
   743                              <1> 
   744 0000083B FA                  <1> 	cli 
   745                              <1> 
   746                              <1> %ifdef __MP__
   747                              <1> 	SET_SPIN_LOCK rcx, qword [rel _copy_locker]
   748                              <1> %endif
   749                              <1> 
   750 0000083C E8BFFDFFFF          <1> 	call allocate_a_4k_page						; 分配一个物理页
   751 00000841 4883C807            <1> 	or rax, 0x07 								; 添加属性
   752 00000845 49BD00F0FFFF7FFFFF- <1> 	mov r13, NEW_PML4_LINEAR					; 用指定的线性地址映射和访问刚分配的这个物理页
   752 0000084E FF                  <1>
   753 0000084F E824FFFFFF          <1> 	call mapping_laddr_to_page
   754                              <1> 
   755                              <1> 	; 目标表项在页部件的转换速查缓冲器 TLB 的缓存, 需要用 invlpg 执行刷新
   756 00000854 410F017D00          <1> 	invlpg [r13]
   757                              <1> 
   758 00000859 48C7C600F0FFFF      <1> 	mov rsi, 0xffff_ffff_ffff_f000				; rsi -> 当前活动4级头表的线性地址(还是利用递归映射)
   759 00000860 4C89EF              <1> 	mov rdi, r13 								; rdi -> 新 4 级头表的线性地址
   760 00000863 B900020000          <1> 	mov rcx, 512								; rcx -> 要复制的目录项数
   761 00000868 FC                  <1> 	cld 										; 将 RFLAGS 中的方向标志位（DF）设置为 0, 即地址自动递增
   762 00000869 F348A5              <1> 	repe movsq
   763                              <1> 
   764 0000086C 498985F80F0000      <1> 	mov [r13 + 0xff8], rax 						; 0xff8 = 512 * 8, 新 4 级头表的 511 号表项指向它自己, 方便递归映射 
   765 00000873 410F01BDF80F0000    <1> 	invlpg [r13 + 0xff8]
   766                              <1> 
   767                              <1> %ifdef __MP__
   768                              <1> 	mov qword [rel _copy_locker], 0
   769                              <1> %endif
   770                              <1> 
   771 0000087B 9D                  <1> 	popfq
   772 0000087C 59                  <1> 	pop rcx 
   773 0000087D 415D                <1> 	pop r13
   774 0000087F 5F                  <1> 	pop rdi 
   775 00000880 5E                  <1> 	pop rsi 
   776                              <1> 
   777 00000881 C3                  <1> 	ret 
   778                              <1> 
   779                              <1> ; ------------------------------------------------------------
   780                              <1> ; get_cmos_time
   781                              <1> ; 功能: 从 CMOS 中获取当前时间, 详情见书中 225 页
   782                              <1> ; 输入: rbx=缓冲区线性地址
   783                              <1> ; ------------------------------------------------------------
   784                              <1> %ifdef __MP__
   785                              <1> _cmos_locker dq 0
   786                              <1> %endif
   787                              <1> 
   788                              <1> get_cmos_time:
   789 00000882 50                  <1> 	push rax 
   790 00000883 9C                  <1> 	pushfq
   791 00000884 FA                  <1> 	cli 
   792                              <1> 
   793                              <1> %ifdef __MP__
   794                              <1> 	SET_SPIN_LOCK rax, qword [rel _cmos_locker]
   795                              <1> %endif
   796                              <1> 
   797                              <1> .w0:
   798 00000885 B08A                <1> 	mov al, 0x8a 
   799 00000887 E670                <1> 	out 0x70, al 
   800 00000889 E471                <1> 	in al, 0x71 								; 读寄存器 A
   801 0000088B A880                <1> 	test al, 0x80 								; 测试第 7 位 UIP, 等待更新周期结束
   802 0000088D 75F6                <1> 	jnz .w0 
   803                              <1> 
   804 0000088F B084                <1> 	mov al, 0x84 
   805 00000891 E670                <1> 	out 0x70, al 
   806 00000893 E471                <1> 	in al, 0x71 								; 读RTC当前时间(时)
   807 00000895 88C4                <1> 	mov ah, al 									; BCD 编码, 用两个寄存器处理
   808                              <1> 
   809 00000897 C0EC04              <1> 	shr ah, 4									; 处理高四位						
   810 0000089A 80E40F              <1> 	and ah, 0x0f 
   811 0000089D 80C430              <1> 	add ah, 0x30 								; 转换成 ASCII
   812 000008A0 8823                <1> 	mov [rbx], ah 
   813                              <1> 
   814 000008A2 240F                <1> 	and al, 0x0f 								; 处理低四位
   815 000008A4 0430                <1> 	add al, 0x30 
   816 000008A6 884301              <1> 	mov [rbx + 1], al 
   817                              <1> 
   818 000008A9 C643023A            <1> 	mov byte [rbx + 2], ":"
   819                              <1> 
   820 000008AD B082                <1> 	mov al, 0x82 
   821 000008AF E670                <1> 	out 0x70, al 
   822 000008B1 E471                <1> 	in al, 0x71									; 读RTC当前时间(分)
   823 000008B3 88C4                <1> 	mov ah, al 
   824                              <1> 
   825 000008B5 C0EC04              <1> 	shr ah, 4			
   826 000008B8 80E40F              <1> 	and ah, 0x0f 
   827 000008BB 80C430              <1> 	add ah, 0x30 
   828 000008BE 886303              <1> 	mov [rbx + 3], ah 
   829                              <1> 
   830 000008C1 240F                <1> 	and al, 0x0f 
   831 000008C3 0430                <1> 	add al, 0x30 
   832 000008C5 884304              <1> 	mov [rbx + 4], al 
   833                              <1> 
   834 000008C8 C643053A            <1> 	mov byte [rbx + 5], ":"
   835                              <1> 
   836 000008CC B080                <1> 	mov al, 0x80 
   837 000008CE E670                <1> 	out 0x70, al 
   838 000008D0 E471                <1> 	in al, 0x71									; 读RTC当前时间(秒)
   839 000008D2 88C4                <1> 	mov ah, al 
   840                              <1> 
   841 000008D4 C0EC04              <1> 	shr ah, 4
   842 000008D7 80E40F              <1> 	and ah, 0x0f 
   843 000008DA 80C430              <1> 	add ah, 0x30
   844 000008DD 886306              <1> 	mov [rbx + 6], ah 
   845                              <1> 
   846 000008E0 240F                <1> 	and al, 0x0f 
   847 000008E2 0430                <1> 	add al, 0x30 
   848 000008E4 884307              <1> 	mov [rbx + 7], al 
   849                              <1> 
   850 000008E7 C6430800            <1> 	mov byte [rbx + 8], 0						; 终止字符
   851                              <1> 
   852                              <1> %ifdef __MP__
   853                              <1> 	mov qword [rel _cmos_locker], 0
   854                              <1> %endif
   855                              <1> 
   856 000008EB 9D                  <1> 	popfq
   857 000008EC 58                  <1> 	pop rax 
   858                              <1> 
   859 000008ED C3                  <1> 	ret 
   860                              <1> 
   861                              <1> ; ------------------------------------------------------------
   862                              <1> ; generate_process_id
   863                              <1> ; 功能: 生成唯一的进程标识
   864                              <1> ; 输出: rax=进程标识
   865                              <1> ; ------------------------------------------------------------
   866 000008EE 0000000000000000    <1> _process_id dq 0
   867                              <1> 
   868                              <1> generate_process_id:
   869 000008F6 B801000000          <1> 	mov rax, 1
   870 000008FB F0480FC105EAFFFFFF  <1> 	lock xadd qword [rel _process_id], rax 		; lock 前缀确保这条指令是原子操作, xadd 是 "交换并相加" 指令, 会将源操作数和目的操作数相加，结果存入目的操作数，同时将目的操作数的原始值存入源操作数
   871                              <1> 	
   872 00000904 C3                  <1> 	ret 
   873                              <1> 
   874                              <1> ; ------------------------------------------------------------
   875                              <1> ; get_screen_row
   876                              <1> ; 功能: 返回下一个屏幕坐标行的行号
   877                              <1> ; 输出: dh=行号
   878                              <1> ; ------------------------------------------------------------
   879 00000905 08                  <1> _screen_row db 8 								; 前边已经显示了 7 行, 所以从 8 开始
   880                              <1> 
   881                              <1> get_screen_row:
   882 00000906 B601                <1> 	mov dh, 1
   883 00000908 F00FC035F5FFFFFF    <1> 	lock xadd byte [rel _screen_row], dh 
   884                              <1> 
   885 00000910 C3                  <1> 	ret 
    24                                  
    25                                      [bits 64]
    26                                  
    27                                  ; ------------------------------------------------------------
    28                                  ; general_interrupt_handler
    29                                  ; 功能: 通用中断处理
    30                                  ; ------------------------------------------------------------
    31                                  general_interrupt_handler:
    32 00000911 48CF                        iretq
    33                                  
    34                                  ; ------------------------------------------------------------
    35                                  ; general_exception_handler
    36                                  ; 功能: 通用异常处理
    37                                  ; ------------------------------------------------------------
    38                                  general_exception_handler:
    39 00000913 4C8B3D(08000000)            mov r15, [rel position]                         ; 在 24 行 0 列显示红底白字的错误信息
    40 0000091A 498D9F[2F090000]            lea rbx, [r15 + exceptm]
    41 00000921 B618                        mov dh, 24
    42 00000923 B200                        mov dl, 0
    43 00000925 41B14F                      mov r9b, 0x4f 
    44 00000928 E8B1F7FFFF                  call put_cstringxy64                            ; 在 core_utils64.asm 中实现
    45                                  
    46 0000092D FA                          cli 
    47 0000092E F4                          hlt                                             ; 停机且不接受外部硬件中断
    48                                  
    49 0000092F 412065786365707469-     exceptm         db "A exception raised, halt.", 0    ; 发生异常时的错误信息
    49 00000938 6F6E20726169736564-
    49 00000941 2C2068616C742E00   
    50                                  
    51                                  ; ------------------------------------------------------------
    52                                  ; general_8259ints_handler
    53                                  ; 功能: 通用的 8259 中断处理过程
    54                                  ; ------------------------------------------------------------
    55                                  general_8259ints_handler:
    56 00000949 50                          push rax 
    57                                  
    58 0000094A B020                        mov al, 0x20                                    ; 中断结束命令 EOI
    59 0000094C E6A0                        out 0xa0, al                                    ; 向从片发送
    60 0000094E E620                        out 0x20, al                                    ; 向主片发送
    61                                  
    62 00000950 58                          pop rax 
    63                                  
    64 00000951 48CF                        iretq
    65                                  
    66                                  ; ------------------------------------------------------------
    67                                  ; rtm_interrupt_handle
    68                                  ; 功能: 实时时钟中断处理过程(任务切换)
    69                                  ; ------------------------------------------------------------
    70                                  rtm_interrupt_handle:
    71                                      ; 进入中断时, 硬件自动关闭可屏蔽中断, iret 指令自动恢复中断发生前的 IF 状态，无需软件手动设置
    72                                  
    73 00000953 4150                        push r8 
    74 00000955 50                          push rax 
    75 00000956 53                          push rbx 
    76                                  
    77 00000957 B020                        mov al, 0x20                                    ; 中断结束命令 EOI
    78 00000959 E6A0                        out 0xa0, al                                    ; 向从片发送
    79 0000095B E620                        out 0x20, al                                    ; 向主片发送
    80                                  
    81 0000095D B00C                        mov al, 0x0c                                    ; 寄存器 c 的索引, 且开放 NMI
    82 0000095F E670                        out 0x70, al
    83 00000961 E471                        in al, 0x71                                     ; 读一下 RTC 的寄存器C, 否则只发生一次中断, 此处不考虑闹钟和周期性中断的情况
    84                                  
    85                                      ; 以下开始执行任务切换
    86                                      ; 任务切换的原理是, 它发生在所有任务的全局空间。在任务 A 的全局空间执行任务切换，切换到任务 B, 实际上也是从任务 B 的全局空间返回任务B的私有空间。
    87                                  
    88                                      ; 从 PCB 链表中寻找就绪任务
    89 00000963 4C8B05(5C000000)            mov r8, [rel cur_pcb]                           ; 定位当前任务的 PCB 节点
    90                                  .again:
    91 0000096A 4D8B8018010000              mov r8, [r8 + 280]                              ; 获取下一个节点
    92 00000971 4C3B05(5C000000)            cmp r8, [rel cur_pcb]                           ; 是否转一圈回到当前节点?
    93 00000978 0F842F010000                jz .return                                      ; 返回
    94                                   
    95 0000097E 4983781000                  cmp qword [r8 + 16], 0                          ; 是否是就绪任务?
    96 00000983 7402                        jz .found                                       ; 切换任务
    97 00000985 EBE3                        jmp .again  
    98                                  
    99                                  .found:
   100 00000987 488B05(5C000000)            mov rax, [rel cur_pcb]                          ; 取得当前任务的 PCB 的线性地址
   101 0000098E 4883781002                  cmp qword [rax + 16], 2                         ; 当前任务可能已经被标记为终止, 我们就不用保存当前任务状态
   102 00000993 7479                        jz .restore
   103                                  
   104                                      ; 保存当前任务的状态以便将来恢复执行
   105 00000995 48C7401000000000            mov qword [rax + 16], 0                         ; 置任务状态为就绪
   106                                      ; mov [rax + 64], rax                           ; 不需设置，将来恢复执行时从栈中弹出, 因为下面把当前任务的 rip 设置成了 .return, 也就是, 当这个任务在被切换到时, 会从 .return 开始执行, pop rax ...
   107                                      ; mov [rax + 72], rbx                           ; 不需设置，将来恢复执行时从栈中弹出
   108 0000099D 48894850                    mov [rax + 80], rcx
   109 000009A1 48895058                    mov [rax + 88], rdx
   110 000009A5 48897060                    mov [rax + 96], rsi
   111 000009A9 48897868                    mov [rax + 104], rdi
   112 000009AD 48896870                    mov [rax + 112], rbp
   113 000009B1 48896078                    mov [rax + 120], rsp
   114                                      ; mov [rax + 128], r8                           ; 不需设置，将来恢复执行时从栈中弹出
   115 000009B5 4C898888000000              mov [rax + 136], r9
   116 000009BC 4C899090000000              mov [rax + 144], r10
   117 000009C3 4C899898000000              mov [rax + 152], r11
   118 000009CA 4C89A0A0000000              mov [rax + 160], r12
   119 000009D1 4C89A8A8000000              mov [rax + 168], r13
   120 000009D8 4C89B0B0000000              mov [rax + 176], r14
   121 000009DF 4C89B8B8000000              mov [rax + 184], r15
   122 000009E6 488B1D(08000000)            mov rbx, [rel position]
   123 000009ED 488D9B[AD0A0000]            lea rbx, [rbx + .return]
   124 000009F4 488998C0000000              mov [rax + 192], rbx                            ; RIP 为中断返回点
   125 000009FB 8C88C8000000                mov [rax + 200], cs
   126 00000A01 8C90D0000000                mov [rax + 208], ss
   127 00000A07 9C                          pushfq
   128 00000A08 8F80E8000000                pop qword [rax + 232]
   129                                  
   130                                  .restore:
   131                                      ; 恢复新任务的状态
   132 00000A0E 4C8905(5C000000)            mov [rel cur_pcb], r8                           ; 将当前任务设置为新任务
   133 00000A15 49C7401001000000            mov qword [r8 + 16], 1                          ; 置任务状态为忙
   134                                  
   135 00000A1D 498B4020                    mov rax, [r8 + 32]                              ; 取 PCB 中的 RSP0
   136 00000A21 488B1D(1C000000)            mov rbx, [rel tss_ptr]
   137 00000A28 48894304                    mov [rbx + 4], rax                              ; 置 TSS 的 RSP0
   138                                  
   139 00000A2C 498B4038                    mov rax, [r8 + 56]                              ; 设置 cr3, 切换地址空间
   140 00000A30 0F22D8                      mov cr3, rax 
   141                                  
   142 00000A33 498B4040                    mov rax, [r8 + 64]
   143 00000A37 498B5848                    mov rbx, [r8 + 72]
   144 00000A3B 498B4850                    mov rcx, [r8 + 80]
   145 00000A3F 498B5058                    mov rdx, [r8 + 88]
   146 00000A43 498B7060                    mov rsi, [r8 + 96]
   147 00000A47 498B7868                    mov rdi, [r8 + 104]
   148 00000A4B 498B6870                    mov rbp, [r8 + 112]
   149 00000A4F 498B6078                    mov rsp, [r8 + 120]
   150 00000A53 4D8B8888000000              mov r9, [r8 + 136]
   151 00000A5A 4D8B9090000000              mov r10, [r8 + 144]
   152 00000A61 4D8B9898000000              mov r11, [r8 + 152]
   153 00000A68 4D8BA0A0000000              mov r12, [r8 + 160]
   154 00000A6F 4D8BA8A8000000              mov r13, [r8 + 168]
   155 00000A76 4D8BB0B0000000              mov r14, [r8 + 176]
   156 00000A7D 4D8BB8B8000000              mov r15, [r8 + 184]
   157                                  
   158 00000A84 41FFB0D0000000              push qword [r8 + 208]                           ; SS
   159 00000A8B 41FF7078                    push qword [r8 + 120]                           ; RSP
   160 00000A8F 41FFB0E8000000              push qword [r8 + 232]                           ; RFLAGS
   161 00000A96 41FFB0C8000000              push qword [r8 + 200]                           ; CS
   162 00000A9D 41FFB0C0000000              push qword [r8 + 192]                           ; RIP
   163                                  
   164 00000AA4 4D8B8080000000              mov r8, [r8 + 128]                              ; 恢复 R8 的值
   165                                  
   166 00000AAB 48CF                        iretq                                           ; 转入新任务局部空间执行
   167                                  
   168                                  .return:
   169 00000AAD 5B                          pop rbx 
   170 00000AAE 58                          pop rax 
   171 00000AAF 4158                        pop r8 
   172                                  
   173 00000AB1 48CF                        iretq
   174                                  
   175                                  ; ------------------------------------------------------------
   176                                  ; append_to_pcb_link
   177                                  ; 功能: 在 PCB 链上追加任务控制块
   178                                  ; 输入: r11=PCB 线性基地址
   179                                  ; ------------------------------------------------------------
   180                                  append_to_pcb_link:
   181 00000AB3 50                          push rax 
   182 00000AB4 53                          push rbx 
   183                                  
   184 00000AB5 FA                          cli 
   185                                  
   186 00000AB6 488B1D(54000000)            mov rbx, [rel pcb_ptr]                          ; 取得链表首节点的线性地址
   187 00000ABD 4809DB                      or rbx, rbx 
   188 00000AC0 7513                        jnz .not_empty                                  ; 链表非空就跳转
   189 00000AC2 4D891B                      mov [r11], r11                                  ; 唯一的节点, 前驱是自己
   190 00000AC5 4D899B18010000              mov [r11 + 280], r11                            ; 后继节点也是自己
   191 00000ACC 4C891D(54000000)            mov [rel pcb_ptr], r11                          ; 填入内核
   192 00000AD3 EB17                        jmp .return 
   193                                  
   194                                  .not_empty:
   195                                      ; rbx=头节点, rax=头节点的前驱节点, r11=追加的节点
   196 00000AD5 488B03                      mov rax, [rbx]                                  ; 取得头节点的前驱线性地址
   197 00000AD8 4C899818010000              mov [rax + 280], r11                            ; 头节点的后继是追加节点
   198 00000ADF 49899B18010000              mov [r11 + 280], rbx                            ; 追加节点的后继是头节点
   199 00000AE6 498903                      mov [r11], rax                                  ; 追加节点的前驱是头节点的前驱
   200 00000AE9 4C891B                      mov [rbx], r11                                  ; 头节点的前驱是追加节点
   201                                  
   202                                  .return:
   203 00000AEC FB                          sti 
   204                                  
   205 00000AED 5B                          pop rbx 
   206 00000AEE 58                          pop rax 
   207                                  
   208 00000AEF C3                          ret 
   209                                  
   210                                  ; ------------------------------------------------------------
   211                                  ; get_current_pid
   212                                  ; 功能: 返回当前任务（进程）的标识
   213                                  ; 输出: rax=当前任务（进程）的标识
   214                                  ; ------------------------------------------------------------
   215                                  get_current_pid:
   216 00000AF0 488B05(5C000000)            mov rax, [rel cur_pcb]
   217 00000AF7 488B4008                    mov rax, [rax + 8]
   218                                  
   219 00000AFB C3                          ret 
   220                                  
   221                                  ; ------------------------------------------------------------
   222                                  ; terminate_process
   223                                  ; 功能: 终止当前任务
   224                                  ; ------------------------------------------------------------
   225                                  terminate_process:
   226 00000AFC FA                          cli                                             ; 执行流改变期间禁止时钟中断引发的任务切换
   227                                  
   228 00000AFD 488B05(5C000000)            mov rax, [rel cur_pcb]                          ; 定位到当前任务的 PCB 节点
   229 00000B04 48C7401002000000            mov qword [rax + 16], 2                         ; 状态=终止
   230                                      
   231 00000B0C E942FEFFFF                  jmp rtm_interrupt_handle                        ; 执行任务调度, 将控制权交给处理器
   232                                  
   233                                  ; ------------------------------------------------------------
   234                                  ; create_process
   235                                  ; 功能: 创建新的任务, 即分配好空间, 创建并填入 PCB
   236                                  ; 输入: r8=程序的起始逻辑扇区号
   237                                  ; ------------------------------------------------------------
   238                                  create_process:
   239 00000B11 50                          push rax
   240 00000B12 53                          push rbx
   241 00000B13 51                          push rcx
   242 00000B14 52                          push rdx
   243 00000B15 56                          push rsi
   244 00000B16 57                          push rdi
   245 00000B17 55                          push rbp
   246 00000B18 4150                        push r8
   247 00000B1A 4151                        push r9
   248 00000B1C 4152                        push r10
   249 00000B1E 4153                        push r11
   250 00000B20 4154                        push r12
   251 00000B22 4155                        push r13
   252 00000B24 4156                        push r14
   253 00000B26 4157                        push r15
   254                                  
   255                                      ; 在内核空间创建任务控制块 PCB, 来记录任务相关信息, 内核通过任务控制块来跟踪和识别任务, 并对任务进行管理和控制
   256 00000B28 B900020000                  mov rcx, 512                                    ; 任务控制块 PCB 的尺寸, PCB 的格式见书中 205 图
   257 00000B2D E862FCFFFF                  call core_memory_allocate                       ; 在内核分配地址
   258                                  
   259 00000B32 4D89EB                      mov r11, r13                                    ; r11 寄存器用来保存 PCB 线性地址
   260                                  
   261 00000B35 49C7431800000000            mov qword [r11 + 24], USER_ALLOC_START          ; 填写 PCB 的下一次内存分配时可用线性地址
   262                                      
   263                                      ; 从当前的四级头表复制并创建新任务的四级头表
   264 00000B3D E8F3FCFFFF                  call copy_current_pml4                          ; 在 core_utils64.asm 中实现
   265 00000B42 49894338                    mov [r11 + 56], rax                             ; 填写 PCB 的 CR3, 默认 PCD=PWT=0(这两个属性忘记的话可以看看书中 123 页)
   266                                  
   267                                      ; 以下，切换到新任务的地址空间，并清空其 4 级头表的前半部分。
   268                                      ; 我们正在地址空间的高端执行，可正常执行内核代码并访问内核数据，同时，当前使用的栈位于地址空间高端的栈。
   269 00000B46 410F20DF                    mov r15, cr3                                    ; 保存控制寄存器, 本次是临时切换, 还要再切回来
   270 00000B4A 0F22D8                      mov cr3, rax                                    ; 切换到新四级头表的新地址空间
   271                                  
   272                                      ; 清空四级头表的前半部分, 即局部地址
   273 00000B4D 48C7C000F0FFFF              mov rax, 0xffff_ffff_ffff_f000                  ; 四级头表线性地址, 还是递归映射...
   274 00000B54 B900010000                  mov rcx, 256
   275                                  .clsp:
   276 00000B59 48C70000000000              mov qword [rax], 0
   277 00000B60 4883C008                    add rax, 8
   278 00000B64 E2F3                        loop .clsp
   279                                  
   280 00000B66 0F20D8                      mov rax, cr3                                    ; 刷新 TLB
   281 00000B69 0F22D8                      mov cr3, rax 
   282                                  
   283                                      ; 为新任务分配 0 特权级使用的栈空间
   284 00000B6C B900000100                  mov rcx, 4096 * 16                              ; 在内核地址开辟空间
   285 00000B71 E81EFCFFFF                  call core_memory_allocate
   286 00000B76 4D897320                    mov [r11 + 32], r14                             ; 填入 PCB 中 RSP0, 满减栈, 所以写入结尾地址
   287                                  
   288                                      ; 为新任务分配 3 特权级使用的栈空间
   289 00000B7A B900000100                  mov rcx, 4096 * 16                              ; 在用户地址开辟空间
   290 00000B7F E865FCFFFF                  call user_memory_allocate
   291 00000B84 4D897378                    mov [r11 + 120], r14                            ; 填入 PCB 中 RSP
   292                                  
   293 00000B88 49C7431000000000            mov qword [r11 + 16], 0                         ; PCB 中的任务状态填为就绪    
   294                                  
   295                                      ; 以下开始加载用户程序
   296 00000B90 B900020000                  mov rcx, 512                                    ; 在用户空间开辟一个缓冲区
   297 00000B95 E84FFCFFFF                  call user_memory_allocate
   298 00000B9A 4C89EB                      mov rbx, r13 
   299 00000B9D 4C89C0                      mov rax, r8                                     ; r8 中存的用户程序起始扇区号         
   300 00000BA0 E80CF6FFFF                  call read_hard_disk_0
   301                                  
   302 00000BA5 4D896D10                    mov [r13 + 16], r13                             ; 在程序头填写它自己的起始线性地址
   303 00000BA9 4D89EE                      mov r14, r13 
   304 00000BAC 4D037508                    add r14, [r13 + 8]
   305 00000BB0 4D89B3C0000000              mov [r11 + 192], r14                            ; 在 PCB 中登记程序入口的线性地址
   306                                  
   307                                      ; 以下读取程序剩下代码
   308 00000BB7 498B4D00                    mov rcx, [r13]                                  ; 程序尺寸(在程序头部记录)
   309 00000BBB 48F7C1FF010000              test rcx, 0x1ff                                 ; 能被 512 整除吗?
   310 00000BC2 740F                        jz .y512
   311 00000BC4 48C1E909                    shr rcx, 9                                      ; 不能就凑整
   312 00000BC8 48C1E109                    shl rcx, 9
   313 00000BCC 4881C100020000              add rcx, 512
   314                                  .y512:
   315 00000BD3 4881E900020000              sub rcx, 512                                    ; 减去已读一个扇区的长度
   316 00000BDA 7416                        jz .rdok 
   317 00000BDC E808FCFFFF                  call user_memory_allocate                       ; 先分配内存在读数据
   318 00000BE1 48C1E909                    shr rcx, 9                                      ; 除以 512, 计算还需要读的扇区数
   319 00000BE5 48FFC0                      inc rax                                         ; 起始扇区号
   320                                  .b1:
   321 00000BE8 E8C4F5FFFF                  call read_hard_disk_0
   322 00000BED 48FFC0                      inc rax 
   323 00000BF0 E2F6                        loop .b1 
   324                                  
   325                                  .rdok:
   326 00000BF2 49C783C80000003B00-         mov qword [r11 + 200], USER_CODE64_SEL          ; 填写 PCB 中代码段选择子
   326 00000BFB 0000               
   327 00000BFD 49C783D00000003300-         mov qword [r11 + 208], USER_STACK64_SEL         ; 填写 PCB 中栈段选择子
   327 00000C06 0000               
   328                                  
   329 00000C08 9C                          pushfq
   330 00000C09 418F83E8000000              pop qword [r11 + 232]                           ; 填写 PCB 中 RFLAGS
   331                                  
   332 00000C10 E8E1FCFFFF                  call generate_process_id
   333 00000C15 49894308                    mov [r11 + 8], rax                              ; 填入 PCB 中当前任务标识
   334                                  
   335 00000C19 E895FEFFFF                  call append_to_pcb_link                         ; 将 PCB 添加到进程控制链表尾部
   336                                  
   337 00000C1E 410F22DF                    mov cr3, r15                                    ; 切换到原任务地址空间
   338                                  
   339 00000C22 415F                        pop r15
   340 00000C24 415E                        pop r14
   341 00000C26 415D                        pop r13
   342 00000C28 415C                        pop r12
   343 00000C2A 415B                        pop r11
   344 00000C2C 415A                        pop r10
   345 00000C2E 4159                        pop r9
   346 00000C30 4158                        pop r8
   347 00000C32 5D                          pop rbp
   348 00000C33 5F                          pop rdi
   349 00000C34 5E                          pop rsi
   350 00000C35 5A                          pop rdx
   351 00000C36 59                          pop rcx
   352 00000C37 5B                          pop rbx
   353 00000C38 58                          pop rax
   354                                  
   355 00000C39 C3                          ret
   356                                  ; ------------------------------------------------------------
   357                                  ; syscall_procedure
   358                                  ; 功能: 系统调用的处理过程
   359                                  ; 注意: rcx 和 r11 由处理器使用, 保存 rip 和 rflags 的内容; rbp 和 r15 由此例程占用. 如有必要, 请用户程序在调用 syscall 前保存它们, 在系统调用返回后自行恢复.
   360                                  ; ------------------------------------------------------------
   361                                  syscall_procedure: 
   362 00000C3A 4889E5                      mov rbp, rsp 
   363 00000C3D 4C8B3D(1C000000)            mov r15, [rel tss_ptr]
   364 00000C44 498B6704                    mov rsp, [r15 + 4]                              ; 使用 TSS 的 RSP0 作为安全栈
   365                                  
   366 00000C48 FB                          sti                                             ; 恢复中断
   367                                  
   368 00000C49 4C8B3D(08000000)            mov r15, [rel position]
   369 00000C50 4D03BCC7[24000000]          add r15, [r15 + rax * 8 + sys_entry]
   370 00000C58 41FFD7                      call r15
   371                                  
   372 00000C5B FA                          cli                                             ; 关中断, 恢复栈
   373 00000C5C 4889EC                      mov rsp, rbp 
   374 00000C5F 480F07                      o64 sysret
   375                                  
   376                                  ; ------------------------------------------------------------
   377                                  ; init
   378                                  ; 功能: 初始化内核工作环境
   379                                  ; ------------------------------------------------------------
   380                                  init: 
   381                                      ; 将 GDT 的线性地址映射到虚拟内存高端的相同位置。
   382                                      ; 处理器不支持 64 位立即数到内存地址的操作, 所以用两条指令完成。
   383 00000C62 48B8000001000080FF-         mov rax, UPPER_GDT_LINEAR                       ; GDT 高端线性地址
   383 00000C6B FF                 
   384 00000C6C 48890425047E0000            mov qword [SDA_PHY_ADDR + 4], rax
   385                                  
   386 00000C74 0F011425027E0000            lgdt [SDA_PHY_ADDR + 2]                
   387                                  
   388                                      ; 将栈映射到高端
   389                                      ; 64 位模式下不支持源操作数为 64 位立即数的加法操作。
   390 00000C7C 48B8000000000080FF-         mov rax, UPPER_LINEAR_START
   390 00000C85 FF                 
   391 00000C86 4801C4                      add rsp, rax 
   392                                  
   393                                      ; 准备让处理器从虚拟地址空间的高端开始执行（现在依然在低端执行）
   394 00000C89 48B8000000000080FF-         mov rax, UPPER_LINEAR_START
   394 00000C92 FF                 
   395 00000C93 480105(08000000)            add [rel position], rax                         ; 更新 position 处地址, 采用相对寻址方式
   396 00000C9A 488B05(08000000)            mov rax, [rel position]
   397 00000CA1 4805[A90C0000]              add rax, .to_upper
   398 00000CA7 FFE0                        jmp rax                                         ; 用 jmp 改变 rip
   399                                  
   400                                  .to_upper:
   401                                      ; 接下来初始化中断描述符表 IDT，并为 32 个异常以及 224 个中断安装门描述符
   402                                  
   403                                      ; 为 32 个异常创建通用处理过程的中断门
   404 00000CA9 4C8B0D(08000000)            mov r9, [rel position]
   405 00000CB0 498D81[13090000]            lea rax, [r9 + general_exception_handler]
   406 00000CB7 E86DF4FFFF                  call make_interrupt_gate                        ; 在 core_utils64.asm 中实现
   407                                  
   408 00000CBC 4D31C0                      xor r8, r8  
   409                                  .idt0:                                              ; 32 个异常
   410 00000CBF E8AAF4FFFF                  call mount_idt_entry                            ; 在 core_utils64.asm 中实现
   411 00000CC4 49FFC0                      inc r8 
   412 00000CC7 4983F81F                    cmp r8, 31 
   413 00000CCB 7EF2                        jle .idt0
   414                                  
   415                                      ; 创建并安装中断门
   416 00000CCD 498D81[11090000]            lea rax, [r9 + general_interrupt_handler]       
   417 00000CD4 E850F4FFFF                  call make_interrupt_gate                        ; 在 core_utils64.asm 中实现
   418                                  
   419 00000CD9 41B820000000                mov r8, 32 
   420                                  .idt1:
   421 00000CDF E88AF4FFFF                  call mount_idt_entry                            ; 在 core_utils64.asm 中实现
   422 00000CE4 49FFC0                      inc r8 
   423 00000CE7 4981F8FF000000              cmp r8, 255
   424 00000CEE 7EEF                        jle .idt1
   425                                  
   426 00000CF0 48B800E000000080FF-         mov rax, UPPER_IDT_LINEAR                       ; 中断描述符表 IDT 的高端线性地址
   426 00000CF9 FF                 
   427 00000CFA 48BB007E00000080FF-         mov rbx, UPPER_SDA_LINEAR                       ; 系统数据区 SDA 的高端线性地址
   427 00000D03 FF                 
   428 00000D04 66C7430CFF0F                mov word [rbx + 0x0c], 256 * 16 - 1
   429 00000D0A 4889430E                    mov qword [rbx + 0x0e], rax                     ; 将 IDT 的线性地址和界限写入内核空间保存
   430                                      
   431                                  
   432 00000D0E 0F015B0C                    lidt [rbx + 0x0c]                               ; 加载 IDT
   433                                  
   434 00000D12 E877F4FFFF                  call init_8259                                  ; 初始化 8259 中断控制器，包括重新设置中断向量号
   435                                  
   436 00000D17 498D81[49090000]            lea rax, [r9 + general_8259ints_handler]        ; 得到通用 8259 中断处理过程的线性地址
   437 00000D1E E806F4FFFF                  call make_interrupt_gate                        ; 在 core_utils64.asm 中实现
   438                                  
   439 00000D23 41B820000000                mov r8, 0x20
   440                                  .8259:
   441 00000D29 E840F4FFFF                  call mount_idt_entry                            ; 在 core_utils64.asm 中实现
   442 00000D2E 49FFC0                      inc r8
   443 00000D31 4983F82F                    cmp r8, 0x2f                                    ; 8259 用来收集外部硬件中断信号, 提供 16 个中断向量, 将之前的覆盖
   444 00000D35 7EF2                        jle .8259
   445                                  
   446 00000D37 FB                          sti                                             ; 开放硬件中断
   447                                  
   448                                      ; 在 64 位模式下显示的第一条信息!
   449 00000D38 4C8B3D(08000000)            mov r15, [rel position]
   450 00000D3F 498D9F[00000000]            lea rbx, [r15 + welcome]
   451 00000D46 E8B5F2FFFF                  call put_string64                               ; 在 core_utils64.asm 中实现
   452                                  
   453                                      ; 安装系统服务(syscall, sysret)所需的代码段和栈段描述符
   454 00000D4B 4883EC10                    sub rsp, 16                                     ; 开辟 16 字节空间操作 GDT, GDTR
   455 00000D4F 0F010424                    sgdt [rsp]
   456 00000D53 4831DB                      xor rbx, rbx 
   457 00000D56 668B1C24                    mov bx, [rsp]                                   ; 得到 GDT 界限值(表的总字节数 - 1 == 下标)
   458 00000D5A 66FFC3                      inc bx
   459 00000D5D 48035C2402                  add rbx, [rsp + 2]                              ; GDT 基址 + GDT 界限值 + 1 == 新描述符的地址
   460                                      ; 增加新的描述符, 这里可以看书中 182 页的图, 将之前设置的四个描述符也画全了
   461                                  
   462                                      ; 创建 4# 描述符, 栈/数据段描述符, DPL= 0
   463 00000D62 C703FFFF0000                mov dword [rbx], 0x0000ffff
   464 00000D68 C743040092CF00              mov dword [rbx + 4], 0x00cf9200                
   465                                      ; 创建 5# 描述符, 兼容模式下代码段描述符, 暂不支持, 位置保留, 设为全 0
   466 00000D6F C7430800000000              mov dword [rbx + 8], 0  
   467 00000D76 C7430C00000000              mov dword [rbx + 12], 0
   468                                      ; 创建 6# 描述符, 栈/数据段描述符, DPL= 3
   469 00000D7D C74310FFFF0000              mov dword [rbx + 16], 0x0000ffff
   470 00000D84 C7431400F2CF00              mov dword [rbx + 20], 0x00cff200
   471                                      ; 创建 7# 描述符, 64 位模式的代码段描述符, DPL= 3
   472 00000D8B C74318FFFF0000              mov dword [rbx + 24], 0x0000ffff
   473 00000D92 C7431C00F8AF00              mov dword [rbx + 28], 0x00aff800
   474                                  
   475                                      ; 安装任务状态段 TSS 的描述符, 见书中 200 页
   476 00000D99 B968000000                  mov rcx, 104                                    ; TSS 标准长度
   477 00000D9E E8F1F9FFFF                  call core_memory_allocate                       ; 在 core_utils64.asm 中实现
   478 00000DA3 4C892D(1C000000)            mov [rel tss_ptr], r13 
   479 00000DAA 4C89E8                      mov rax, r13 
   480 00000DAD E893F3FFFF                  call make_tss_descriptor                        ; 在 core_utils64.asm 中实现
   481 00000DB2 48897320                    mov qword [rbx + 32], rsi                       ; TSS 描述符低 64 位
   482 00000DB6 48897B28                    mov qword [rbx + 40], rdi                       ; TSS 描述符高 64 位
   483                                  
   484 00000DBA 6683042430                  add word [rsp], 48                              ; 四个段描述符和一个 TSS 描述符总字节数
   485 00000DBF 0F011424                    lgdt [rsp]
   486 00000DC3 4883C410                    add rsp, 16                                     ; 栈平衡
   487                                  
   488 00000DC7 66B94000                    mov cx, 0x0040                                  ; TSS 描述符选择子
   489 00000DCB 0F00D9                      ltr cx                                          ; 使用 ltr 指令加载 TSS 选择子
   490                                  
   491                                      ; 为快速系统调用 syscall 和 sysret 准备参数, 详细见书中 180-185
   492 00000DCE B9800000C0                  mov ecx, 0x0c0000080                            ; 指定型号专属寄存器 IA32_EFER
   493 00000DD3 0F32                        rdmsr
   494 00000DD5 0FBAE800                    bts eax, 0                                      ; 置位 SCE 位, 允许 syscall 和 sysret
   495 00000DD9 0F30                        wrmsr
   496                                  
   497 00000DDB B9810000C0                  mov ecx, 0xc0000081                             ; IA32_STAR, syscall 会自动切换代码段寄存器（CS）到内核态的代码段，其值来自 IA32_STAR
   498 00000DE0 BA18002B00                  mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL ; 高 32 位, RESVD_DESC_SEL 是用户态代码段选择子（返回用户态时使用）, CORE_CODE64_SEL 是内核态代码段选择子（进入内核态时使用）
   499 00000DE5 31C0                        xor eax, eax                                    ; 低 32 位
   500 00000DE7 0F30                        wrmsr                                           
   501                                  
   502 00000DE9 B9820000C0                  mov ecx, 0xc0000082                             ; IA32_LSTAR
   503 00000DEE 488B05(08000000)            mov rax, [rel position]
   504 00000DF5 488D80[3A0C0000]            lea rax, [rax + syscall_procedure]              ; 只用 EAX 部分
   505 00000DFC 4889C2                      mov rdx, rax 
   506 00000DFF 48C1EA20                    shr rdx, 32                                     ; 只用 EDX 部分
   507 00000E03 0F30                        wrmsr
   508                                  
   509 00000E05 B9840000C0                  mov ecx, 0xc0000084                             ; IA32_FMASK
   510 00000E0A 31D2                        xor edx, edx 
   511 00000E0C B800770400                  mov eax, 0x00047700                             ; 将 TF, IF, DF, IOPL, AC 清零, 其他保持不变, 可看书 185 页的图
   512 00000E11 0F30                        wrmsr
   513                                  
   514                                      ; 以下安装用于任务切换的实时时钟中断处理过程
   515 00000E13 4C8B0D(08000000)            mov r9, [rel position]
   516 00000E1A 498D81[53090000]            lea rax, [r9 + rtm_interrupt_handle]            ; 得到中断处理过程的线性地址
   517 00000E21 E803F3FFFF                  call make_interrupt_gate
   518                                  
   519 00000E26 FA                          cli 
   520                                  
   521 00000E27 41B828000000                mov r8, 0x28                                    ; 使用 0x20 时, 应调整 bochs 的时间速率
   522 00000E2D E83CF3FFFF                  call mount_idt_entry
   523                                  
   524                                      ; 设置与时钟中断相关的硬件
   525 00000E32 B00B                        mov al, 0x0b                                    ; RTC 寄存器 B
   526 00000E34 0C80                        or al, 0x80                                     ; 阻断 NMI
   527 00000E36 E670                        out 0x70, al 
   528                                  
   529 00000E38 B012                        mov al, 0x12                                    ; 设置寄存器B，禁止周期性中断，开放更新结束后中断，BCD码，24小时制
   530 00000E3A E671                        out 0x71, al 
   531                                  
   532 00000E3C E4A1                        in al, 0xa1                                     ; 读 8259 从片的 IMR 寄存器
   533 00000E3E 24FE                        and al, 0xfe                                    ; 清除 bit 0(此位连接RTC)
   534 00000E40 E6A1                        out 0xa1, al                                    ; 写回此寄存器
   535                                  
   536 00000E42 FB                          sti 
   537                                  
   538 00000E43 B00C                        mov al, 0x0c 
   539 00000E45 E670                        out 0x70, al    
   540 00000E47 E471                        in al, 0x71                                     ; 读 RTC 寄存器 C, 复位未决的中断状态
   541                                  
   542                                      ; 以下创建进程
   543 00000E49 41B832000000                mov r8, 50
   544 00000E4F E8BDFCFFFF                  call create_process
   545                                  
   546 00000E54 488B1D(54000000)            mov rbx, [rel pcb_ptr]                          ; 得到外壳任务 PCB 的线性地址
   547 00000E5B 488B4338                    mov rax, [rbx + 56]                             ; 从 PCB 中取出 CR3
   548 00000E5F 0F22D8                      mov cr3, rax                                    ; 切换到新进程的地址空间, cr3 寄存器中存储当前四级头表的地址
   549                                  
   550 00000E62 48891D(5C000000)            mov [rel cur_pcb], rbx                          ; 设置当前任务的 PCB
   551 00000E69 48C7431001000000            mov qword [rbx + 16], 1                         ; 设置当前任务状态为忙
   552                                  
   553 00000E71 488B4320                    mov rax, [rbx + 32]                             ; 从 PCB 中取出 RSP0
   554 00000E75 488B15(1C000000)            mov rdx, [rel tss_ptr]                          ; 得到 TSS 的线性地址
   555 00000E7C 48894204                    mov [rdx + 4], rax                              ; 在 TSS 中回填 RSP0
   556                                  
   557 00000E80 FFB3D0000000                push qword [rbx + 208]                          ; 用户程序的 SS
   558 00000E86 FF7378                      push qword [rbx + 120]                          ; 用户程序的 RSP
   559 00000E89 9C                          pushfq                                          ; 用户程序的 RFLGAS
   560 00000E8A FFB3C8000000                push qword [rbx + 200]                          ; 用户程序的 CS
   561 00000E90 FFB3C0000000                push qword [rbx + 192]                          ; 用户程序的 RIP
   562                                  
   563 00000E96 48CF                        iretq                                           ; 返回当前任务的私有空间执行, 弹出 rip, cs, rflags, rsp, ss 跳转
   564                                  
   565                                  core_end:
