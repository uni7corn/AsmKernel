     1                                  ; 内核
     2                                  
     3                                  %include "./common/global_defs.asm"
     1                              <1> ; 全局常量定义
     2                              <1> 
     3                              <1> %ifndef _GLOBAL_DEFS_
     4                              <1>     %define _GLOBAL_DEFS_
     5                              <1> 
     6                              <1>     SDA_PHY_ADDR        equ     0x00007e00	; 系统数据区的起始物理地址
     7                              <1>     PML5_PHY_ADDR       equ     0x00009000	; 内核 5 级头表物理地址
     8                              <1>     PML4_PHY_ADDR       equ     0x0000a000	; 内核 4 级头表物理地址
     9                              <1>     PDPT_PHY_ADDR       equ     0x0000b000	; 对应于低端 2MB 的内核页目录指针表物理地址
    10                              <1>     PDT_PHY_ADDR        equ     0x0000c000	; 对应于低端 2MB 的页目录表物理地址
    11                              <1>     PT_PHY_ADDR         equ     0x0000d000	; 对应于低端 2MB 的内核页表的物理地址
    12                              <1>     IDT_PHY_ADDR        equ     0x0000e000	; 中断描述符表的物理地址
    13                              <1>     LDR_PHY_ADDR        equ     0x0000f000	; 用于安装内核加载器的起始物理地址
    14                              <1>     GDT_PHY_ADDR        equ     0x00010000	; 全局描述符表 GDT 的物理地址
    15                              <1>     CORE_PHY_ADDR       equ     0x00020000	; 内核的起始物理地址
    16                              <1>     COR_PDPT_ADDR       equ     0x00100000	; 从这个物理地址开始的 1MB 是内核的 254 个页目录指针表
    17                              <1> 
    18                              <1>     LDR_START_SECTOR    equ     1      	        ; 内核加载器在硬盘上的起始逻辑扇区号
    19                              <1>     COR_START_SECTOR    equ     9      	        ; 内核程序在硬盘上的起始逻辑扇区号
    20                              <1> 
    21                              <1>     ; 虚拟内存空间的高端起始于线性地址 0xffff800000000000
    22                              <1>     UPPER_LINEAR_START  equ     0xffff800000000000  
    23                              <1>     UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	    ; 内核的高端线性地址
    24                              <1>     UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ; 文本显示缓冲区的高端起始线性地址
    25                              <1>     UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	    ; 系统数据区的高端线性地址
    26                              <1>     UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	    ; GDT 的高端线性地址
    27                              <1>     UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	    ; IDT 的高端线性地址
    28                              <1> 
    29                              <1>     ; 与全局描述符表有关的选择子定义, 及内存管理有关的常量定义
    30                              <1>     CORE_CODE64_SEL     equ     0x0018	; 内核代码段的描述符选择子(RPL=00)
    31                              <1>     CORE_STACK64_SEL    equ     0x0020	; 内核栈段的描述符选择子(RPL=00)
    32                              <1>     RESVD_DESC_SEL      equ     0x002b	; 保留的描述符选择子
    33                              <1>     USER_CODE64_SEL     equ     0x003b	; 3 特权级代码段的描述符选择子(RPL=11)
    34                              <1>     USER_STACK64_SEL    equ     0x0033	; 3 特权级栈段的描述符选择子(RPL=11)
    35                              <1> 
    36                              <1>     PHY_MEMORY_SIZE     equ     32    	            ; 物理内存大小(MB), 要求至少 3MB
    37                              <1>     CORE_ALLOC_START    equ     0xffff800000200000	; 在虚拟地址空间高端(内核)分配内存时的起始地址
    38                              <1>     USER_ALLOC_START    equ     0x0000000000000000	; 在每个任务虚拟地址空间低端分配内存时的起始地址
    39                              <1> 
    40                              <1>     ; 创建任务时, 需要分配一个物理页作为新任务的 4 级头表, 并分配一个临时的线性地址来初始化这个页
    41                              <1>     NEW_PML4_LINEAR     equ     0xffffff7ffffff000	; 用来映射新任务 4 级头表的线性地址
    42                              <1>     LAPIC_START_ADDR    equ     0xffffff7fffffe000	; LOCAL APIC 寄存器的起始线性地址
    43                              <1>     IOAPIC_START_ADDR   equ     0xffffff7fffffd000	; I/O APIC 寄存器的起始线性地址
    44                              <1>     AP_START_UP_ADDR    equ     0x0000f000 	        ; 应用处理器(AP)启动代码的物理地址
    45                              <1>     SUGG_PREEM_SLICE    equ     55          	    ; 推荐的任务/线程抢占时间片长度(毫秒)
    46                              <1> 
    47                              <1>     ; 多处理器环境下的自旋锁加锁宏。需要两个参数: 寄存器, 以及一个对应宽度的锁变量
    48                              <1>     %macro  SET_SPIN_LOCK 2             ; 两个参数, 分别是寄存器 %1 和锁变量 %2
    49                              <1>             %%spin_lock:
    50                              <1>                     cmp %2, 0           ; 看一眼锁现在是不是 0
    51                              <1>                     je %%get_lock      	; 如果是 0，说明没人占，跳过去抢
    52                              <1>                     pause				; 不是 0，先喘口气（降低 CPU 占用）, 见书中 341 页
    53                              <1>                     jmp %%spin_lock    	; 继续看
    54                              <1>             %%get_lock:
    55                              <1>                     mov %1, 1
    56                              <1>                     xchg %1, %2         ; 用 xchg 的“原子交换”能力抢锁，抢不到就一直循环（自旋）
    57                              <1>                     cmp %1, 0          	; 交换回来的 %2 旧值是 0 吗？
    58                              <1>                     jne %%spin_lock   	; 不是 0 说明别人先插了旗，回到开头重抢
    59                              <1>     %endmacro
    60                              <1> 
    61                              <1> %endif
     4                                  
     5                                  SECTION core_header                                 ; 内核头部
     6 00000000 [00000000]                  length      dd core_end                         ; 内核总长度
     7 00000004 [F9160000]                  init_entry  dd init                             ; 内核入口点
     8 00000008 0000000000000000            position    dq 0                                ; 内核加载虚拟地址
     9                                  
    10                                  SECTION core_data                                   ; 内核数据段
    11 00000000 41435049206973206E-         acpi_error  db "ACPI is not supported or data error.", 0x0d, 0x0a, 0
    11 00000009 6F7420737570706F72-
    11 00000012 746564206F72206461-
    11 0000001B 7461206572726F722E-
    11 00000024 0D0A00             
    12                                  
    13 00000027 00                          num_cpus    db 0                                ; 逻辑处理器数量
    14 00000028 00<rep 100h>                cpu_list    times 256 db 0                      ; Local APIC ID的列表
    15 00000128 00000000                    lapic_addr  dd 0                                ; Local APIC的物理地址
    16                                  
    17 0000012C 00000000                    ioapic_addr dd 0                                ; I/O APIC的物理地址
    18 00000130 00                          ioapic_id   db 0                                ; I/O APIC ID
    19                                  
    20 00000131 00                          ack_cpus    db 0                                ; 处理器初始化应答计数
    21                                  
    22 00000132 00000000                    clocks_1ms  dd 0                                ; 处理器在1ms内经历的时钟数
    23                                  
    24 00000136 457865637574696E67-         welcome     db "Executing in 64-bit mode.Init MP", 249, 0
    24 0000013F 20696E2036342D6269-
    24 00000148 74206D6F64652E496E-
    24 00000151 6974204D50F900     
    25 00000158 204350552873292072-         cpu_init_ok db " CPU(s) ready.", 0x0d, 0x0a, 0
    25 00000161 656164792E0D0A00   
    26                                  
    27 00000169 00<rep 100h>                buffer      times 256 db 0
    28                                  
    29 00000269 [1D09000000000000]          sys_entry   dq get_screen_row                   ; #0  获取一个可用的屏幕行坐标
    30 00000271 [8208000000000000]                      dq get_cmos_time                    ; #1  获取CMOS时间
    31 00000279 [DE00000000000000]                      dq put_cstringxy64                  ; #2  在指定坐标打印字符串
    32 00000281 [3915000000000000]                      dq create_process                   ; #3  创建任务
    33 00000289 [7A0F000000000000]                      dq get_current_pid                  ; #4  获取当前任务的标识
    34 00000291 [9C13000000000000]                      dq terminate_process                ; #5  终止当前任务
    35 00000299 [2809000000000000]                      dq get_cpu_number                   ; #6  获取当前CPU的标识
    36 000002A1 [2714000000000000]                      dq create_thread                    ; #7  创建线程
    37 000002A9 [630F000000000000]                      dq get_current_tid                  ; #8  获取当前线程的标识
    38 000002B1 [2B13000000000000]                      dq thread_exit                      ; #9  退出当前线程
    39 000002B9 [3B09000000000000]                      dq memory_allocate                  ; #10 用户空间内存分配
    40 000002C1 [C80F000000000000]                      dq waiting_for_a_thread             ; #11 等待指定的线程
    41 000002C9 [DD10000000000000]                      dq init_mutex                       ; #12 初始化互斥锁
    42 000002D1 [FD10000000000000]                      dq acquire_mutex                    ; #13 获取互斥锁
    43 000002D9 [0F12000000000000]                      dq release_mutex                    ; #14 释放互斥锁
    44 000002E1 [1812000000000000]                      dq thread_sleep                     ; #15 线程休眠
    45                                  
    46 000002E9 0000000000000000            pcb_ptr     dq 0                                ; 进程控制块PCB首节点的线性地址
    47                                  
    48                                  
    49                                  SECTION core_code                                   ; 内核代码段
    50                                  
    51                                  %include "./common/core_utils64.asm"
     1                              <1> ; 内核通用代码
     2                              <1> 
     3                              <1> ; 在多处理器环境中使用时, 需要在内核程序中定义宏 __MP__
     4                              <1> 
     5                              <1> %include "./common/global_defs.asm"
     1                              <2> ; 全局常量定义
     2                              <2> 
     3                              <2> %ifndef _GLOBAL_DEFS_
     4                              <2>     %define _GLOBAL_DEFS_
     5                              <2> 
     6                              <2>     SDA_PHY_ADDR        equ     0x00007e00	; 系统数据区的起始物理地址
     7                              <2>     PML5_PHY_ADDR       equ     0x00009000	; 内核 5 级头表物理地址
     8                              <2>     PML4_PHY_ADDR       equ     0x0000a000	; 内核 4 级头表物理地址
     9                              <2>     PDPT_PHY_ADDR       equ     0x0000b000	; 对应于低端 2MB 的内核页目录指针表物理地址
    10                              <2>     PDT_PHY_ADDR        equ     0x0000c000	; 对应于低端 2MB 的页目录表物理地址
    11                              <2>     PT_PHY_ADDR         equ     0x0000d000	; 对应于低端 2MB 的内核页表的物理地址
    12                              <2>     IDT_PHY_ADDR        equ     0x0000e000	; 中断描述符表的物理地址
    13                              <2>     LDR_PHY_ADDR        equ     0x0000f000	; 用于安装内核加载器的起始物理地址
    14                              <2>     GDT_PHY_ADDR        equ     0x00010000	; 全局描述符表 GDT 的物理地址
    15                              <2>     CORE_PHY_ADDR       equ     0x00020000	; 内核的起始物理地址
    16                              <2>     COR_PDPT_ADDR       equ     0x00100000	; 从这个物理地址开始的 1MB 是内核的 254 个页目录指针表
    17                              <2> 
    18                              <2>     LDR_START_SECTOR    equ     1      	        ; 内核加载器在硬盘上的起始逻辑扇区号
    19                              <2>     COR_START_SECTOR    equ     9      	        ; 内核程序在硬盘上的起始逻辑扇区号
    20                              <2> 
    21                              <2>     ; 虚拟内存空间的高端起始于线性地址 0xffff800000000000
    22                              <2>     UPPER_LINEAR_START  equ     0xffff800000000000  
    23                              <2>     UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	    ; 内核的高端线性地址
    24                              <2>     UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ; 文本显示缓冲区的高端起始线性地址
    25                              <2>     UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	    ; 系统数据区的高端线性地址
    26                              <2>     UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	    ; GDT 的高端线性地址
    27                              <2>     UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	    ; IDT 的高端线性地址
    28                              <2> 
    29                              <2>     ; 与全局描述符表有关的选择子定义, 及内存管理有关的常量定义
    30                              <2>     CORE_CODE64_SEL     equ     0x0018	; 内核代码段的描述符选择子(RPL=00)
    31                              <2>     CORE_STACK64_SEL    equ     0x0020	; 内核栈段的描述符选择子(RPL=00)
    32                              <2>     RESVD_DESC_SEL      equ     0x002b	; 保留的描述符选择子
    33                              <2>     USER_CODE64_SEL     equ     0x003b	; 3 特权级代码段的描述符选择子(RPL=11)
    34                              <2>     USER_STACK64_SEL    equ     0x0033	; 3 特权级栈段的描述符选择子(RPL=11)
    35                              <2> 
    36                              <2>     PHY_MEMORY_SIZE     equ     32    	            ; 物理内存大小(MB), 要求至少 3MB
    37                              <2>     CORE_ALLOC_START    equ     0xffff800000200000	; 在虚拟地址空间高端(内核)分配内存时的起始地址
    38                              <2>     USER_ALLOC_START    equ     0x0000000000000000	; 在每个任务虚拟地址空间低端分配内存时的起始地址
    39                              <2> 
    40                              <2>     ; 创建任务时, 需要分配一个物理页作为新任务的 4 级头表, 并分配一个临时的线性地址来初始化这个页
    41                              <2>     NEW_PML4_LINEAR     equ     0xffffff7ffffff000	; 用来映射新任务 4 级头表的线性地址
    42                              <2>     LAPIC_START_ADDR    equ     0xffffff7fffffe000	; LOCAL APIC 寄存器的起始线性地址
    43                              <2>     IOAPIC_START_ADDR   equ     0xffffff7fffffd000	; I/O APIC 寄存器的起始线性地址
    44                              <2>     AP_START_UP_ADDR    equ     0x0000f000 	        ; 应用处理器(AP)启动代码的物理地址
    45                              <2>     SUGG_PREEM_SLICE    equ     55          	    ; 推荐的任务/线程抢占时间片长度(毫秒)
    46                              <2> 
    47                              <2>     ; 多处理器环境下的自旋锁加锁宏。需要两个参数: 寄存器, 以及一个对应宽度的锁变量
    48                              <2>     %macro  SET_SPIN_LOCK 2             ; 两个参数, 分别是寄存器 %1 和锁变量 %2
    49                              <2>             %%spin_lock:
    50                              <2>                     cmp %2, 0           ; 看一眼锁现在是不是 0
    51                              <2>                     je %%get_lock      	; 如果是 0，说明没人占，跳过去抢
    52                              <2>                     pause				; 不是 0，先喘口气（降低 CPU 占用）, 见书中 341 页
    53                              <2>                     jmp %%spin_lock    	; 继续看
    54                              <2>             %%get_lock:
    55                              <2>                     mov %1, 1
    56                              <2>                     xchg %1, %2         ; 用 xchg 的“原子交换”能力抢锁，抢不到就一直循环（自旋）
    57                              <2>                     cmp %1, 0          	; 交换回来的 %2 旧值是 0 吗？
    58                              <2>                     jne %%spin_lock   	; 不是 0 说明别人先插了旗，回到开头重抢
    59                              <2>     %endmacro
    60                              <2> 
    61                              <2> %endif
     6                              <1> 
     7                              <1> 	[bits 64]
     8                              <1> 
     9                              <1> ; ------------------------------------------------------------
    10                              <1> ; put_string64
    11                              <1> ; 功能: 显示 0 终止的字符串并移动光标
    12                              <1> ; 输入: rbx=字符串的线性地址
    13                              <1> ; ------------------------------------------------------------
    14                              <1> %ifdef __MP__
    15                              <1> _prn_str_locker dq 0
    16                              <1> %endif
    17                              <1> 
    18                              <1> put_string64:
    19 00000000 53                  <1> 	push rbx 
    20 00000001 51                  <1> 	push rcx 
    21                              <1> 
    22 00000002 9C                  <1> 	pushfq 
    23 00000003 FA                  <1> 	cli 
    24                              <1> %ifdef __MP__
    25                              <1> 	SET_SPIN_LOCK rcx, qword [rel _prn_str_locker]		; 上锁
    26                              <1> %endif 
    27                              <1> 
    28                              <1> .getc:
    29 00000004 8A0B                <1> 	mov cl, [rbx]
    30 00000006 08C9                <1> 	or cl, cl 							; 检查是不是 0
    31 00000008 740A                <1> 	jz .exit 							; 如果是 0 跳转到退出代码
    32 0000000A E809000000          <1> 	call put_char 
    33 0000000F 48FFC3              <1> 	inc rbx 
    34 00000012 EBF0                <1> 	jmp .getc
    35                              <1> 
    36                              <1> .exit:
    37                              <1> %ifdef __MP__ 
    38                              <1> 	mov qword [rel _prn_str_locker], 0					; 释放锁
    39                              <1> %endif
    40 00000014 9D                  <1> 	popfq
    41                              <1> 
    42 00000015 59                  <1> 	pop rcx 
    43 00000016 5B                  <1> 	pop rbx 
    44                              <1> 
    45 00000017 C3                  <1> 	ret 
    46                              <1> 	
    47                              <1> ; ------------------------------------------------------------
    48                              <1> ; put_char
    49                              <1> ; 功能: 在屏幕上的当前光标处显示一个字符并推进光标(ldr.asm 中 put_char 的 64 位版本)
    50                              <1> ; 输入: cl=字符ASCII码
    51                              <1> ; ------------------------------------------------------------
    52                              <1> put_char:
    53 00000018 50                  <1> 	push rax 
    54 00000019 53                  <1> 	push rbx 
    55 0000001A 51                  <1> 	push rcx 
    56 0000001B 52                  <1> 	push rdx 
    57 0000001C 56                  <1> 	push rsi 
    58 0000001D 57                  <1> 	push rdi 
    59                              <1> 
    60                              <1> 	; 获取光标位置
    61 0000001E 66BAD403            <1> 	mov dx, 0x3d4
    62 00000022 B00E                <1> 	mov al, 0x0e 
    63 00000024 EE                  <1> 	out dx, al 
    64 00000025 66FFC2              <1> 	inc dx 
    65 00000028 EC                  <1> 	in al, dx 								; 高字
    66 00000029 88C4                <1> 	mov ah, al 
    67                              <1> 
    68 0000002B 66FFCA              <1> 	dec dx 
    69 0000002E B00F                <1> 	mov al, 0x0f 
    70 00000030 EE                  <1> 	out dx, al 
    71 00000031 66FFC2              <1> 	inc dx 
    72 00000034 EC                  <1> 	in al, dx 								; 低字
    73 00000035 6689C3              <1> 	mov bx, ax 								; 此时 bx 中存储了字符的数目, 一个字符占两个字节
    74 00000038 4881E3FFFF0000      <1> 	and rbx, 0x000000000000ffff 			; 准备使用 64 位寻址方式访问显存
    75                              <1> 
    76 0000003F 80F90D              <1> 	cmp cl, 0x0d							; 回车符?
    77 00000042 750E                <1> 	jnz .put_0a
    78 00000044 6689D8              <1> 	mov ax, bx 
    79 00000047 B350                <1> 	mov bl, 80
    80 00000049 F6F3                <1> 	div bl 
    81 0000004B F6E3                <1> 	mul bl 									; 移到本行起始
    82 0000004D 6689C3              <1> 	mov bx, ax 	
    83 00000050 EB6C                <1> 	jmp .set_cursor
    84                              <1> 
    85                              <1> .put_0a:
    86 00000052 80F90A              <1> 	cmp cl, 0x0a 							; 换行符?
    87 00000055 7506                <1> 	jnz .put_other
    88 00000057 6683C350            <1> 	add bx, 80								; 平移一行
    89 0000005B EB16                <1> 	jmp .roll_screen
    90                              <1> 
    91                              <1> .put_other:						
    92 0000005D 66D1E3              <1> 	shl bx, 1								; 转换成字节数
    93 00000060 48B800800B000080FF- <1> 	mov rax, UPPER_TEXT_VIDEO
    93 00000069 FF                  <1>
    94 0000006A 880C18              <1> 	mov [rax + rbx], cl 					; 写入字符
    95                              <1> 
    96 0000006D 66D1EB              <1> 	shr bx, 1								; 转回字符数
    97 00000070 66FFC3              <1> 	inc bx 
    98                              <1> 
    99                              <1> .roll_screen:
   100 00000073 6681FBD007          <1> 	cmp bx, 2000							; 光标超出屏幕? 滚屏
   101 00000078 7C44                <1> 	jl .set_cursor 
   102                              <1> 	
   103 0000007A 6653                <1> 	push bx 
   104                              <1> 
   105 0000007C FC                  <1> 	cld 									; 清除方向标志位
   106 0000007D 48BEA0800B000080FF- <1> 	mov rsi, UPPER_TEXT_VIDEO + 0xa0		; 源地址
   106 00000086 FF                  <1>
   107 00000087 48BF00800B000080FF- <1> 	mov rdi, UPPER_TEXT_VIDEO				; 目标地址
   107 00000090 FF                  <1>
   108 00000091 B9E0010000          <1> 	mov rcx, 480							; 480 == 24 x 80 x 2 / 8。前 24 行向上平移一行
   109 00000096 F348A5              <1> 	rep movsq								
   110                              <1> 
   111 00000099 66BB000F            <1> 	mov bx, 3840							; 24 x 80 x 2。清除最后一行
   112 0000009D B950000000          <1> 	mov rcx, 80
   113                              <1> .cls:
   114 000000A2 48B800800B000080FF- <1> 	mov rax, UPPER_TEXT_VIDEO
   114 000000AB FF                  <1>
   115 000000AC 66C704182007        <1> 	mov word [rax + rbx], 0x0720
   116 000000B2 6683C302            <1> 	add bx, 2 
   117 000000B6 E2EA                <1> 	loop .cls 
   118                              <1> 
   119 000000B8 665B                <1> 	pop bx 									; 考虑换行符
   120 000000BA 6683EB50            <1> 	sub bx, 80
   121                              <1> 
   122                              <1> .set_cursor:
   123 000000BE 66BAD403            <1> 	mov dx, 0x3d4
   124 000000C2 B00E                <1> 	mov al, 0x0e 
   125 000000C4 EE                  <1> 	out dx, al 
   126 000000C5 66FFC2              <1> 	inc dx 									; 0x3d5
   127 000000C8 88F8                <1> 	mov al, bh 
   128 000000CA EE                  <1> 	out dx, al 
   129                              <1> 
   130 000000CB 66FFCA              <1> 	dec dx 									; 0x3d4
   131 000000CE B00F                <1> 	mov al, 0x0f 
   132 000000D0 EE                  <1> 	out dx, al 
   133 000000D1 66FFC2              <1> 	inc dx 									; 0x3d5
   134 000000D4 88D8                <1> 	mov al, bl 
   135 000000D6 EE                  <1> 	out dx, al 
   136                              <1> 
   137 000000D7 5F                  <1> 	pop rdi 
   138 000000D8 5E                  <1> 	pop rsi 
   139 000000D9 5A                  <1> 	pop rdx 
   140 000000DA 59                  <1> 	pop rcx 
   141 000000DB 5B                  <1> 	pop rbx 
   142 000000DC 58                  <1> 	pop rax 
   143                              <1> 
   144 000000DD C3                  <1> 	ret 
   145                              <1> 
   146                              <1> ; ------------------------------------------------------------
   147                              <1> ; put_cstringxy64
   148                              <1> ; 功能: 在指定位置用指定颜色显示 0 终止的字符串，只适用于打印图形字符。由于各程序打印时的坐标位置不同，互不干扰，不需要加锁和互斥。
   149                              <1> ; 输入: rbx=字符串首地址, dh=行, dl=列, r9b=颜色属性
   150                              <1> ; ------------------------------------------------------------
   151                              <1> %ifdef __MP__ 
   152                              <1> _prnxy_locker dq 0
   153                              <1> %endif 
   154                              <1> 
   155                              <1> put_cstringxy64:
   156 000000DE 50                  <1> 	push rax 
   157 000000DF 53                  <1> 	push rbx 
   158 000000E0 51                  <1> 	push rcx 
   159 000000E1 52                  <1> 	push rdx 
   160 000000E2 4150                <1> 	push r8 
   161                              <1> 
   162                              <1> 	; 指定坐标位置在显存内的偏移量
   163 000000E4 88F0                <1> 	mov al, dh 
   164 000000E6 B5A0                <1> 	mov ch, 160									; 每行 80 个字符, 占用 160 字节
   165 000000E8 F6E5                <1> 	mul ch 
   166 000000EA D0E2                <1> 	shl dl, 1									; 每个字符占两字节
   167 000000EC 6681E2FF00          <1> 	and dx, 0x00ff
   168 000000F1 6601D0              <1> 	add ax, dx 									; 得到相应显存偏移
   169 000000F4 4825FFFF0000        <1> 	and rax, 0x000000000000ffff
   170                              <1> 
   171 000000FA 9C                  <1> 	pushfq										; 将 RFLAGS 寄存器的全部 64 位标志位压入当前栈顶
   172 000000FB FA                  <1> 	cli 
   173                              <1> 
   174                              <1> %ifdef __MP__									; 读写显存时加锁
   175                              <1> 	SET_SPIN_LOCK r8, qword [rel _prnxy_locker]
   176                              <1> %endif 
   177                              <1> 
   178 000000FC 49B800800B000080FF- <1> 	mov r8, UPPER_TEXT_VIDEO					; 显存起始线性地址
   178 00000105 FF                  <1>
   179                              <1> .nextc:
   180 00000106 8A13                <1> 	mov dl, [rbx]								; 获取将要显示的字符
   181 00000108 08D2                <1> 	or dl, dl 
   182 0000010A 7412                <1> 	jz .exit 
   183 0000010C 41881400            <1> 	mov byte [r8 + rax], dl 					; 字符内容
   184 00000110 45884C0001          <1> 	mov byte [r8 + rax + 1], r9b 				; 字符颜色
   185 00000115 48FFC3              <1> 	inc rbx 
   186 00000118 4883C002            <1> 	add rax, 2
   187 0000011C EBE8                <1> 	jmp .nextc
   188                              <1> .exit:
   189 0000011E 4D31C0              <1> 	xor r8, r8 
   190                              <1> 
   191                              <1> %ifdef __MP__									; 读写显存时释放锁
   192                              <1> 	mov qword [rel _prnxy_locker], 0
   193                              <1> %endif 
   194                              <1> 
   195 00000121 9D                  <1> 	popfq 
   196                              <1> 
   197 00000122 4158                <1> 	pop r8 
   198 00000124 5A                  <1> 	pop rdx 
   199 00000125 59                  <1> 	pop rcx 
   200 00000126 5B                  <1> 	pop rbx 
   201 00000127 58                  <1> 	pop rax 
   202                              <1> 
   203 00000128 C3                  <1> 	ret 
   204                              <1> 
   205                              <1> ; ------------------------------------------------------------
   206                              <1> ; make_interrupt_gate
   207                              <1> ; 功能: 创建 64 位的中断门
   208                              <1> ; 输入: rax=处理程序的线性地址
   209                              <1> ; 输出: rdi 与 rsi 组成中断门(中断门、陷阱门格式见书中 148 页)
   210                              <1> ; ------------------------------------------------------------
   211                              <1> make_interrupt_gate:
   212 00000129 4889C7              <1> 	mov rdi, rax 
   213 0000012C 48C1EF20            <1> 	shr rdi, 32 						; 门的高 64 位, 其中高 32 位是保留
   214                              <1> 
   215 00000130 50                  <1> 	push rax 							; 借助栈构造, 先压入完整 rax, 也就是门的低 64 位, 在对其修改
   216 00000131 66C74424021800      <1> 	mov word [rsp + 2], CORE_CODE64_SEL	; 填入选择子
   217 00000138 89442404            <1> 	mov [rsp + 4], eax 					; 填入线性地址 31~16 位
   218 0000013C 66C7442404008E      <1> 	mov word [rsp + 4], 0x8e00			; 填入属性, P=1, TYPE=64 的中断门, 覆盖填入
   219 00000143 5E                  <1> 	pop rsi 
   220                              <1> 
   221 00000144 C3                  <1> 	ret 								; 可以参考书中 155 页的图
   222                              <1> 
   223                              <1> ; ------------------------------------------------------------
   224                              <1> ; make_tss_descriptor
   225                              <1> ; 功能: 创建 64 位的 TSS 描述符
   226                              <1> ; 输入: rax=TSS 的线性地址
   227                              <1> ; 输出: rdi:rsi=TSS 描述符(LDT, TSS 描述符格式见书中 200 页)
   228                              <1> ; ------------------------------------------------------------
   229                              <1> make_tss_descriptor:
   230 00000145 50                  <1> 	push rax 
   231                              <1> 
   232 00000146 4889C7              <1> 	mov rdi, rax 
   233 00000149 48C1EF20            <1> 	shr rdi, 32							; 得到门高 64 位, 存在 rdi 中
   234                              <1> 
   235 0000014D 50                  <1> 	push rax 							; 借助栈构造, 先压入完整 rax, 也就是门的低 64 位, 在对其修改
   236 0000014E 48C1242410          <1> 	shl qword [rsp], 16 				; 将线性地址 23~0 位移到正确位置
   237 00000153 66C704246800        <1> 	mov word [rsp], 104					; 填入段界限标准长度
   238 00000159 8A442405            <1> 	mov al, [rsp + 5]
   239 0000015D 88442407            <1> 	mov [rsp + 7], al 					; 将线性地址 31~24 位移到正确位置
   240 00000161 C644240589          <1> 	mov byte [rsp + 5], 0x89 			; P=1, DPL=0, TYPE=0b1001(64 位 TSS)
   241 00000166 C644240600          <1> 	mov byte [rsp + 6], 0				; G, 0, 0, AVL, limit
   242 0000016B 5E                  <1> 	pop rsi								; 门低 64 位
   243                              <1> 
   244 0000016C 58                  <1> 	pop rax 
   245                              <1> 
   246 0000016D C3                  <1> 	ret 
   247                              <1> 
   248                              <1> ; ------------------------------------------------------------
   249                              <1> ; mount_idt_entry
   250                              <1> ; 功能: 在中断描述符表 IDT 中安装门描述符
   251                              <1> ; 输入: r8=中断向量, rdi 与 rsi 组成中断门
   252                              <1> ; ------------------------------------------------------------
   253                              <1> mount_idt_entry:
   254 0000016E 4150                <1> 	push r8
   255 00000170 4151                <1> 	push r9 
   256                              <1> 
   257 00000172 49C1E004            <1> 	shl r8, 4 							; 中断号乘以 16 得到表内偏移, 每个中断门 16 字节大小
   258 00000176 49B900E000000080FF- <1> 	mov r9, UPPER_IDT_LINEAR			; 中断描述符表的高端地址
   258 0000017F FF                  <1>
   259 00000180 4B893401            <1> 	mov [r9 + r8], rsi 
   260 00000184 4B897C0108          <1> 	mov [r9 + r8 + 8], rdi 
   261                              <1> 
   262 00000189 4159                <1> 	pop r9 
   263 0000018B 4158                <1> 	pop r8 
   264                              <1> 
   265 0000018D C3                  <1> 	ret  
   266                              <1> 
   267                              <1> ; ------------------------------------------------------------
   268                              <1> ; init_8259
   269                              <1> ; 功能: 初始化8259中断控制器，包括重新设置向量号
   270                              <1> ; ------------------------------------------------------------
   271                              <1> init_8259:
   272 0000018E 50                  <1> 	push rax
   273                              <1> 
   274 0000018F B011                <1> 	mov al, 0x11
   275 00000191 E620                <1> 	out 0x20, al                    	; ICW1: 边沿触发/级联方式
   276 00000193 B020                <1> 	mov al, 0x20
   277 00000195 E621                <1> 	out 0x21, al  						; ICW2: 起始中断向量（避开前31个异常的向量）
   278 00000197 B004                <1> 	mov al, 0x04
   279 00000199 E621                <1> 	out 0x21, al  						; ICW3: 从片级联到 IR2
   280 0000019B B001                <1> 	mov al, 0x01
   281 0000019D E621                <1> 	out 0x21, al                  		; ICW4: 非总线缓冲，全嵌套，正常 EOI
   282                              <1> 
   283 0000019F B011                <1> 	mov al, 0x11
   284 000001A1 E6A0                <1> 	out 0xa0, al                  		; ICW1: 边沿触发/级联方式
   285 000001A3 B028                <1> 	mov al, 0x28
   286 000001A5 E6A1                <1> 	out 0xa1, al                  		; ICW2: 起始中断向量-->0x28
   287 000001A7 B002                <1> 	mov al, 0x02
   288 000001A9 E6A1                <1> 	out 0xa1, al                  		; ICW3: 从片识别标志，级联到主片 IR2
   289 000001AB B001                <1> 	mov al, 0x01
   290 000001AD E6A1                <1> 	out 0xa1, al                  		; ICW4: 非总线缓冲，全嵌套，正常 EOI
   291                              <1> 
   292 000001AF 58                  <1> 	pop rax
   293 000001B0 C3                  <1> 	ret
   294                              <1> 
   295                              <1> ; ------------------------------------------------------------
   296                              <1> ; read_hard_disk_0
   297                              <1> ; 功能: 从硬盘读取一个逻辑扇区
   298                              <1> ; 输入: rax=逻辑扇区号, rbx=目标缓冲区线性地址
   299                              <1> ; 输出: rbx=rbx+512
   300                              <1> ; ------------------------------------------------------------
   301                              <1> %ifdef __MP__
   302                              <1> _read_hdd_locker dq 0						
   303                              <1> %endif
   304                              <1> 
   305                              <1> read_hard_disk_0:
   306 000001B1 50                  <1> 	push rax 
   307 000001B2 51                  <1> 	push rcx 
   308 000001B3 52                  <1> 	push rdx 
   309 000001B4 9C                  <1> 	pushfq
   310                              <1> 
   311 000001B5 FA                  <1> 	cli 
   312                              <1> 
   313                              <1> %ifdef __MP__
   314                              <1> 	SET_SPIN_LOCK rdx, qword [rel _read_hdd_locker]
   315                              <1> %endif
   316                              <1> 
   317 000001B6 50                  <1> 	push rax 
   318                              <1> 
   319 000001B7 66BAF201            <1> 	mov dx, 0x1f2 								; 0x1f2
   320 000001BB B001                <1> 	mov al, 1
   321 000001BD EE                  <1> 	out dx, al 									; 读取扇区数
   322                              <1> 
   323 000001BE 66FFC2              <1> 	inc dx 										; 0x1f3 
   324 000001C1 58                  <1> 	pop rax 
   325 000001C2 EE                  <1> 	out dx, al 									; LBA 地址 7~0
   326                              <1> 
   327 000001C3 B108                <1> 	mov cl, 8 
   328                              <1> 
   329 000001C5 66FFC2              <1> 	inc dx 										; 0x1f4
   330 000001C8 48D3E8              <1> 	shr rax, cl 
   331 000001CB EE                  <1> 	out dx, al 									; LBA 地址 15~8
   332                              <1> 
   333 000001CC 66FFC2              <1> 	inc dx 										; 0x1f5
   334 000001CF 48D3E8              <1> 	shr rax, cl 
   335 000001D2 EE                  <1> 	out dx, al 									; LBA 地址 23~16
   336                              <1> 
   337 000001D3 66FFC2              <1> 	inc dx 										; 0x1f6
   338 000001D6 48D3E8              <1> 	shr rax, cl 
   339 000001D9 0CE0                <1> 	or al, 0xe0 								; 第一硬盘, LBA 地址 27~24
   340 000001DB EE                  <1> 	out dx, al 
   341                              <1> 
   342 000001DC 66FFC2              <1> 	inc dx 										; 0x1f6
   343 000001DF B020                <1> 	mov al, 0x20 								; 读命令
   344 000001E1 EE                  <1> 	out dx, al 
   345                              <1> 
   346                              <1> .waits:
   347 000001E2 EC                  <1> 	in al, dx 
   348 000001E3 A808                <1> 	test al, 8
   349 000001E5 74FB                <1> 	jz .waits
   350                              <1> 	; 不忙且硬盘已经准备好传输数据
   351 000001E7 B900010000          <1> 	mov rcx, 256								; 总共要读的字数=2字节
   352 000001EC 66BAF001            <1> 	mov dx, 0x1f0 
   353                              <1> .readw:
   354 000001F0 66ED                <1> 	in ax, dx 
   355 000001F2 668903              <1> 	mov [rbx], ax 
   356 000001F5 4883C302            <1> 	add rbx, 2
   357 000001F9 E2F5                <1> 	loop .readw 
   358                              <1> 
   359                              <1> %ifdef __MP__
   360                              <1> 	mov qword [rel _read_hdd_locker], 0
   361                              <1> %endif
   362                              <1> 
   363 000001FB 9D                  <1> 	popfq
   364 000001FC 5A                  <1> 	pop rdx 
   365 000001FD 59                  <1> 	pop rcx 
   366 000001FE 58                  <1> 	pop rax 
   367                              <1> 
   368 000001FF C3                  <1> 	ret 
   369                              <1> 
   370                              <1> ; ------------------------------------------------------------
   371                              <1> ; allocate_a_4k_page
   372                              <1> ; 功能: 分配一个 4KB 的页
   373                              <1> ; 输出: rax=页的物理地址
   374                              <1> ; ------------------------------------------------------------	
   375 00000200 FF<rep 40h>         <1> _page_bit_map times 2 * 1024 / 4 / 8 db 0xff 		; 对应物理内存前 512 页(2MB), 见书中 193 页
   376 00000240 00<rep 3C0h>        <1> 	times (PHY_MEMORY_SIZE - 2) * 1024 / 4 / 8 db 0	; 存放后续的页面
   377                              <1> _page_map_len equ $ - _page_bit_map
   378                              <1> 
   379                              <1> allocate_a_4k_page:
   380 00000600 4831C0              <1> 	xor rax, rax 
   381                              <1> .b1:
   382 00000603 F0480FAB05F4FBFFFF  <1> 	lock bts [rel _page_bit_map], rax 				; 多处理器需要 lock, 这是一个指令前缀，用于将随后的指令变成原子操作
   383 0000060C 730B                <1> 	jnc .b2 
   384 0000060E 48FFC0              <1> 	inc rax 
   385 00000611 483D00200000        <1> 	cmp rax, _page_map_len * 8
   386 00000617 7CEA                <1> 	jl .b1 
   387                              <1> 
   388                              <1> 	; 对我们这个简单的系统来说，通常不存在页面不够分配的情况。对于一个流行的系统来说, 
   389                              <1> 	; 如果页面不够分配，需要在这里执行虚拟内存管理，即，回收已经注销的页面，或者执行页面的换入和换出。
   390                              <1> .b2:
   391 00000619 48C1E00C            <1> 	shl rax, 12										; rax 是位数, 转换为内存要乘 4098
   392                              <1> 
   393 0000061D C3                  <1> 	ret 
   394                              <1> 
   395                              <1> ; ------------------------------------------------------------
   396                              <1> ; lin_to_lin_of_pml4e
   397                              <1> ; 功能: 返回指定的线性地址所对应的 4 级头表项的线性地址
   398                              <1> ; 输入: r13=线性地址
   399                              <1> ; 输出: r14=对应的 4 级头表项的线性地址
   400                              <1> ; ------------------------------------------------------------
   401                              <1> lin_to_lin_of_pml4e:
   402 0000061E 4155                <1> 	push r13 
   403                              <1> 
   404 00000620 49BE0000000080FF00- <1> 	mov r14, 0x0000_ff80_0000_0000 			; 保留 4 级头表索引部分
   404 00000629 00                  <1>
   405 0000062A 4D21F5              <1> 	and r13, r14 	
   406 0000062D 49C1ED24            <1> 	shr r13, 36								; 右移到低位, 相当于偏移 = 索引 * 8
   407                              <1> 
   408                              <1> 	; 这个利用了递归映射, 还记得在 ldr.asm 中我们将 4 级头表中最后一个项填入了其本身的地址, 
   409                              <1> 	; 而 0xffff_ffff_ffff_f000 这个线性地址前缀会一直访问最后一个表项, 得到的也一直是 4 级头表的地址
   410 00000631 49C7C600F0FFFF      <1> 	mov r14, 0xffff_ffff_ffff_f000			; 访问 4 级头表所用的地址前缀
   411 00000638 4D01EE              <1> 	add r14, r13 							
   412                              <1> 
   413 0000063B 415D                <1> 	pop r13 
   414                              <1> 
   415 0000063D C3                  <1> 	ret 
   416                              <1> 
   417                              <1> ; ------------------------------------------------------------
   418                              <1> ; lin_to_lin_of_pdpte
   419                              <1> ; 功能: 返回指定的线性地址所对应的页目录指针项的线性地址
   420                              <1> ; 输入: r13=线性地址
   421                              <1> ; 输出: r14=对应的页目录指针项的线性地址
   422                              <1> ; ------------------------------------------------------------
   423                              <1> lin_to_lin_of_pdpte:
   424 0000063E 4155                <1> 	push r13 
   425                              <1> 
   426 00000640 49BE000000C0FFFF00- <1> 	mov r14, 0x0000_ffff_c000_0000			; 保留 4 级头表索引和页目录指针表索引部分
   426 00000649 00                  <1>
   427 0000064A 4D21F5              <1> 	and r13, r14 
   428 0000064D 49C1ED1B            <1> 	shr r13, 27								
   429                              <1> 
   430                              <1> 	; 同上
   431 00000651 49C7C60000E0FF      <1> 	mov r14, 0xffff_ffff_ffe0_0000
   432 00000658 4D01EE              <1> 	add r14, r13 
   433                              <1> 
   434 0000065B 415D                <1> 	pop r13
   435                              <1> 
   436 0000065D C3                  <1> 	ret 
   437                              <1> 
   438                              <1> ; ------------------------------------------------------------
   439                              <1> ; lin_to_lin_of_pdte
   440                              <1> ; 功能: 返回指定的线性地址所对应的页目录项的线性地址
   441                              <1> ; 输入: r13=线性地址
   442                              <1> ; 输出: r14=对应的页目录项的线性地址
   443                              <1> ; ------------------------------------------------------------
   444                              <1> lin_to_lin_of_pdte:
   445 0000065E 4155                <1> 	push r13 
   446                              <1> 
   447 00000660 49BE0000E0FFFFFF00- <1> 	mov r14, 0x0000_ffff_ffe0_0000			; 保留 4 级头表索引、页目录指针表索引和页目录表
   447 00000669 00                  <1>
   448 0000066A 4D21F5              <1> 	and r13, r14 
   449 0000066D 49C1ED12            <1> 	shr r13, 18								
   450                              <1> 
   451                              <1> 	; 同上
   452 00000671 49C7C6000000C0      <1> 	mov r14, 0xffff_ffff_c000_0000
   453 00000678 4D01EE              <1> 	add r14, r13 
   454                              <1> 
   455 0000067B 415D                <1> 	pop r13
   456                              <1> 
   457 0000067D C3                  <1> 	ret 
   458                              <1> 
   459                              <1> ; ------------------------------------------------------------
   460                              <1> ; lin_to_lin_of_pte
   461                              <1> ; 功能: 返回指定的线性地址所对应的页表项的线性地址
   462                              <1> ; 输入: r13=线性地址
   463                              <1> ; 输出: r14=对应的页表项的线性地址
   464                              <1> ; ------------------------------------------------------------
   465                              <1> lin_to_lin_of_pte:
   466 0000067E 4155                <1> 	push r13 
   467                              <1> 
   468 00000680 49BE00F0FFFFFFFF00- <1> 	mov r14, 0x0000_ffff_ffff_f000			; 保留 4 级头表、页目录指针表、页目录表和页表的索引部分
   468 00000689 00                  <1>
   469 0000068A 4D21F5              <1> 	and r13, r14 
   470 0000068D 49C1ED09            <1> 	shr r13, 9								
   471                              <1> 
   472                              <1> 	; 同上
   473 00000691 49BE0000000080FFFF- <1> 	mov r14, 0xffff_ff80_0000_0000
   473 0000069A FF                  <1>
   474 0000069B 4D01EE              <1> 	add r14, r13 
   475                              <1> 
   476 0000069E 415D                <1> 	pop r13
   477                              <1> 
   478 000006A0 C3                  <1> 	ret 
   479                              <1> 
   480                              <1> 
   481                              <1> ; ------------------------------------------------------------
   482                              <1> ; find_pte_for_laddr
   483                              <1> ; 功能: 为指定的线性地址寻找到页表项线性地址
   484                              <1> ; 注意: 不保证线程安全, 如果需要在外部加锁, 关中断. 使用了 rcx, rax, r14 寄存器, 但不负责维护内容不变, 如果需要在外部 push, pop
   485                              <1> ; 输入: r13=线性地址
   486                              <1> ; 输出: r14=页表项线性地址
   487                              <1> ; ------------------------------------------------------------
   488                              <1> find_pte_for_laddr:
   489                              <1> 	; 四级头表一定存在, 检查对应地址的四级头表项是否存在
   490 000006A1 E878FFFFFF          <1> 	call lin_to_lin_of_pml4e							; 得到四级头表项的线性地址
   491 000006A6 49F70601000000      <1> 	test qword [r14], 1									; 看 P 位是否为 1 判断表项是否存在
   492 000006AD 752B                <1> 	jnz .b0
   493                              <1> 
   494                              <1> 	; 创建并安装该线性地址所对应的 4 级头表项(创建页目录指针表)
   495 000006AF E84CFFFFFF          <1> 	call allocate_a_4k_page								; 分配一个页作为页目录指针表
   496 000006B4 4883C807            <1> 	or rax, 0x07										; rax 是分配页的物理地址, 添加属性位 U/S=R/W=P=1
   497 000006B8 498906              <1> 	mov [r14], rax 										; 在 4 级头表中登记 4 级头表项
   498                              <1> 
   499                              <1> 	; 清空刚分配的页目录指针表
   500 000006BB E87EFFFFFF          <1> 	call lin_to_lin_of_pdpte
   501 000006C0 49C1EE0C            <1> 	shr r14, 12
   502 000006C4 49C1E60C            <1> 	shl r14, 12											; 得到页目录指针表的线性地址, 低 12 位是页目录指针项在页目录指针表内的偏移
   503 000006C8 B900020000          <1> 	mov rcx, 512
   504                              <1> .cls0:
   505 000006CD 49C70600000000      <1> 	mov qword [r14], 0
   506 000006D4 4983C608            <1> 	add r14, 8
   507 000006D8 E2F3                <1> 	loop .cls0
   508                              <1> 
   509                              <1> .b0:
   510                              <1> 	; 检查该线性地址对应的页目录指针项是否存在
   511 000006DA E85FFFFFFF          <1> 	call lin_to_lin_of_pdpte 							; 得到页目录指针项的线性地址
   512 000006DF 49F70601000000      <1> 	test qword [r14], 1									; 看 P 位是否为 1 判断表项是否存在
   513 000006E6 752B                <1> 	jnz .b1 
   514                              <1> 
   515                              <1> 	; 创建并安装该线性地址对应的页目录指针项
   516 000006E8 E813FFFFFF          <1> 	call allocate_a_4k_page								; 分配一个页作为页目录表
   517 000006ED 4883C807            <1> 	or rax, 0x07
   518 000006F1 498906              <1> 	mov [r14], rax 
   519                              <1> 
   520                              <1> 	; 清空刚分配的页目录表
   521 000006F4 E865FFFFFF          <1> 	call lin_to_lin_of_pdte 
   522 000006F9 49C1EE0C            <1> 	shr r14, 12
   523 000006FD 49C1E60C            <1> 	shl r14, 12 
   524 00000701 B900020000          <1> 	mov rcx, 512 
   525                              <1> .cls1:
   526 00000706 49C70600000000      <1> 	mov qword [r14], 0
   527 0000070D 4983C608            <1> 	add r14, 8
   528 00000711 E2F3                <1> 	loop .cls1 
   529                              <1> 
   530                              <1> .b1:
   531                              <1> 	; 检查该线性地址对应的页目录指针项是否存在
   532 00000713 E846FFFFFF          <1> 	call lin_to_lin_of_pdte 
   533 00000718 49F70601000000      <1> 	test qword [r14], 1
   534 0000071F 752B                <1> 	jnz .b2 
   535                              <1> 
   536                              <1> 	; 创建并安装该线性地址对应的页目录项, 即分配页表
   537 00000721 E8DAFEFFFF          <1> 	call allocate_a_4k_page
   538 00000726 4883C807            <1> 	or rax, 0x07
   539 0000072A 498906              <1> 	mov [r14], rax 
   540                              <1> 
   541                              <1> 	; 清空刚分配的页表
   542 0000072D E84CFFFFFF          <1> 	call lin_to_lin_of_pte 
   543 00000732 49C1EE0C            <1> 	shr r14, 12
   544 00000736 49C1E60C            <1> 	shl r14, 12
   545 0000073A B900020000          <1> 	mov rcx, 512
   546                              <1> 
   547                              <1> .cls2:
   548 0000073F 49C70600000000      <1> 	mov qword [r14], 0
   549 00000746 4983C608            <1> 	add r14, 8
   550 0000074A E2F3                <1> 	loop .cls2 
   551                              <1> 
   552                              <1> .b2:
   553                              <1> 	; 检查该线性地址所对应的页表项是否存在
   554 0000074C E82DFFFFFF          <1> 	call lin_to_lin_of_pte 
   555                              <1> 
   556 00000751 C3                  <1> 	ret 
   557                              <1> 
   558                              <1> ; ------------------------------------------------------------
   559                              <1> ; setup_paging_for_laddr
   560                              <1> ; 功能: 为指定的线性地址安装分页
   561                              <1> ; 输入: r13=线性地址
   562                              <1> ; ------------------------------------------------------------
   563                              <1> %ifdef __MP__
   564                              <1> _spaging_locker dq 0
   565                              <1> %endif
   566                              <1> 
   567                              <1> setup_paging_for_laddr:
   568 00000752 51                  <1> 	push rcx 
   569 00000753 50                  <1> 	push rax 
   570 00000754 4156                <1> 	push r14 
   571 00000756 9C                  <1> 	pushfq
   572                              <1> 
   573 00000757 FA                  <1> 	cli 
   574                              <1> 
   575                              <1> %ifdef __MP__
   576                              <1> 	SET_SPIN_LOCK r14, qword [rel _spaging_locker]
   577                              <1> %endif 
   578                              <1> 
   579 00000758 E844FFFFFF          <1> 	call find_pte_for_laddr
   580 0000075D 49F70601000000      <1> 	test qword [r14], 1
   581 00000764 750C                <1> 	jnz .exit
   582                              <1> 
   583                              <1> 	; 创建并安装该地址对应的页表项, 即最终分配的页
   584 00000766 E895FEFFFF          <1> 	call allocate_a_4k_page
   585 0000076B 4883C807            <1> 	or rax, 0x07										; 设置属性
   586 0000076F 498906              <1> 	mov [r14], rax 
   587                              <1> 
   588                              <1> .exit:
   589                              <1> %ifdef __MP__
   590                              <1> 	mov qword [rel _spaging_locker], 0
   591                              <1> %endif
   592 00000772 9D                  <1> 	popfq 
   593                              <1> 
   594 00000773 415E                <1> 	pop r14 
   595 00000775 58                  <1> 	pop rax 
   596 00000776 59                  <1> 	pop rcx 
   597                              <1> 
   598 00000777 C3                  <1> 	ret 
   599                              <1> ; ------------------------------------------------------------
   600                              <1> ; mapping_laddr_to_page
   601                              <1> ; 功能: 建立线性地址到物理页的映射, 即, 为指定的线性地址安装指定的物理页
   602                              <1> ; 输入: r13=线性地址, rax=页的物理地址（含属性）
   603                              <1> ; ------------------------------------------------------------
   604                              <1> %ifdef __MP__
   605                              <1> _mapping_locker dq 0
   606                              <1> %endif
   607                              <1> 
   608                              <1> mapping_laddr_to_page:
   609 00000778 51                  <1> 	push rcx 
   610 00000779 4156                <1> 	push r14 
   611 0000077B 9C                  <1> 	pushfq
   612                              <1> 
   613 0000077C FA                  <1> 	cli 
   614                              <1> 
   615                              <1> %ifdef __MP__
   616                              <1> 	SET_SPIN_LOCK r14, qword [rel _mapping_locker]
   617                              <1> %endif
   618                              <1> 
   619 0000077D 50                  <1> 	push rax 
   620 0000077E E81EFFFFFF          <1> 	call find_pte_for_laddr								; 得到页表项的线性地址
   621 00000783 58                  <1> 	pop rax 
   622 00000784 498906              <1> 	mov [r14], rax 										; 在页表项中写入页的物理地址
   623                              <1> 
   624                              <1> %ifdef __MP__
   625                              <1> 	mov qword [rel _mapping_locker], 0
   626                              <1> %endif
   627                              <1> 
   628 00000787 9D                  <1> 	popfq
   629 00000788 415E                <1> 	pop r14 
   630 0000078A 59                  <1> 	pop rcx 
   631                              <1> 
   632 0000078B C3                  <1> 	ret 
   633                              <1> 	
   634                              <1> ; ------------------------------------------------------------
   635                              <1> ; core_memory_allocate
   636                              <1> ; 功能: 在虚拟地址空间的高端（内核）分配内存
   637                              <1> ; 输入: rcx=请求分配的字节数
   638                              <1> ; 输出: r13=本次分配的起始线性地址, r14=下次分配的起始线性地址
   639                              <1> ; ------------------------------------------------------------
   640 0000078C 000020000080FFFF    <1> _core_next_linear dq CORE_ALLOC_START
   641                              <1> 
   642                              <1> %ifdef __MP__
   643                              <1> _core_alloc_locker dq 0
   644                              <1> %endif
   645                              <1> 
   646                              <1> core_memory_allocate:
   647 00000794 9C                  <1> 	pushfq 
   648 00000795 FA                  <1> 	cli 
   649                              <1> %ifdef __MP__
   650                              <1> 	SET_SPIN_LOCK r14, qword [rel _core_alloc_locker]
   651                              <1> %endif
   652 00000796 4C8B2DEFFFFFFF      <1> 	mov r13, [rel _core_next_linear]					; 起始地址
   653 0000079D 4D8D740D00          <1> 	lea r14, [r13 + rcx]								; 下次分配的起始地址
   654                              <1> 
   655 000007A2 49F7C607000000      <1> 	test r14, 0x07 										; 进行 8 字节对齐处理
   656 000007A9 740C                <1> 	jz .algn
   657 000007AB 4983C608            <1> 	add r14, 0x08
   658 000007AF 49C1EE03            <1> 	shr r14, 3
   659 000007B3 49C1E603            <1> 	shl r14, 3											; 最低的 3 个比特变 0
   660                              <1> 
   661                              <1> .algn:
   662 000007B7 4C8935CEFFFFFF      <1> 	mov qword [rel _core_next_linear], r14 				; 写回, 保留, 下一次用
   663                              <1> 
   664                              <1> %ifdef __MP__
   665                              <1> 	mov qword [rel _core_alloc_locker], 0
   666                              <1> %endif
   667                              <1> 
   668 000007BE 9D                  <1> 	popfq
   669                              <1> 
   670 000007BF 4155                <1> 	push r13 
   671 000007C1 4156                <1> 	push r14 
   672                              <1> 
   673                              <1> 	; 以下为请求的内存分配页。R13 为本次分配的线性地址；R14 为下次分配的线性地址
   674 000007C3 49C1ED0C            <1> 	shr r13, 12
   675 000007C7 49C1E50C            <1> 	shl r13, 12											; 清除页内偏移
   676 000007CB 49C1EE0C            <1> 	shr r14, 12
   677 000007CF 49C1E60C            <1> 	shl r14, 12
   678                              <1> .next:
   679 000007D3 E87AFFFFFF          <1> 	call setup_paging_for_laddr							; 安装线性地址所在页
   680 000007D8 4981C500100000      <1> 	add r13, 0x1000
   681 000007DF 4D39F5              <1> 	cmp r13, r14 
   682 000007E2 7EEF                <1> 	jle .next 
   683                              <1> 
   684 000007E4 415E                <1> 	pop r14 
   685 000007E6 415D                <1> 	pop r13 
   686                              <1> 
   687 000007E8 C3                  <1> 	ret 
   688                              <1> 
   689                              <1> ; ------------------------------------------------------------
   690                              <1> ; user_memory_allocate
   691                              <1> ; 功能: 在用户任务的私有空间（低端）分配内存
   692                              <1> ; 输入: r11=任务控制块 PCB 的线性地址, rcx=希望分配的字节数
   693                              <1> ; 输出: r13=本次分配的起始线性地址, r14=下次分配的起始线性地址
   694                              <1> ; ------------------------------------------------------------
   695                              <1> user_memory_allocate:
   696 000007E9 4D8B6B18            <1> 	mov r13, [r11 + 24]								; 获得本次分配的起始线性地址
   697 000007ED 4D8D740D00          <1> 	lea r14, [r13 + rcx]							; 下次分配的起始线性地址
   698                              <1> 
   699 000007F2 49F7C607000000      <1> 	test r14, 0x07									; 是否按 8 字节对齐
   700 000007F9 740C                <1> 	jz .algn
   701 000007FB 49C1EE03            <1> 	shr r14, 3 										; 8 字节向上取整
   702 000007FF 49C1E603            <1> 	shl r14, 3 
   703 00000803 4983C608            <1> 	add r14, 0x08 
   704                              <1> 
   705                              <1> .algn:
   706 00000807 4D897318            <1> 	mov [r11 + 24], r14 							; 写回 PCB 中
   707                              <1> 
   708 0000080B 4155                <1> 	push r13 
   709 0000080D 4156                <1> 	push r14 
   710                              <1> 
   711                              <1> 	; 以下为请求的内存分配页
   712 0000080F 49C1ED0C            <1> 	shr r13, 12										; 清除页内便宜
   713 00000813 49C1E50C            <1> 	shl r13, 12
   714 00000817 49C1EE0C            <1> 	shr r14, 12
   715 0000081B 49C1E60C            <1> 	shl r14, 12
   716                              <1> 
   717                              <1> .next:
   718 0000081F E82EFFFFFF          <1> 	call setup_paging_for_laddr						; 为当前线性地址安装页
   719 00000824 4981C500100000      <1> 	add r13, 0x1000
   720 0000082B 4D39F5              <1> 	cmp r13, r14 
   721 0000082E 7EEF                <1> 	jle .next
   722                              <1> 
   723 00000830 415E                <1> 	pop r14
   724 00000832 415D                <1> 	pop r13 
   725                              <1> 
   726 00000834 C3                  <1> 	ret 
   727                              <1> 
   728                              <1> ; ------------------------------------------------------------
   729                              <1> ; copy_current_pml4
   730                              <1> ; 功能: 创建新的 4 级头表，并复制当前 4 级头表的内容
   731                              <1> ; 输出: rax=新 4 级头表的物理地址及属性
   732                              <1> ; ------------------------------------------------------------
   733                              <1> %ifdef __MP__
   734                              <1> _copy_locker dq 0
   735                              <1> %endif
   736                              <1> 
   737                              <1> copy_current_pml4:
   738 00000835 56                  <1> 	push rsi 
   739 00000836 57                  <1> 	push rdi 
   740 00000837 4155                <1> 	push r13 
   741 00000839 51                  <1> 	push rcx 
   742 0000083A 9C                  <1> 	pushfq
   743                              <1> 
   744 0000083B FA                  <1> 	cli 
   745                              <1> 
   746                              <1> %ifdef __MP__
   747                              <1> 	SET_SPIN_LOCK rcx, qword [rel _copy_locker]
   748                              <1> %endif
   749                              <1> 
   750 0000083C E8BFFDFFFF          <1> 	call allocate_a_4k_page						; 分配一个物理页
   751 00000841 4883C807            <1> 	or rax, 0x07 								; 添加属性
   752 00000845 49BD00F0FFFF7FFFFF- <1> 	mov r13, NEW_PML4_LINEAR					; 用指定的线性地址映射和访问刚分配的这个物理页
   752 0000084E FF                  <1>
   753 0000084F E824FFFFFF          <1> 	call mapping_laddr_to_page
   754                              <1> 
   755                              <1> 	; 目标表项在页部件的转换速查缓冲器 TLB 的缓存, 需要用 invlpg 执行刷新
   756 00000854 410F017D00          <1> 	invlpg [r13]
   757                              <1> 
   758 00000859 48C7C600F0FFFF      <1> 	mov rsi, 0xffff_ffff_ffff_f000				; rsi -> 当前活动4级头表的线性地址(还是利用递归映射)
   759 00000860 4C89EF              <1> 	mov rdi, r13 								; rdi -> 新 4 级头表的线性地址
   760 00000863 B900020000          <1> 	mov rcx, 512								; rcx -> 要复制的目录项数
   761 00000868 FC                  <1> 	cld 										; 将 RFLAGS 中的方向标志位（DF）设置为 0, 即地址自动递增
   762 00000869 F348A5              <1> 	repe movsq
   763                              <1> 
   764 0000086C 498985F80F0000      <1> 	mov [r13 + 0xff8], rax 						; 0xff8 = 512 * 8, 新 4 级头表的 511 号表项指向它自己, 方便递归映射 
   765 00000873 410F01BDF80F0000    <1> 	invlpg [r13 + 0xff8]
   766                              <1> 
   767                              <1> %ifdef __MP__
   768                              <1> 	mov qword [rel _copy_locker], 0
   769                              <1> %endif
   770                              <1> 
   771 0000087B 9D                  <1> 	popfq
   772 0000087C 59                  <1> 	pop rcx 
   773 0000087D 415D                <1> 	pop r13
   774 0000087F 5F                  <1> 	pop rdi 
   775 00000880 5E                  <1> 	pop rsi 
   776                              <1> 
   777 00000881 C3                  <1> 	ret 
   778                              <1> 
   779                              <1> ; ------------------------------------------------------------
   780                              <1> ; get_cmos_time
   781                              <1> ; 功能: 从 CMOS 中获取当前时间, 详情见书中 225 页
   782                              <1> ; 输入: rbx=缓冲区线性地址
   783                              <1> ; ------------------------------------------------------------
   784                              <1> %ifdef __MP__
   785                              <1> _cmos_locker dq 0
   786                              <1> %endif
   787                              <1> 
   788                              <1> get_cmos_time:
   789 00000882 50                  <1> 	push rax 
   790 00000883 9C                  <1> 	pushfq
   791 00000884 FA                  <1> 	cli 
   792                              <1> 
   793                              <1> %ifdef __MP__
   794                              <1> 	SET_SPIN_LOCK rax, qword [rel _cmos_locker]
   795                              <1> %endif
   796                              <1> 
   797                              <1> .w0:
   798 00000885 B08A                <1> 	mov al, 0x8a 
   799 00000887 E670                <1> 	out 0x70, al 
   800 00000889 E471                <1> 	in al, 0x71 								; 读寄存器 A
   801 0000088B A880                <1> 	test al, 0x80 								; 测试第 7 位 UIP, 等待更新周期结束
   802 0000088D 75F6                <1> 	jnz .w0 
   803                              <1> 
   804 0000088F B084                <1> 	mov al, 0x84 
   805 00000891 E670                <1> 	out 0x70, al 
   806 00000893 E471                <1> 	in al, 0x71 								; 读RTC当前时间(时)
   807 00000895 88C4                <1> 	mov ah, al 									; BCD 编码, 用两个寄存器处理
   808                              <1> 
   809 00000897 C0EC04              <1> 	shr ah, 4									; 处理高四位						
   810 0000089A 80E40F              <1> 	and ah, 0x0f 
   811 0000089D 80C430              <1> 	add ah, 0x30 								; 转换成 ASCII
   812 000008A0 8823                <1> 	mov [rbx], ah 
   813                              <1> 
   814 000008A2 240F                <1> 	and al, 0x0f 								; 处理低四位
   815 000008A4 0430                <1> 	add al, 0x30 
   816 000008A6 884301              <1> 	mov [rbx + 1], al 
   817                              <1> 
   818 000008A9 C643023A            <1> 	mov byte [rbx + 2], ":"
   819                              <1> 
   820 000008AD B082                <1> 	mov al, 0x82 
   821 000008AF E670                <1> 	out 0x70, al 
   822 000008B1 E471                <1> 	in al, 0x71									; 读RTC当前时间(分)
   823 000008B3 88C4                <1> 	mov ah, al 
   824                              <1> 
   825 000008B5 C0EC04              <1> 	shr ah, 4			
   826 000008B8 80E40F              <1> 	and ah, 0x0f 
   827 000008BB 80C430              <1> 	add ah, 0x30 
   828 000008BE 886303              <1> 	mov [rbx + 3], ah 
   829                              <1> 
   830 000008C1 240F                <1> 	and al, 0x0f 
   831 000008C3 0430                <1> 	add al, 0x30 
   832 000008C5 884304              <1> 	mov [rbx + 4], al 
   833                              <1> 
   834 000008C8 C643053A            <1> 	mov byte [rbx + 5], ":"
   835                              <1> 
   836 000008CC B080                <1> 	mov al, 0x80 
   837 000008CE E670                <1> 	out 0x70, al 
   838 000008D0 E471                <1> 	in al, 0x71									; 读RTC当前时间(秒)
   839 000008D2 88C4                <1> 	mov ah, al 
   840                              <1> 
   841 000008D4 C0EC04              <1> 	shr ah, 4
   842 000008D7 80E40F              <1> 	and ah, 0x0f 
   843 000008DA 80C430              <1> 	add ah, 0x30
   844 000008DD 886306              <1> 	mov [rbx + 6], ah 
   845                              <1> 
   846 000008E0 240F                <1> 	and al, 0x0f 
   847 000008E2 0430                <1> 	add al, 0x30 
   848 000008E4 884307              <1> 	mov [rbx + 7], al 
   849                              <1> 
   850 000008E7 C6430800            <1> 	mov byte [rbx + 8], 0						; 终止字符
   851                              <1> 
   852                              <1> %ifdef __MP__
   853                              <1> 	mov qword [rel _cmos_locker], 0
   854                              <1> %endif
   855                              <1> 
   856 000008EB 9D                  <1> 	popfq
   857 000008EC 58                  <1> 	pop rax 
   858                              <1> 
   859 000008ED C3                  <1> 	ret 
   860                              <1> 
   861                              <1> ; ------------------------------------------------------------
   862                              <1> ; generate_process_id
   863                              <1> ; 功能: 生成唯一的进程标识
   864                              <1> ; 输出: rax=进程标识
   865                              <1> ; ------------------------------------------------------------
   866 000008EE 0000000000000000    <1> _process_id dq 0
   867                              <1> 
   868                              <1> generate_process_id:
   869 000008F6 B801000000          <1> 	mov rax, 1
   870 000008FB F0480FC105EAFFFFFF  <1> 	lock xadd qword [rel _process_id], rax 		; lock 前缀确保这条指令是原子操作, xadd 是 "交换并相加" 指令, 会将源操作数和目的操作数相加，结果存入目的操作数，同时将目的操作数的原始值存入源操作数
   871                              <1> 	
   872 00000904 C3                  <1> 	ret 
   873                              <1> 
   874                              <1> ; ------------------------------------------------------------
   875                              <1> ; generate_thread_id
   876                              <1> ; 功能: 生成唯一的线程标识
   877                              <1> ; 输出: rax=线程标识
   878                              <1> ; ------------------------------------------------------------
   879 00000905 0000000000000000    <1> _thread_id dq 0
   880                              <1> 
   881                              <1> generate_thread_id:
   882 0000090D B801000000          <1> 	mov rax, 1
   883 00000912 F0480FC105EAFFFFFF  <1> 	lock xadd qword [rel _thread_id], rax 		; lock 前缀确保这条指令是原子操作, xadd 是 "交换并相加" 指令, 会将源操作数和目的操作数相加，结果存入目的操作数，同时将目的操作数的原始值存入源操作数
   884                              <1> 	
   885 0000091B C3                  <1> 	ret 
   886                              <1> 
   887                              <1> ; ------------------------------------------------------------
   888                              <1> ; get_screen_row
   889                              <1> ; 功能: 返回下一个屏幕坐标行的行号
   890                              <1> ; 输出: dh=行号
   891                              <1> ; ------------------------------------------------------------
   892 0000091C 08                  <1> _screen_row db 8 								; 前边已经显示了 7 行, 所以从 8 开始
   893                              <1> 
   894                              <1> get_screen_row:
   895 0000091D B601                <1> 	mov dh, 1
   896 0000091F F00FC035F5FFFFFF    <1> 	lock xadd byte [rel _screen_row], dh 
   897                              <1> 
   898 00000927 C3                  <1> 	ret 
   899                              <1> 
   900                              <1> ; ------------------------------------------------------------
   901                              <1> ; get_cpu_number
   902                              <1> ; 功能: 返回当前处理器的编号
   903                              <1> ; 输出: rax=处理器编号
   904                              <1> ; ------------------------------------------------------------
   905                              <1> get_cpu_number:
   906 00000928 9C                  <1> 	pushfq
   907 00000929 FA                  <1> 	cli 
   908 0000092A 0F01F8              <1> 	swapgs
   909 0000092D 65488B042510000000  <1> 	mov rax, [gs:16]							; 在专属数据区取
   910 00000936 0F01F8              <1> 	swapgs
   911 00000939 9D                  <1> 	popfq
   912 0000093A C3                  <1> 	ret 
   913                              <1> 
   914                              <1> ; ------------------------------------------------------------
   915                              <1> ; memory_allocate
   916                              <1> ; 功能: 用户空间的内存分配
   917                              <1> ; 输入: rdx=期望分配的字节数
   918                              <1> ; 输出: r13=所分配内存的起始线性地址
   919                              <1> ; ------------------------------------------------------------
   920                              <1> memory_allocate:
   921 0000093B 51                  <1> 	push rcx 
   922 0000093C 4153                <1> 	push r11 
   923 0000093E 4156                <1> 	push r14 
   924                              <1> 
   925 00000940 9C                  <1> 	pushfq
   926 00000941 FA                  <1> 	cli 
   927 00000942 0F01F8              <1> 	swapgs
   928 00000945 654C8B1C2508000000  <1> 	mov r11, [gs:8]								; PCB 线性地址
   929 0000094E 0F01F8              <1> 	swapgs
   930 00000951 9D                  <1> 	popfq
   931                              <1> 
   932 00000952 4889D1              <1> 	mov rcx, rdx 
   933 00000955 E88FFEFFFF          <1> 	call user_memory_allocate
   934                              <1> 
   935 0000095A 415E                <1> 	pop r14 
   936 0000095C 415B                <1> 	pop r11 
   937 0000095E 59                  <1> 	pop rcx 
   938                              <1> 
   939 0000095F C3                  <1> 	ret 
    52                                  %include "./common/user_static64.asm"
     1                              <1> ; 用户通用代码
     2                              <1> 
     3                              <1>     bits 64 
     4                              <1> 
     5                              <1> ; ------------------------------------------------------------
     6                              <1> ; bin64_to_dec
     7                              <1> ; 功能: 将二进制数转换为十进制字符串
     8                              <1> ; 输入: r8=64位二进制数, rbx=目标缓冲区线性地址
     9                              <1> ; ------------------------------------------------------------
    10                              <1> bin64_to_dec: 
    11 00000960 50                  <1>     push rax
    12 00000961 53                  <1>     push rbx
    13 00000962 51                  <1>     push rcx
    14 00000963 52                  <1>     push rdx
    15 00000964 4150                <1>     push r8
    16                              <1> 
    17 00000966 490FBAE03F          <1>     bt r8, 63                                       ; 检查最高位, 处理正,负数
    18 0000096B 7309                <1>     jnc .begin
    19 0000096D C6032D              <1>     mov byte [rbx], "-"
    20 00000970 49F7D8              <1>     neg r8                                          ; 取反, 将负数转为正数
    21                              <1> 
    22 00000973 48FFC3              <1>     inc rbx
    23                              <1> 
    24                              <1> .begin:
    25 00000976 4C89C0              <1>     mov rax, r8                                     ; rax 是被除数
    26 00000979 41B80A000000        <1>     mov r8, 10
    27 0000097F 4831C9              <1>     xor rcx, rcx                                    ; rcx 是位数
    28                              <1> 
    29                              <1> .next_div:
    30 00000982 4831D2              <1>     xor rdx, rdx                                    ; 使用 128 位除法, 要将 rdx 清零
    31 00000985 49F7F0              <1>     div r8 
    32 00000988 52                  <1>     push rdx                                        ; 保存分解的数位
    33 00000989 48FFC1              <1>     inc rcx 
    34 0000098C 4809C0              <1>     or rax, rax                                     ; 商为 0?
    35 0000098F 7402                <1>     jz .rotate
    36 00000991 EBEF                <1>     jmp .next_div
    37                              <1> 
    38                              <1> .rotate:
    39 00000993 5A                  <1>     pop rdx 
    40 00000994 80C230              <1>     add dl, 0x30                                    ; 将数位转为 ASCII
    41 00000997 8813                <1>     mov [rbx], dl 
    42 00000999 48FFC3              <1>     inc rbx 
    43 0000099C E2F5                <1>     loop .rotate
    44                              <1> 
    45 0000099E C60300              <1>     mov byte [rbx], 0
    46                              <1> 
    47 000009A1 4158                <1>     pop r8
    48 000009A3 5A                  <1>     pop rdx
    49 000009A4 59                  <1>     pop rcx
    50 000009A5 5B                  <1>     pop rbx
    51 000009A6 58                  <1>     pop rax
    52                              <1> 
    53 000009A7 C3                  <1>     ret 
    54                              <1> 
    55                              <1> ; ------------------------------------------------------------
    56                              <1> ; string_concatenates
    57                              <1> ; 功能: 将源字符串连接到目的字符串的尾部
    58                              <1> ; 输入: rsi=源字符串的线性地址, rdi=目的字符串的线性地址
    59                              <1> ; ------------------------------------------------------------
    60                              <1> string_concatenates:
    61 000009A8 50                  <1>     push rax
    62 000009A9 56                  <1>     push rsi
    63 000009AA 57                  <1>     push rdi
    64                              <1> 
    65                              <1>     
    66                              <1> .r0:                                                ; 先找到 rdi 的结尾
    67 000009AB 803F00              <1>     cmp byte [rdi], 0
    68 000009AE 7405                <1>     jz .r1 
    69 000009B0 48FFC7              <1>     inc rdi 
    70 000009B3 EBF6                <1>     jmp .r0 
    71                              <1>     
    72                              <1> .r1:                                                ; 再复制源字符串过去
    73 000009B5 8A06                <1>     mov al, [rsi]
    74 000009B7 8807                <1>     mov [rdi], al 
    75 000009B9 3C00                <1>     cmp al, 0
    76 000009BB 7408                <1>     jz .r2 
    77 000009BD 48FFC6              <1>     inc rsi 
    78 000009C0 48FFC7              <1>     inc rdi 
    79 000009C3 EBF0                <1>     jmp .r1 
    80                              <1>     
    81                              <1> .r2:
    82 000009C5 5F                  <1>     pop rdi 
    83 000009C6 5E                  <1>     pop rsi 
    84 000009C7 58                  <1>     pop rax 
    85                              <1> 
    86 000009C8 C3                  <1>     ret 
    53                                  
    54                                      [bits 64]
    55                                  
    56                                  ; ------------------------------------------------------------
    57                                  ; ap_to_core_entry
    58                                  ; 功能: 应用处理器（AP）进入内核的入口点
    59                                  ; ------------------------------------------------------------
    60 000009C9 F900                    _ap_string      db 249, 0
    61                                  
    62                                  ap_to_core_entry:
    63                                      ; 启用 GDT 的高端线性地址并加载 IDTR
    64 000009CB 48B8007E00000080FF-         mov rax, UPPER_SDA_LINEAR
    64 000009D4 FF                 
    65 000009D5 0F015002                    lgdt [rax + 2]                                  ; 只有 64 位模式下才能加载 64 位线性地址
    66 000009D9 0F01580C                    lidt [rax + 0x0c]
    67                                  
    68                                      ; 为当前处理器创建 64 位 模式下专属栈
    69 000009DD B900100000                  mov rcx, 4096
    70 000009E2 E8ADFDFFFF                  call core_memory_allocate
    71 000009E7 4C89F4                      mov rsp, r14 
    72                                  
    73                                      ; 创建当前处理器的专属存储区(格式见书中 348 页)
    74 000009EA B900010000                  mov rcx, 256                                    ; 专属数据区长度, 含 TSS
    75 000009EF E8A0FDFFFF                  call core_memory_allocate
    76 000009F4 498D8580000000              lea rax, [r13 + 128]                            ; TSS 开始于专属存储区偏移为 128 的地方
    77 000009FB E845F7FFFF                  call make_tss_descriptor
    78                                  
    79 00000A00 49BF007E00000080FF-         mov r15, UPPER_SDA_LINEAR
    79 00000A09 FF                 
    80                                  
    81                                      ; 安装 TSS 描述符到 GDT
    82 00000A0A 4D8B4704                    mov r8, [r15 + 4]                               ; r8=gdt 的线性地址
    83 00000A0E 490FB74F02                  movzx rcx, word [r15 + 2]                       ; rcx=gdt 的界限值
    84 00000A13 4989740801                  mov [r8 + rcx + 1], rsi                         ; TSS 描述符的低 64 位
    85 00000A18 49897C0809                  mov [r8 + rcx + 9], rdi                         ; TSS 描述符的高 64 位
    86                                  
    87 00000A1D 664183470210                add word [r15 + 2], 16                          ; TSS 大小
    88 00000A23 410F015702                  lgdt [r15 + 2]                                  ; 重新加载 GDTR
    89                                  
    90 00000A28 66C1E903                    shr cx, 3                                       ; 除 8 得到索引
    91 00000A2C 66FFC1                      inc cx                                          ; 找到 TSS 描述符
    92 00000A2F 66C1E103                    shl cx, 3                                       ; 乘 8 得到正确偏移
    93                                  
    94 00000A33 0F00D9                      ltr cx                                          ; 为当前任务加载任务寄存器 TR
    95                                  
    96                                      ; 将处理器专属数据区首地址保存到当前处理器的型号专属寄存器 IA32_KERNEL_GS_BASE
    97 00000A36 B9020100C0                  mov ecx, 0xc000_0102                            ; IA32_KERNEL_GS_BASE
    98 00000A3B 4C89E8                      mov rax, r13                                    ; 只用 EAX
    99 00000A3E 4C89EA                      mov rdx, r13 
   100 00000A41 48C1EA20                    shr rdx, 32 
   101 00000A45 0F30                        wrmsr 
   102                                  
   103                                      ; 为快速系统调用 SYSCALL 和 SYSRET 准备参数
   104 00000A47 B9800000C0                  mov ecx, 0x0c0000080                            ; 指定型号专属寄存器 IA32_EFER
   105 00000A4C 0F32                        rdmsr 
   106 00000A4E 0FBAE800                    bts eax, 0                                      ; 设置 SCE 位，允许 SYSCALL 指令
   107 00000A52 0F30                        wrmsr
   108                                  
   109 00000A54 B9810000C0                  mov ecx, 0xc0000081                             ; STAR
   110 00000A59 BA18002B00                  mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL
   111 00000A5E 31C0                        xor eax, eax 
   112 00000A60 0F30                        wrmsr
   113                                  
   114 00000A62 B9820000C0                  mov ecx, 0xc0000082                             ; LSTAR
   115 00000A67 488B05(08000000)            mov rax, [rel position]
   116 00000A6E 488D80[C0160000]            lea rax, [rax + syscall_procedure]              ; 只用 EAX 部分
   117 00000A75 4889C2                      mov rdx, rax
   118 00000A78 48C1EA20                    shr rdx, 32                                     ; 使用 EDX 部分
   119 00000A7C 0F30                        wrmsr
   120                                  
   121 00000A7E B9840000C0                  mov ecx, 0xc0000084                             ; FMASK
   122 00000A83 31D2                        xor edx, edx
   123 00000A85 B800770400                  mov eax, 0x00047700                             ; 要求 TF=IF=DF=AC=0, IOPL=00
   124 00000A8A 0F30                        wrmsr
   125                                  
   126 00000A8C 4C8B3D(08000000)            mov r15, [rel position]
   127 00000A93 498D9F[C9090000]            lea rbx, [r15 + _ap_string]
   128 00000A9A E861F5FFFF                  call put_string64
   129                                  
   130 00000A9F 0F01F8                      swapgs                                          ; 准备用 GS 操作当前处理器的专属数据, IA32_KERNEL_GS_BASE 与 GS 互换内容
   131 00000AA2 6548C7042508000000-         mov qword [gs:8], 0                             ; PCB 的线性地址 = 0, 没有正在执行的任务
   131 00000AAB 00000000           
   132 00000AAF 4831C0                      xor rax, rax 
   133 00000AB2 8A05(31010000)              mov al, byte [rel ack_cpus]
   134 00000AB8 654889042510000000          mov [gs:16], rax                                ; 设置处理器编号
   135 00000AC1 654889242518000000          mov [gs:24], rsp                                ; 保存当前处理器的固有栈指针
   136 00000ACA 0F01F8                      swapgs
   137                                  
   138 00000ACD FE05(31010000)              inc byte [rel ack_cpus]                         ; 递增应答计数值
   139                                  
   140 00000AD3 C60425[82F00000]00          mov byte [AP_START_UP_ADDR + lock_var], 0       ; 释放自旋锁
   141                                  
   142 00000ADB 48BE00E0FFFF7FFFFF-         mov rsi, LAPIC_START_ADDR                       ; Local APIC 的线性地址
   142 00000AE4 FF                 
   143 00000AE5 0FBAAEF000000008            bts dword [rsi + 0xf0], 8                       ; 设置 SVR 寄存器, 允许 LAPIC
   144                                  
   145 00000AED FB                          sti                                             ; 开放中断
   146                                  
   147                                  .do_idle:
   148 00000AEE F4                          hlt 
   149 00000AEF EBFD                        jmp .do_idle
   150                                  
   151                                  ; ------------------------------------------------------------
   152                                  ; general_interrupt_handler
   153                                  ; 功能: 通用中断处理
   154                                  ; ------------------------------------------------------------
   155                                  general_interrupt_handler:
   156 00000AF1 48CF                        iretq
   157                                  
   158                                  ; ------------------------------------------------------------
   159                                  ; general_exception_handler
   160                                  ; 功能: 通用异常处理
   161                                  ; ------------------------------------------------------------
   162                                  general_exception_handler:
   163 00000AF3 4C8B3D(08000000)            mov r15, [rel position]                         ; 在 24 行 0 列显示红底白字的错误信息
   164 00000AFA 498D9F[0F0B0000]            lea rbx, [r15 + exceptm]
   165 00000B01 B618                        mov dh, 24
   166 00000B03 B200                        mov dl, 0
   167 00000B05 41B14F                      mov r9b, 0x4f 
   168 00000B08 E8D1F5FFFF                  call put_cstringxy64                            ; 在 core_utils64.asm 中实现
   169                                  
   170 00000B0D FA                          cli 
   171 00000B0E F4                          hlt                                             ; 停机且不接受外部硬件中断
   172                                  
   173 00000B0F 412065786365707469-     exceptm         db "A exception raised, halt.", 0   ; 发生异常时的错误信息
   173 00000B18 6F6E20726169736564-
   173 00000B21 2C2068616C742E00   
   174                                  
   175                                  ; ------------------------------------------------------------
   176                                  ; handle_waiting_thread
   177                                  ; 功能: 处理等待其它线程的线程
   178                                  ; 输入: r11=线程控制块 TCB 的线性地址
   179                                  ; ------------------------------------------------------------
   180                                  handle_waiting_thread:
   181 00000B29 53                          push rbx 
   182 00000B2A 52                          push rdx 
   183 00000B2B 4153                        push r11 
   184                                  
   185 00000B2D 4C89DB                      mov rbx, r11 
   186                                  
   187 00000B30 498B5338                    mov rdx, [r11 + 56]                             ; 被等待的线程的标识
   188 00000B34 E858040000                  call search_for_thread_id
   189 00000B39 4D09DB                      or r11, r11                                     ; 线程已经被清理了吗?
   190 00000B3C 7407                        jz .set_th 
   191 00000B3E 49837B1002                  cmp qword [r11 + 16], 2                         ; 线程是终止状态吗?
   192 00000B43 7528                        jne .return                                     ; 不是。返回（继续等待）
   193                                  
   194                                  .set_th:
   195 00000B45 48C7431000000000            mov qword [rbx + 16], 0                         ; 将线程设置为就绪状态
   196                                  
   197 00000B4D 49BB00E0FFFF7FFFFF-         mov r11, LAPIC_START_ADDR          
   197 00000B56 FF                 
   198 00000B57 41C783100300000000-         mov dword [r11 + 0x310], 0
   198 00000B60 0000               
   199 00000B62 41C78300030000FE40-         mov dword [r11 + 0x300], 0x000840fe             ; 向所有处理器发送线程认领中断
   199 00000B6B 0800               
   200                                  
   201                                  .return:
   202 00000B6D 415B                        pop r11
   203 00000B6F 5A                          pop rdx
   204 00000B70 5B                          pop rbx
   205                                  
   206 00000B71 C3                          ret
   207                                  
   208                                  ; ------------------------------------------------------------
   209                                  ; handle_waiting_sleep
   210                                  ; 功能: 处理等待标志的线程
   211                                  ; 输入: r11=线程控制块 TCB 的线性地址
   212                                  ; ------------------------------------------------------------
   213                                  handle_waiting_flag:
   214 00000B72 50                          push rax
   215 00000B73 53                          push rbx
   216 00000B74 51                          push rcx
   217                                  
   218 00000B75 B800000000                  mov rax, 0
   219 00000B7A 498B5B38                    mov rbx, [r11 + 56]                             ; 被等待的标志的线性地址
   220 00000B7E B901000000                  mov rcx, 1
   221 00000B83 F0480FB10B                  lock cmpxchg [rbx], rcx 
   222 00000B88 7528                        jnz .return
   223                                  
   224 00000B8A 49C7431000000000            mov qword [r11 + 16], 0                         ; 将线程设置为就绪状态
   225                                  
   226 00000B92 49BB00E0FFFF7FFFFF-         mov r11, LAPIC_START_ADDR          
   226 00000B9B FF                 
   227 00000B9C 41C783100300000000-         mov dword [r11 + 0x310], 0
   227 00000BA5 0000               
   228 00000BA7 41C78300030000FE40-         mov dword [r11 + 0x300], 0x000840fe             ; 向所有处理器发送线程认领中断
   228 00000BB0 0800               
   229                                  
   230                                  .return:
   231 00000BB2 59                          pop rcx
   232 00000BB3 5B                          pop rbx
   233 00000BB4 58                          pop rax
   234                                  
   235 00000BB5 C3                          ret
   236                                  
   237                                  ; ------------------------------------------------------------
   238                                  ; handle_waiting_sleep
   239                                  ; 功能: 处理睡眠中的线程
   240                                  ; 输入: r11=线程控制块 TCB 的线性地址
   241                                  ; ------------------------------------------------------------
   242                                  handle_waiting_sleep:
   243 00000BB6 50                          push rax 
   244                                  
   245 00000BB7 49FF4B38                    dec qword [r11 + 56]                            ; 休眠时间数 - 1
   246 00000BBB 49837B3800                  cmp qword [r11 + 56], 0
   247 00000BC0 7528                        jnz .return
   248                                  
   249 00000BC2 49C7431000000000            mov qword [r11 + 16], 0                         ; 设置线程状态为就绪
   250                                  
   251 00000BCA 48B800E0FFFF7FFFFF-         mov rax, LAPIC_START_ADDR
   251 00000BD3 FF                 
   252 00000BD4 48C780100300000000-         mov qword [rax + 0x310], 0                      ; 向所有处理器发送线程认领中断
   252 00000BDD 0000               
   253 00000BDF 48C78000030000FE40-         mov qword [rax + 0x300], 0x000840fe
   253 00000BE8 0800               
   254                                  
   255                                  .return:
   256 00000BEA 58                          pop rax 
   257                                  
   258 00000BEB C3                          ret 
   259                                  
   260                                  ; ------------------------------------------------------------
   261                                  ; system_management_handler
   262                                  ; 功能: 系统管理中断的处理过程
   263                                  ; ------------------------------------------------------------
   264                                  system_management_handler:
   265 00000BEC 53                          push rbx 
   266 00000BED 4153                        push r11 
   267                                  
   268 00000BEF 488B1D(E9020000)            mov rbx, [rel pcb_ptr]                          ; pcb 链表首地址
   269 00000BF6 4809DB                      or rbx, rbx 
   270 00000BF9 7453                        jz .return                                      ; 不存在任务
   271                                  .nextp:
   272 00000BFB 4C8B9B10010000              mov r11, [rbx + 272]
   273 00000C02 4D09DB                      or r11, r11 
   274 00000C05 7447                        jz .return                                      ; 线程未创建
   275                                  .nextt:
   276 00000C07 49837B1003                  cmp qword [r11 + 16], 3                         ; 正在休眠并等待其他线程?
   277 00000C0C 7507                        jne .next0                                      ; 不是, 转去 .next0 处理此 TCB
   278 00000C0E E816FFFFFF                  call handle_waiting_thread                      ; 处理等待其它线程终止的线程并决定其是否唤醒
   279 00000C13 EB1C                        jmp .gnext 
   280                                  
   281                                      ; switch-case
   282                                  .next0:
   283                                      ; 处理等待某个信号的线程并决定其是否唤醒
   284 00000C15 49837B1005                  cmp qword [r11 + 16], 5
   285 00000C1A 7507                        jne .next1 
   286 00000C1C E851FFFFFF                  call handle_waiting_flag 
   287 00000C21 EB0E                        jmp .gnext
   288                                  .next1:
   289                                      ; 处理休眠的线程并决定其是否唤醒
   290 00000C23 49837B1004                  cmp qword [r11 + 16], 4
   291 00000C28 7507                        jne .next2
   292 00000C2A E887FFFFFF                  call handle_waiting_sleep
   293 00000C2F EB00                        jmp .gnext
   294                                  .next2:
   295                                  .gnext:
   296 00000C31 4D8B9B18010000              mov r11, [r11 + 280]                            ; 下一个 TCB 节点
   297 00000C38 4983FB00                    cmp r11, 0                                      ; 到达 TCB 链表尾部?
   298 00000C3C 75C9                        jne .nextt                                      ; 否, 继续遍历 TCB
   299 00000C3E 488B9B18010000              mov rbx, [rbx + 280]                            ; 下一个 PCB 节点
   300 00000C45 483B1D(E9020000)            cmp rbx, [rel pcb_ptr]                          ; 转一圈回到 PCB 首节点?
   301 00000C4C 75AD                        jne .nextp                                      ; 否, 处理下一个 PCB
   302                                  
   303                                  .return:
   304 00000C4E 49BB00E0FFFF7FFFFF-         mov r11, LAPIC_START_ADDR                       ; 给 Local APIC 发送中断结束命令 EOI
   304 00000C57 FF                 
   305 00000C58 41C783B00000000000-         mov dword [r11 + 0xb0], 0
   305 00000C61 0000               
   306                                  
   307 00000C63 48BB00800B000080FF-         mov rbx, UPPER_TEXT_VIDEO
   307 00000C6C FF                 
   308 00000C6D F613                        not byte [rbx]
   309                                  
   310 00000C6F 415B                        pop r11 
   311 00000C71 5B                          pop rbx 
   312                                  
   313 00000C72 48CF                        iretq
   314                                  
   315                                  ; ------------------------------------------------------------
   316                                  ; search_for_a_ready_thread
   317                                  ; 功能: 查找一个就绪的线程并将其置为忙, 本程序在中断处理过程内调用，默认中断是关闭状态。
   318                                  ; 输出: r11=就绪线程所属任务的 PCB 线性地址, r12=就绪线程的 TCB 线性地址
   319                                  ; ------------------------------------------------------------
   320                                  search_for_a_ready_thread:
   321 00000C74 50                          push rax 
   322 00000C75 53                          push rbx 
   323 00000C76 51                          push rcx 
   324                                  
   325 00000C77 B901000000                  mov rcx, 1                                      ; rcx=任务的“忙”状态
   326                                  
   327 00000C7C 0F01F8                      swapgs 
   328 00000C7F 65488B1C2508000000          mov rbx, [gs:8]                                 ; 取得当前任务的 PCB 线性地址
   329 00000C88 654C8B242520000000          mov r12, [gs:32]                                ; 取得当前线程的 TCB 地址
   330 00000C91 0F01F8                      swapgs
   331 00000C94 4989DB                      mov r11, rbx 
   332 00000C97 4883FB00                    cmp rbx, 0                                      ; 专属数据区存的 PCB 线性地址为 0, 也就是刚初始化
   333 00000C9B 7511                        jne .nextt
   334 00000C9D 488B1D(E9020000)            mov rbx, [rel pcb_ptr]                          ; 那就从链表头部开始找
   335 00000CA4 4989DB                      mov r11, rbx 
   336 00000CA7 4D8BA310010000              mov r12, [r11 + 272]                            ; 从 PCB 的第一个 TCB 开始
   337                                  
   338                                  .nextt:                                             ; 这一部分遍历 TCB 链表
   339 00000CAE 4983FC00                    cmp r12, 0                                      ; 位于 TCB 链表的末尾?
   340 00000CB2 7416                        je .nextp                                       ; 切换下一个 PCB
   341 00000CB4 4831C0                      xor rax, rax 
   342 00000CB7 F0490FB14C2410              lock cmpxchg [r12 + 16], rcx 
   343 00000CBE 7425                        jz .return
   344 00000CC0 4D8BA42418010000            mov r12, [r12 + 280]                            ; 获取下个 TCB
   345 00000CC8 EBE4                        jmp .nextt
   346                                  
   347                                  .nextp:                                             ; 这一部分遍历 PCB 链表
   348 00000CCA 4D8B9B18010000              mov r11, [r11 + 280]
   349 00000CD1 4939DB                      cmp r11, rbx                                    ; 是否转一圈回到当前节点?
   350 00000CD4 7409                        je .fmiss                                       ; 是, 未找到就绪任务
   351 00000CD6 4D8BA310010000              mov r12, [r11 + 272]                            ; 不是, 从新的 PCB 中提取 TCB 节点
   352 00000CDD EBCF                        jmp .nextt
   353                                  
   354                                  .fmiss:
   355 00000CDF 4D31DB                      xor r11, r11 
   356 00000CE2 4D31E4                      xor r12, r12 
   357                                  
   358                                  .return:
   359 00000CE5 59                          pop rcx 
   360 00000CE6 5B                          pop rbx 
   361 00000CE7 58                          pop rax 
   362                                  
   363 00000CE8 C3                          ret 
   364                                  
   365                                  ; ------------------------------------------------------------
   366                                  ; resume_execute_a_thread
   367                                  ; 功能: 恢复执行一个线程, 本程序在中断处理过程内调用，默认中断是关闭状态。
   368                                  ; 输入: r11=线程所属的任务的 PCB 线性地址, r12=线程的 TCB 线性地址
   369                                  ; ------------------------------------------------------------
   370                                  resume_execute_a_thread:
   371 00000CE9 8B05(32010000)              mov eax, [rel clocks_1ms]                       ; 以下计算新任务运行时间
   372 00000CEF 418B9C24F0000000            mov ebx, [r12 + 240]                            ; 线程指定的时间片
   373 00000CF7 F7E3                        mul ebx 
   374                                  
   375 00000CF9 48BE00E0FFFF7FFFFF-         mov rsi, LAPIC_START_ADDR
   375 00000D02 FF                 
   376 00000D03 C786E00300000B0000-         mov dword [rsi + 0x3e0], 0x0b                   ; 1 分频
   376 00000D0C 00                 
   377 00000D0D C78620030000FD0000-         mov dword [rsi + 0x320], 0xfd                   ; 单次击发模式, Fixed, 中断信号 0xfd, 详情见书中 276 页
   377 00000D16 00                 
   378                                  
   379 00000D17 498B5B38                    mov rbx, [r11 + 56]
   380 00000D1B 0F22DB                      mov cr3, rbx                                    ; 切换地址空间
   381                                  
   382 00000D1E 0F01F8                      swapgs
   383 00000D21 654C891C2508000000          mov [gs:8], r11                                 ; 将新线程所属的任务设置为当前任务
   384 00000D2A 654C89242520000000          mov [gs:32], r12                                ; 将新线程设置为当前线程
   385 00000D33 498B5C2420                  mov rbx, [r12 + 32]                             ; 取 TCB 中的 RSP0
   386 00000D38 6548891C2584000000          mov [gs:128 + 4], rbx                           ; 置 TSS 中的 RSP0
   387 00000D41 0F01F8                      swapgs
   388                                  
   389 00000D44 498B4C2450                  mov rcx, [r12 + 80]
   390 00000D49 498B542458                  mov rdx, [r12 + 88]
   391 00000D4E 498B7C2468                  mov rdi, [r12 + 104]
   392 00000D53 498B6C2470                  mov rbp, [r12 + 112]
   393 00000D58 498B642478                  mov rsp, [r12 + 120]
   394 00000D5D 4D8B842480000000            mov r8, [r12 + 128]
   395 00000D65 4D8B8C2488000000            mov r9, [r12 + 136]
   396 00000D6D 4D8B942490000000            mov r10, [r12 + 144]
   397                                  
   398 00000D75 4D8BAC24A8000000            mov r13, [r12 + 168]
   399 00000D7D 4D8BB424B0000000            mov r14, [r12 + 176]
   400 00000D85 4D8BBC24B8000000            mov r15, [r12 + 184]
   401 00000D8D 41FFB424D0000000            push qword [r12 + 208]                          ; SS
   402 00000D95 41FF742478                  push qword [r12 + 120]                          ; RSP
   403 00000D9A 41FFB424E8000000            push qword [r12 + 232]                          ; RFLAGS
   404 00000DA2 41FFB424C8000000            push qword [r12 + 200]                          ; CS
   405 00000DAA 41FFB424C0000000            push qword [r12 + 192]                          ; RIP
   406                                  
   407 00000DB2 898680030000                mov dword [rsi + 0x380], eax                    ; 开始计时
   408                                  
   409 00000DB8 498B442440                  mov rax, [r12 + 64]
   410 00000DBD 498B5C2448                  mov rbx, [r12 + 72]
   411 00000DC2 498B742460                  mov rsi, [r12 + 96]
   412 00000DC7 4D8B9C2498000000            mov r11, [r12 + 152]
   413 00000DCF 4D8BA424A0000000            mov r12, [r12 + 160]
   414                                  
   415 00000DD7 48CF                        iretq                                           ; 转入新线程执行
   416                                  
   417                                  ; ------------------------------------------------------------
   418                                  ; time_slice_out_handler
   419                                  ; 功能: 时间片到期中断的处理过程
   420                                  ; ------------------------------------------------------------
   421                                  time_slice_out_handler:
   422 00000DD9 50                          push rax
   423 00000DDA 53                          push rbx 
   424 00000DDB 4153                        push r11 
   425 00000DDD 4154                        push r12
   426 00000DDF 4155                        push r13 
   427                                  
   428 00000DE1 49BB00E0FFFF7FFFFF-         mov r11, LAPIC_START_ADDR                       ; 给 Local APIC 发送中断结束命令 EOI
   428 00000DEA FF                 
   429 00000DEB 41C783B00000000000-         mov dword [r11 + 0xb0], 0
   429 00000DF4 0000               
   430                                  
   431 00000DF6 E879FEFFFF                  call search_for_a_ready_thread
   432 00000DFB 4D09DB                      or r11, r11 
   433 00000DFE 0F8490000000                jz .return                                      ; 未找到就绪任务
   434                                  
   435 00000E04 0F01F8                      swapgs
   436 00000E07 65488B042508000000          mov rax, qword [gs:8]                           ; 当前任务的 PCB 线性地址
   437 00000E10 65488B1C2520000000          mov rbx, qword [gs:32]                          ; 当前线程的 TCB 线性地址
   438 00000E19 0F01F8                      swapgs
   439                                  
   440                                      ; 保存当前任务和线程的状态以便将来恢复执行。
   441 00000E1C 410F20DD                    mov r13, cr3                                    ; 保存原任务的分页系统
   442 00000E20 4C896838                    mov qword [rax + 56], r13
   443                                      ; rax 和 rbx 不需要保存，将来恢复执行时从栈中弹出
   444 00000E24 48894B50                    mov [rbx + 80], rcx
   445 00000E28 48895358                    mov [rbx + 88], rdx
   446 00000E2C 48897360                    mov [rbx + 96], rsi
   447 00000E30 48897B68                    mov [rbx + 104], rdi
   448 00000E34 48896B70                    mov [rbx + 112], rbp
   449 00000E38 48896378                    mov [rbx + 120], rsp
   450 00000E3C 4C898380000000              mov [rbx + 128], r8
   451 00000E43 4C898B88000000              mov [rbx + 136], r9
   452 00000E4A 4C899390000000              mov [rbx + 144], r10
   453                                      ; r11、r12和 r13 不需要设置，将来恢复执行时从栈中弹出
   454 00000E51 4C89B3B0000000              mov [rbx + 176], r14
   455 00000E58 4C89BBB8000000              mov [rbx + 184], r15
   456 00000E5F 4C8B2D(08000000)            mov r13, [rel position]
   457 00000E66 4D8DAD[940E0000]            lea r13, [r13 + .return]                        ; 将来恢复执行时，是从中断返回也～
   458 00000E6D 4C89ABC0000000              mov [rbx + 192], r13                            ; rip 域为中断返回点
   459 00000E74 8C8BC8000000                mov [rbx + 200], cs
   460 00000E7A 8C93D0000000                mov [rbx + 208], ss
   461 00000E80 9C                          pushfq
   462 00000E81 8F83E8000000                pop qword [rbx + 232]
   463                                  
   464 00000E87 48C7431000000000            mov qword [rbx + 16], 0                         ; 置线程状态为就绪
   465                                  
   466 00000E8F E955FEFFFF                  jmp resume_execute_a_thread                     ; 恢复并执行新线程
   467                                  
   468                                  .return:
   469 00000E94 415D                        pop r13
   470 00000E96 415C                        pop r12 
   471 00000E98 415B                        pop r11
   472 00000E9A 5B                          pop rbx 
   473 00000E9B 58                          pop rax 
   474 00000E9C 48CF                        iretq
   475                                  
   476                                  ; ------------------------------------------------------------
   477                                  ; new_task_notify_handler
   478                                  ; 功能: 新任务创建后，将广播新任务创建消息给所有处理器，所有处理器执行此中断服务例程。
   479                                  ; ------------------------------------------------------------
   480                                  new_task_notify_handler:
   481 00000E9E 56                          push rsi 
   482 00000E9F 4153                        push r11 
   483 00000EA1 4154                        push r12 
   484                                  
   485 00000EA3 48BE00E0FFFF7FFFFF-         mov rsi, LAPIC_START_ADDR                       
   485 00000EAC FF                 
   486 00000EAD C786B0000000000000-         mov dword [rsi + 0xb0], 0                       ; 发送 EOI
   486 00000EB6 00                 
   487                                  
   488 00000EB7 0F01F8                      swapgs
   489 00000EBA 6548833C2508000000-         cmp qword [gs:8], 0                             ; 当前处理器没有任务执行吗?
   489 00000EC3 00                 
   490 00000EC4 0F01F8                      swapgs
   491 00000EC7 7522                        jne .return 
   492                                  
   493 00000EC9 E8A6FDFFFF                  call search_for_a_ready_thread
   494 00000ECE 4D09DB                      or r11, r11 
   495 00000ED1 7418                        jz .return                                      ; 未找到就绪任务
   496                                  
   497 00000ED3 0F01F8                      swapgs
   498 00000ED6 4883C418                    add rsp, 24,                                    ; 去掉前面压入的三个
   499 00000EDA 654889242518000000          mov qword [gs:24], rsp                          ; 保存固有栈当前指针, 以便将来返回, 在进入中断时 RIP → CS → RFLAGS → RSP → SS 按顺序入栈
   500 00000EE3 0F01F8                      swapgs
   501                                  
   502 00000EE6 E9FEFDFFFF                  jmp resume_execute_a_thread                     ; 执行新任务
   503                                  
   504                                  .return:
   505 00000EEB 415C                        pop r12    
   506 00000EED 415B                        pop r11
   507 00000EEF 5E                          pop rsi
   508                                  
   509 00000EF0 48CF                        iretq 
   510                                  
   511                                  ; ------------------------------------------------------------
   512                                  ; append_to_pcb_link
   513                                  ; 功能: 在 PCB 链上追加任务控制块
   514                                  ; 输入: r11=PCB 线性基地址
   515                                  ; ------------------------------------------------------------
   516 00000EF2 0000000000000000        _append_lock dq 0
   517                                  
   518                                  append_to_pcb_link:
   519 00000EFA 50                          push rax 
   520 00000EFB 53                          push rbx 
   521                                  
   522 00000EFC 9C                          pushfq
   523 00000EFD FA                          cli 
   524                                      SET_SPIN_LOCK rax, qword [rel _append_lock]
    49                              <1>  %%spin_lock:
    50 00000EFE 48833DECFFFFFF00    <1>  cmp %2, 0
    51 00000F06 7404                <1>  je %%get_lock
    52 00000F08 F390                <1>  pause
    53 00000F0A EBF2                <1>  jmp %%spin_lock
    54                              <1>  %%get_lock:
    55 00000F0C B801000000          <1>  mov %1, 1
    56 00000F11 488705DAFFFFFF      <1>  xchg %1, %2
    57 00000F18 4883F800            <1>  cmp %1, 0
    58 00000F1C 75E0                <1>  jne %%spin_lock
   525                                  
   526 00000F1E 488B1D(E9020000)            mov rbx, [rel pcb_ptr]                          ; 取得链表首节点的线性地址
   527 00000F25 4809DB                      or rbx, rbx 
   528 00000F28 7513                        jnz .not_empty                                  ; 链表非空就跳转
   529 00000F2A 4D891B                      mov [r11], r11                                  ; 唯一的节点, 前驱是自己
   530 00000F2D 4D899B18010000              mov [r11 + 280], r11                            ; 后继节点也是自己
   531 00000F34 4C891D(E9020000)            mov [rel pcb_ptr], r11                          ; 填入内核
   532 00000F3B EB17                        jmp .return 
   533                                  
   534                                  .not_empty:
   535                                      ; rbx=头节点, rax=头节点的前驱节点, r11=追加的节点
   536 00000F3D 488B03                      mov rax, [rbx]                                  ; 取得头节点的前驱线性地址
   537 00000F40 4C899818010000              mov [rax + 280], r11                            ; 头节点的后继是追加节点
   538 00000F47 49899B18010000              mov [r11 + 280], rbx                            ; 追加节点的后继是头节点
   539 00000F4E 498903                      mov [r11], rax                                  ; 追加节点的前驱是头节点的前驱
   540 00000F51 4C891B                      mov [rbx], r11                                  ; 头节点的前驱是追加节点
   541                                  
   542                                  .return:
   543 00000F54 48C70593FFFFFF0000-         mov qword [rel _append_lock], 0
   543 00000F5D 0000               
   544 00000F5F 9D                          popfq
   545                                  
   546 00000F60 5B                          pop rbx 
   547 00000F61 58                          pop rax 
   548                                  
   549 00000F62 C3                          ret 
   550                                  
   551                                  ; ------------------------------------------------------------
   552                                  ; get_current_tid
   553                                  ; 功能: 返回当前线程的标识
   554                                  ; 输出: rax=当前线程的标识
   555                                  ; ------------------------------------------------------------
   556                                  get_current_tid:
   557 00000F63 9C                          pushfq
   558 00000F64 FA                          cli 
   559 00000F65 0F01F8                      swapgs 
   560 00000F68 65488B042520000000          mov rax, [gs:32]
   561 00000F71 488B4008                    mov rax, [rax + 8]
   562 00000F75 0F01F8                      swapgs
   563 00000F78 9D                          popfq
   564                                  
   565 00000F79 C3                          ret 
   566                                  
   567                                  ; ------------------------------------------------------------
   568                                  ; get_current_pid
   569                                  ; 功能: 返回当前任务（进程）的标识
   570                                  ; 输出: rax=当前任务（进程）的标识
   571                                  ; ------------------------------------------------------------
   572                                  get_current_pid:
   573 00000F7A 9C                          pushfq
   574 00000F7B FA                          cli 
   575 00000F7C 0F01F8                      swapgs
   576 00000F7F 65488B042508000000          mov rax, [gs:8]
   577 00000F88 488B4008                    mov rax, [rax + 8]
   578 00000F8C 0F01F8                      swapgs
   579 00000F8F 9D                          popfq
   580                                  
   581 00000F90 C3                          ret 
   582                                  
   583                                  ; ------------------------------------------------------------
   584                                  ; search_for_thread_id
   585                                  ; 功能: 查找指定标识的线程
   586                                  ; 输入: rdx=线程标识
   587                                  ; 输出: r11=线程的 TCB 线性地址, r11=0 表明不存在指定的线程
   588                                  ; ------------------------------------------------------------
   589                                  search_for_thread_id:
   590 00000F91 53                          push rbx 
   591                                  
   592 00000F92 488B1D(E9020000)            mov rbx, [rel pcb_ptr]                          ; pcb 链表头
   593                                  .nextp:
   594 00000F99 4C8B9B10010000              mov r11, [rbx + 272]                            ; tcb
   595                                  .nextt:
   596 00000FA0 49395308                    cmp [r11 + 8], rdx                              ; 找到指定的线程了吗?
   597 00000FA4 7420                        je .found                                       ; 是的。转.found
   598 00000FA6 4D8B9B18010000              mov r11, [r11 + 280]                            ; 否。处理下一个 TCB 节点
   599 00000FAD 4983FB00                    cmp r11, 0
   600 00000FB1 75ED                        jne .nextt
   601                                  
   602 00000FB3 488B9B18010000              mov rbx, [rbx + 280]                            ; 下一个 PCB 节点
   603 00000FBA 483B1D(E9020000)            cmp rbx, [rel pcb_ptr]                          ; 转一圈又回到 PCB 首节点?
   604 00000FC1 75D6                        jne .nextp                                      ; 否。转 .nextp 处理下一个 PCB
   605                                  
   606 00000FC3 4D31DB                      xor r11, r11                                    ; r11=0 表明不存在指定的线程
   607                                  .found:
   608 00000FC6 5B                          pop rbx 
   609                                  
   610 00000FC7 C3                          ret 
   611                                  
   612                                  ; ------------------------------------------------------------
   613                                  ; waiting_for_a_thread
   614                                  ; 功能: 等待指定的线程结束
   615                                  ; 输入: rdx=线程标识
   616                                  ; ------------------------------------------------------------
   617                                  waiting_for_a_thread:
   618 00000FC8 50                          push rax
   619 00000FC9 53                          push rbx
   620 00000FCA 4153                        push r11
   621 00000FCC 4154                        push r12
   622 00000FCE 4155                        push r13
   623                                  
   624 00000FD0 E8BCFFFFFF                  call search_for_thread_id
   625 00000FD5 4D09DB                      or r11, r11                                     ; 线程存在
   626 00000FD8 0F84F6000000                jz .return
   627 00000FDE 49837B1002                  cmp qword [r11 + 16], 2                         ; 线程已经终止?
   628 00000FE3 0F84EB000000                je .return 
   629                                  
   630                                      ; 被等待的线程还在运行，只能休眠并等待通知
   631 00000FE9 FA                          cli 
   632                                  
   633 00000FEA 48B800E0FFFF7FFFFF-         mov rax, LAPIC_START_ADDR
   633 00000FF3 FF                 
   634 00000FF4 C78020030000000001-         mov dword [rax + 0x320], 0x00010000             ; 屏蔽定时器中断
   634 00000FFD 00                 
   635                                  
   636 00000FFE 0F01F8                      swapgs
   637 00001001 65488B042508000000          mov rax, qword [gs:8]                           ; 当前任务的 PCB 线性地址
   638 0000100A 65488B1C2520000000          mov rbx, qword [gs:32]                          ; 当前线程的 TCB 线性地址
   639 00001013 0F01F8                      swapgs
   640                                  
   641                                      ; 保存当前任务和线程的状态以便将来恢复执行。
   642 00001016 410F20DD                    mov r13, cr3                                    ; 保存原任务的分页系统
   643 0000101A 4C896838                    mov qword [rax + 56], r13
   644                                      ; rax 和 rbx 不需要保存，将来恢复执行时从栈中弹出
   645 0000101E 48894B50                    mov [rbx + 80], rcx
   646 00001022 48895358                    mov [rbx + 88], rdx
   647 00001026 48897360                    mov [rbx + 96], rsi
   648 0000102A 48897B68                    mov [rbx + 104], rdi
   649 0000102E 48896B70                    mov [rbx + 112], rbp
   650 00001032 48896378                    mov [rbx + 120], rsp
   651 00001036 4C898380000000              mov [rbx + 128], r8
   652 0000103D 4C898B88000000              mov [rbx + 136], r9
   653 00001044 4C899390000000              mov [rbx + 144], r10
   654                                      ; r11、r12 和 r13 不需要设置，将来恢复执行时从栈中弹出
   655 0000104B 4C89B3B0000000              mov [rbx + 176], r14
   656 00001052 4C89BBB8000000              mov [rbx + 184], r15
   657 00001059 4C8B2D(08000000)            mov r13, [rel position]
   658 00001060 4D8DAD[D4100000]            lea r13, [r13 + .return]                        ; 将来恢复执行时，是从例程调用返回
   659 00001067 4C89ABC0000000              mov [rbx + 192], r13                            ; rip 域为中断返回点
   660 0000106E 8C8BC8000000                mov [rbx + 200], cs
   661 00001074 8C93D0000000                mov [rbx + 208], ss
   662 0000107A 9C                          pushfq
   663 0000107B 8F83E8000000                pop qword [rbx + 232]
   664                                  
   665 00001081 48C7431003000000            mov qword [rbx + 16], 3                         ; 置线程状态为“休眠并等待指定线程结束”
   666 00001089 48895338                    mov qword [rbx + 56], rdx                       ; 设置被等待的线程标识
   667                                  
   668 0000108D E8E2FBFFFF                  call search_for_a_ready_thread
   669 00001092 4D09DB                      or r11, r11 
   670 00001095 7405                        jz .sleep
   671                                  
   672 00001097 E94DFCFFFF                  jmp resume_execute_a_thread
   673                                  
   674                                  .sleep:
   675 0000109C 0F01F8                      swapgs
   676 0000109F 6548C7042500000000-         mov qword [gs:0], 0                             ; 当前处理器无有效 3 特权级栈指针
   676 000010A8 00000000           
   677 000010AC 6548C7042508000000-         mov qword [gs:8], 0                             ; 当前处理器未在执行任务
   677 000010B5 00000000           
   678 000010B9 6548C7042520000000-         mov qword [gs:32], 0                            ; 当前处理器未在执行线程
   678 000010C2 00000000           
   679 000010C6 65488B242518000000          mov rsp, [gs:24]                                ; 切换到处理器的固有栈
   680 000010CF 0F01F8                      swapgs
   681                                  
   682 000010D2 48CF                        iretq
   683                                  
   684                                  .return:
   685 000010D4 415D                        pop r13
   686 000010D6 415C                        pop r12
   687 000010D8 415B                        pop r11
   688 000010DA 5B                          pop rbx
   689 000010DB 58                          pop rax
   690                                  
   691 000010DC C3                          ret
   692                                  
   693                                  ; ------------------------------------------------------------
   694                                  ; init_mutex
   695                                  ; 功能: 初始化互斥锁
   696                                  ; 输出: rdx=互斥锁变量线性地址
   697                                  ; ------------------------------------------------------------
   698                                  init_mutex:
   699 000010DD 51                          push rcx 
   700 000010DE 4155                        push r13 
   701 000010E0 4156                        push r14 
   702                                  
   703 000010E2 B908000000                  mov rcx, 8
   704 000010E7 E8A8F6FFFF                  call core_memory_allocate                       ; 必须是在内核的空间中开辟
   705 000010EC 49C7450000000000            mov qword [r13], 0                              ; 初始化互斥锁的状态（未加锁）
   706 000010F4 4C89EA                      mov rdx, r13
   707                                  
   708 000010F7 415E                        pop r14
   709 000010F9 415D                        pop r13
   710 000010FB 59                          pop rcx
   711                                  
   712 000010FC C3                          ret
   713                                  
   714                                  ; ------------------------------------------------------------
   715                                  ; acquire_mutex
   716                                  ; 功能: 获取互斥锁
   717                                  ; 输入: rdx=互斥锁变量线性地址
   718                                  ; ------------------------------------------------------------
   719                                  acquire_mutex:
   720 000010FD 50                          push rax
   721 000010FE 53                          push rbx
   722 000010FF 4153                        push r11
   723 00001101 4154                        push r12
   724 00001103 4155                        push r13
   725                                  
   726 00001105 41BB01000000                mov r11, 1
   727 0000110B B800000000                  mov rax, 0
   728 00001110 F04C0FB11A                  lock cmpxchg [rdx], r11
   729 00001115 0F84EB000000                jz .return
   730                                  
   731                                      ; 未获得互斥锁，只能阻塞当前线程
   732 0000111B FA                          cli 
   733                                      
   734 0000111C 48B800E0FFFF7FFFFF-         mov rax, LAPIC_START_ADDR
   734 00001125 FF                 
   735 00001126 C78020030000000001-         mov dword [rax + 0x320], 0x00010000             ; 屏蔽定时器中断
   735 0000112F 00                 
   736                                  
   737 00001130 0F01F8                      swapgs
   738 00001133 65488B042508000000          mov rax, qword [gs:8]                           ; 当前任务的 PCB 线性地址
   739 0000113C 65488B1C2520000000          mov rbx, qword [gs:32]                          ; 当前线程的 TCB 线性地址
   740 00001145 0F01F8                      swapgs
   741                                  
   742                                      ; 保存当前任务和线程的状态以便将来恢复执行。恢复时已获得互斥锁
   743 00001148 410F20DD                    mov r13, cr3                                    ; 保存原任务的分页系统
   744 0000114C 4C896838                    mov qword [rax + 56], r13
   745                                      ; RAX 和 RBX 不需要保存，将来恢复执行时从栈中弹出
   746 00001150 48894B50                    mov [rbx + 80], rcx
   747 00001154 48895358                    mov [rbx + 88], rdx
   748 00001158 48897360                    mov [rbx + 96], rsi
   749 0000115C 48897B68                    mov [rbx + 104], rdi
   750 00001160 48896B70                    mov [rbx + 112], rbp
   751 00001164 48896378                    mov [rbx + 120], rsp
   752 00001168 4C898380000000              mov [rbx + 128], r8
   753 0000116F 4C898B88000000              mov [rbx + 136], r9
   754 00001176 4C899390000000              mov [rbx + 144], r10
   755                                      ;r11、r12 和 r13 不需要设置，将来恢复执行时从栈中弹出
   756 0000117D 4C89B3B0000000              mov [rbx + 176], r14
   757 00001184 4C89BBB8000000              mov [rbx + 184], r15
   758 0000118B 4C8B2D(08000000)            mov r13, [rel position]
   759 00001192 4D8DAD[06120000]            lea r13, [r13 + .return]                        ; 将来恢复执行时已获得互斥锁
   760 00001199 4C89ABC0000000              mov [rbx + 192], r13                            ; rip 域为中断返回点
   761 000011A0 8C8BC8000000                mov [rbx + 200], cs
   762 000011A6 8C93D0000000                mov [rbx + 208], ss
   763 000011AC 9C                          pushfq
   764 000011AD 8F83E8000000                pop qword [rbx + 232]
   765                                  
   766 000011B3 48895338                    mov qword [rbx + 56], rdx                       ; 设置被等待的数据的线性地址
   767 000011B7 48C7431005000000            mov qword [rbx + 16], 5                         ; 置线程状态为“休眠并等待某个信号清零”
   768                                  
   769 000011BF E8B0FAFFFF                  call search_for_a_ready_thread
   770 000011C4 4D09DB                      or r11, r11
   771 000011C7 7405                        jz .sleep                                       ; 未找到就绪的任务
   772                                  
   773 000011C9 E91BFBFFFF                  jmp resume_execute_a_thread                     ; 恢复并执行新线程
   774                                  
   775                                  .sleep:
   776 000011CE 0F01F8                      swapgs
   777 000011D1 6548C7042500000000-         mov qword [gs:0], 0                             ; 当前处理器无有效 3 特权级栈指针
   777 000011DA 00000000           
   778 000011DE 6548C7042508000000-         mov qword [gs:8], 0                             ; 当前处理器未在执行任务
   778 000011E7 00000000           
   779 000011EB 6548C7042520000000-         mov qword [gs:32], 0                            ; 当前处理器未在执行线程
   779 000011F4 00000000           
   780 000011F8 65488B242518000000          mov rsp, [gs:24]                                ; 切换到处理器的固有栈
   781 00001201 0F01F8                      swapgs
   782                                  
   783 00001204 48CF                        iretq
   784                                  
   785                                  .return:
   786 00001206 415D                        pop r13
   787 00001208 415C                        pop r12
   788 0000120A 415B                        pop r11
   789 0000120C 5B                          pop rbx
   790 0000120D 58                          pop rax
   791                                  
   792 0000120E C3                          ret
   793                                  
   794                                  ; ------------------------------------------------------------
   795                                  ; release_mutex
   796                                  ; 功能: 释放互斥锁
   797                                  ; 输入: rdx=互斥锁变量线性地址
   798                                  ; ------------------------------------------------------------
   799                                  release_mutex:
   800 0000120F 50                          push rax 
   801                                  
   802 00001210 4831C0                      xor rax, rax 
   803 00001213 488702                      xchg [rdx], rax 
   804                                      
   805 00001216 58                          pop rax 
   806                                  
   807 00001217 C3                          ret 
   808                                  
   809                                  ; ------------------------------------------------------------
   810                                  ; thread_sleep
   811                                  ; 功能: 线程休眠
   812                                  ; 输入: rdx=以55ms为单位的时间长度
   813                                  ; ------------------------------------------------------------
   814                                  thread_sleep:
   815 00001218 50                          push rax
   816 00001219 53                          push rbx
   817 0000121A 4153                        push r11
   818 0000121C 4154                        push r12
   819 0000121E 4155                        push r13
   820                                  
   821 00001220 4883FA00                    cmp rdx, 0
   822 00001224 0F84EB000000                je .return 
   823                                  
   824                                      ; 休眠就意味着阻塞当前进程
   825 0000122A FA                          cli 
   826                                  
   827 0000122B 48B800E0FFFF7FFFFF-         mov rax, LAPIC_START_ADDR
   827 00001234 FF                 
   828 00001235 C78020030000000001-         mov dword [rax + 0x320], 0x00010000             ; 屏蔽定时器中断
   828 0000123E 00                 
   829                                  
   830 0000123F 0F01F8                      swapgs
   831 00001242 65488B042508000000          mov rax, qword [gs:8]                           ; PCB 线性地址
   832 0000124B 65488B1C2520000000          mov rbx, qword [gs:32]                          ; TCB 线性地址
   833 00001254 0F01F8                      swapgs
   834                                  
   835                                      ; 保存当前任务和线程的状态以便将来恢复执行。
   836 00001257 410F20DD                    mov r13, cr3                                    ; 保存原任务的分页系统
   837 0000125B 4C896838                    mov qword [rax + 56], r13
   838                                      ; rax 和 rbx 不需要保存，将来恢复执行时从栈中弹出
   839 0000125F 48894B50                    mov [rbx + 80], rcx
   840 00001263 48895358                    mov [rbx + 88], rdx
   841 00001267 48897360                    mov [rbx + 96], rsi
   842 0000126B 48897B68                    mov [rbx + 104], rdi
   843 0000126F 48896B70                    mov [rbx + 112], rbp
   844 00001273 48896378                    mov [rbx + 120], rsp
   845 00001277 4C898380000000              mov [rbx + 128], r8
   846 0000127E 4C898B88000000              mov [rbx + 136], r9
   847 00001285 4C899390000000              mov [rbx + 144], r10
   848                                      ; r11、r12 和 r13 不需要设置，将来恢复执行时从栈中弹出
   849 0000128C 4C89B3B0000000              mov [rbx + 176], r14
   850 00001293 4C89BBB8000000              mov [rbx + 184], r15
   851 0000129A 4C8B2D(08000000)            mov r13, [rel position]
   852 000012A1 4D8DAD[15130000]            lea r13, [r13 + .return]                        ; 将来恢复执行时，重新尝试加锁
   853 000012A8 4C89ABC0000000              mov [rbx + 192], r13                            ; rip 域为中断返回点
   854 000012AF 8C8BC8000000                mov [rbx + 200], cs
   855 000012B5 8C93D0000000                mov [rbx + 208], ss
   856 000012BB 9C                          pushfq
   857 000012BC 8F83E8000000                pop qword [rbx + 232]
   858                                  
   859 000012C2 48895338                    mov qword [rbx + 56], rdx                       ; 设置以 55ms 为单位的时间长度
   860 000012C6 48C7431004000000            mov qword [rbx + 16], 4                         ; 置线程状态为“休眠指定时间长度”
   861                                  
   862 000012CE E8A1F9FFFF                  call search_for_a_ready_thread
   863 000012D3 4D09DB                      or r11, r11 
   864 000012D6 7405                        jz .sleep                                       ; 未找到就绪任务
   865                                  
   866 000012D8 E90CFAFFFF                  jmp resume_execute_a_thread                     ; 恢复并执行新进程
   867                                  
   868                                  .sleep:
   869 000012DD 0F01F8                      swapgs
   870 000012E0 6548C7042500000000-         mov qword [gs:0], 0                             ; 当前处理器无有效 3 级特权栈指针
   870 000012E9 00000000           
   871 000012ED 6548C7042508000000-         mov qword [gs:8], 0                             ; 当前处理器未执行任务
   871 000012F6 00000000           
   872 000012FA 6548C7042520000000-         mov qword [gs:32], 0                            ; 当前处理器未执行线程
   872 00001303 00000000           
   873 00001307 65488B242518000000          mov rsp, [gs:24]                                ; 切换到处理器固有栈
   874 00001310 0F01F8                      swapgs
   875                                  
   876 00001313 48CF                        iretq
   877                                  
   878                                  .return:
   879 00001315 48BB00800B000080FF-         mov rbx, UPPER_TEXT_VIDEO
   879 0000131E FF                 
   880 0000131F F65302                      not byte [rbx + 2]
   881                                  
   882 00001322 415D                        pop r13
   883 00001324 415C                        pop r12
   884 00001326 415B                        pop r11
   885 00001328 5B                          pop rbx
   886 00001329 58                          pop rax
   887                                  
   888 0000132A C3                          ret
   889                                  
   890                                  ; ------------------------------------------------------------
   891                                  ; thread_exit
   892                                  ; 功能: 线程终止退出
   893                                  ; 输入: rdx=返回码
   894                                  ; ------------------------------------------------------------
   895                                  thread_exit:
   896 0000132B 48BE00E0FFFF7FFFFF-         mov rsi, LAPIC_START_ADDR
   896 00001334 FF                 
   897 00001335 C78620030000000001-         mov dword [rsi + 0x320], 0x00010000             ; 屏蔽定时器中断
   897 0000133E 00                 
   898                                  
   899 0000133F FA                          cli 
   900                                  
   901 00001340 0F01F8                      swapgs
   902 00001343 65488B1C2520000000          mov rbx, [gs:32]                                ; 取出当前线程的 TCB 线性地址
   903 0000134C 65488B242518000000          mov rsp, [gs:24]                                ; 切换到处理器固有栈
   904 00001355 6548C7042500000000-         mov qword [gs:0], 0                             ; 当前处理器无有效 3 级特权栈指针
   904 0000135E 00000000           
   905 00001362 6548C7042508000000-         mov qword [gs:8], 0                             ; 当前处理器未执行任务
   905 0000136B 00000000           
   906 0000136F 6548C7042520000000-         mov qword [gs:32], 0                            ; 当前处理器未执行线程
   906 00001378 00000000           
   907 0000137C 0F01F8                      swapgs
   908                                  
   909 0000137F 48C7431002000000            mov qword [rbx + 16], 2                         ; 线程状态: 终止
   910 00001387 48895318                    mov [rbx + 24], rdx                             ; 返回码
   911                                  
   912 0000138B E8E4F8FFFF                  call search_for_a_ready_thread
   913 00001390 4D09DB                      or r11, r11 
   914 00001393 7405                        jz .sleep 
   915                                  
   916 00001395 E94FF9FFFF                  jmp resume_execute_a_thread
   917                                  
   918                                  .sleep:
   919 0000139A 48CF                        iretq                                           ; 回到不执行线程的代码
   920                                  
   921                                  ; ------------------------------------------------------------
   922                                  ; terminate_process
   923                                  ; 功能: 终止当前任务
   924                                  ; ------------------------------------------------------------
   925                                  terminate_process:
   926 0000139C 48BE00E0FFFF7FFFFF-         mov rsi, LAPIC_START_ADDR
   926 000013A5 FF                 
   927 000013A6 C78620030000000001-         mov dword [rsi + 0x320], 0x00010000             ; 屏蔽定时器中断
   927 000013AF 00                 
   928                                  
   929 000013B0 FA                          cli                                             ; 执行流改变期间禁止时钟中断引发的任务切换
   930                                  
   931 000013B1 0F01F8                      swapgs
   932 000013B4 65488B042508000000          mov rax, [gs:8]                                 ; 当前的 PCB 线性地址
   933 000013BD 48C7401002000000            mov qword [rax + 16], 2                         ; 任务状态=终止
   934 000013C5 65488B042520000000          mov rax, [gs:32]                                ; 当前的 TCB 线性地址
   935 000013CE 48C7401002000000            mov qword [rax + 16], 2                         ; 线程状态=终止
   936 000013D6 6548C7042500000000-         mov qword [gs:0], 0
   936 000013DF 00000000           
   937 000013E3 65488B242518000000          mov rsp, [gs:24]                                ; 切换到处理器固有栈
   938 000013EC 6548C7042500000000-         mov qword [gs:0], 0                             ; 当前处理器无有效 3 级特权栈指针
   938 000013F5 00000000           
   939 000013F9 6548C7042508000000-         mov qword [gs:8], 0                             ; 当前处理器未执行任务
   939 00001402 00000000           
   940 00001406 6548C7042520000000-         mov qword [gs:32], 0                            ; 当前处理器未执行线程
   940 0000140F 00000000           
   941 00001413 0F01F8                      swapgs
   942                                  
   943 00001416 E859F8FFFF                  call search_for_a_ready_thread
   944 0000141B 4D09DB                      or r11, r11 
   945 0000141E 7405                        jz .sleep                                       ; 未找到就绪任务
   946                                  
   947 00001420 E9C4F8FFFF                  jmp resume_execute_a_thread                     ; 执行新任务
   948                                  
   949                                  .sleep:
   950 00001425 48CF                        iretq
   951                                  
   952                                  ; ------------------------------------------------------------
   953                                  ; create_thread
   954                                  ; 功能: 创建一个线程
   955                                  ; 输入: rsi=线程入口的线性地址, rdi=传递给线程的参数
   956                                  ; 输出: rdx=线程标识
   957                                  ; ------------------------------------------------------------
   958                                  create_thread:
   959 00001427 50                          push rax
   960 00001428 53                          push rbx
   961 00001429 51                          push rcx
   962 0000142A 4153                        push r11
   963 0000142C 4154                        push r12
   964 0000142E 4155                        push r13
   965 00001430 4156                        push r14
   966                                  
   967                                      ; 先创建并填写 TCB
   968 00001432 B900020000                  mov rcx, 512                                    ; 开辟内核空间
   969 00001437 E858F3FFFF                  call core_memory_allocate
   970                                  
   971 0000143C 4C89EB                      mov rbx, r13                                    ; 以下, rbx专用于保存 TCB 线性地址
   972                                  
   973 0000143F E8C9F4FFFF                  call generate_thread_id
   974 00001444 48894308                    mov [rbx + 8], rax                              ; 记录当前线程的标识
   975 00001448 4889C2                      mov rdx, rax                                    ; 用于返回线程标识
   976                                  
   977 0000144B 48C7431000000000            mov qword [rbx + 16], 0                         ; 线程状态=就绪
   978                                  
   979 00001453 B900000100                  mov rcx, 4096 * 16                              ; 为 TSS 的 RSP0 开辟栈空间
   980 00001458 E837F3FFFF                  call core_memory_allocate                       
   981 0000145D 4C897320                    mov [rbx + 32], r14                             ; 填写 TCB 中的 RSP0 域的值
   982                                  
   983 00001461 9C                          pushfq
   984 00001462 FA                          cli 
   985 00001463 0F01F8                      swapgs
   986 00001466 654C8B1C2508000000          mov r11, [gs:8]                                 ; 当前 PCB
   987 0000146F 654C8B242520000000          mov r12, [gs:32]                                ; 当前 TCB
   988 00001478 0F01F8                      swapgs
   989 0000147B 9D                          popfq
   990                                  
   991                                      ; 见书中 433 图
   992 0000147C B900000100                  mov rcx, 4096 * 16                              ; 开辟线程栈空间
   993 00001481 E863F3FFFF                  call user_memory_allocate
   994 00001486 4983EE20                    sub r14, 32                                     ; 栈中开辟 32 字节空间
   995 0000148A 4C897378                    mov [rbx + 120], r14                            ; 线程执行时的 rsp
   996                                  
   997 0000148E 498D4E08                    lea rcx, [r14 + 8]                              ; 得到线程返回地址
   998 00001492 49890E                      mov [r14], rcx                                  ; 相当于 call 压入返回值
   999                                  
  1000                                      ; 以下填写指令 MOV RAX, 9 的机器代码
  1001 00001495 C601B8                      mov byte [rcx], 0xb8
  1002 00001498 C6410109                    mov byte [rcx + 1], 0x09
  1003 0000149C C6410200                    mov byte [rcx + 2], 0x00
  1004 000014A0 C6410300                    mov byte [rcx + 3], 0x00
  1005 000014A4 C6410400                    mov byte [rcx + 4], 0x00
  1006                                      ; 以下填写指令 XOR RDX, RDX 的机器代码
  1007 000014A8 C6410548                    mov byte [rcx + 5], 0x48
  1008 000014AC C6410631                    mov byte [rcx + 6], 0x31
  1009 000014B0 C64107D2                    mov byte [rcx + 7], 0xd2
  1010                                      ; 以下填写指令 SYSCALL 的机器代码
  1011 000014B4 C641080F                    mov byte [rcx + 8], 0x0f
  1012 000014B8 C6410905                    mov byte [rcx + 9], 0x05
  1013                                  
  1014 000014BC 4889B3C0000000              mov qword [rbx + 192], rsi                      ; 线程入口地址(rip)
  1015                                  
  1016 000014C3 48C783C80000003B00-         mov qword [rbx + 200], USER_CODE64_SEL          ; 线程代码段选择子
  1016 000014CC 0000               
  1017 000014CE 48C783D00000003300-         mov qword [rbx + 208], USER_STACK64_SEL         ; 线程段选择子
  1017 000014D7 0000               
  1018                                  
  1019 000014D9 9C                          pushfq
  1020 000014DA 8F83E8000000                pop qword [rbx + 232]                           ; 线程执行时的标志寄存器
  1021                                  
  1022 000014E0 48C783F00000003700-         mov qword [rbx + 240], SUGG_PREEM_SLICE         ; 推荐的线程执行时间片
  1022 000014E9 0000               
  1023 000014EB 48C783180100000000-         mov qword [rbx + 280], 0                        ; 下一个 TCB 的线性地址, 0=无
  1023 000014F4 0000               
  1024                                  
  1025                                  .again:
  1026 000014F6 4831C0                      xor rax, rax 
  1027 000014F9 F0490FB19C24180100-         lock cmpxchg [r12 + 280], rbx                   ; 如果后继节点为 0, 则新节点为其后继. cmpxchg dest, src  ; 比较 dest 与 累加器(AL/AX/EAX/RAX)比较，相等则 dest ← src，否则累加器 ← dest
  1027 00001502 00                 
  1028 00001503 740A                        jz .linkd 
  1029 00001505 4D8BA42418010000            mov r12, [r12 + 280]
  1030 0000150D EBE7                        jmp .again
  1031                                  
  1032                                  .linkd:
  1033 0000150F 48B900E0FFFF7FFFFF-         mov rcx, LAPIC_START_ADDR
  1033 00001518 FF                 
  1034 00001519 C78110030000000000-         mov dword [rcx + 0x310], 0
  1034 00001522 00                 
  1035 00001523 C78100030000FE4008-         mov dword [rcx + 0x300], 0x000840fe             ; 向所有处理器发送线程认领中断
  1035 0000152C 00                 
  1036                                  
  1037 0000152D 415E                        pop r14
  1038 0000152F 415D                        pop r13
  1039 00001531 415C                        pop r12
  1040 00001533 415B                        pop r11
  1041 00001535 59                          pop rcx
  1042 00001536 5B                          pop rbx
  1043 00001537 58                          pop rax
  1044                                  
  1045 00001538 C3                          ret
  1046                                  
  1047                                  ; ------------------------------------------------------------
  1048                                  ; create_process
  1049                                  ; 功能: 创建新的任务, 即分配好空间, 创建并填入 PCB
  1050                                  ; 输入: r8=程序的起始逻辑扇区号
  1051                                  ; ------------------------------------------------------------
  1052                                  create_process:
  1053 00001539 50                          push rax
  1054 0000153A 53                          push rbx
  1055 0000153B 51                          push rcx
  1056 0000153C 52                          push rdx
  1057 0000153D 56                          push rsi
  1058 0000153E 57                          push rdi
  1059 0000153F 55                          push rbp
  1060 00001540 4150                        push r8
  1061 00001542 4151                        push r9
  1062 00001544 4152                        push r10
  1063 00001546 4153                        push r11
  1064 00001548 4154                        push r12
  1065 0000154A 4155                        push r13
  1066 0000154C 4156                        push r14
  1067 0000154E 4157                        push r15
  1068                                  
  1069                                      ; 在内核空间创建任务控制块 PCB, 来记录任务相关信息, 内核通过任务控制块来跟踪和识别任务, 并对任务进行管理和控制
  1070 00001550 B900020000                  mov rcx, 512                                    ; 任务控制块 PCB 的尺寸, PCB 的格式见书中 205 图
  1071 00001555 E83AF2FFFF                  call core_memory_allocate                       ; 在内核分配地址
  1072                                  
  1073 0000155A 4D89EB                      mov r11, r13                                    ; r11 寄存器用来保存 PCB 线性地址
  1074                                  
  1075 0000155D E832F2FFFF                  call core_memory_allocate                       ; 为线程控制块 TCB 分配内存
  1076 00001562 4D89EC                      mov r12, r13                                    ; r13 寄存器用来保存 TCB 线性地址
  1077                                  
  1078 00001565 4D89A310010000              mov qword [r11 + 272], r12                      ; 在 PCB 中登记第一个 TCB
  1079                                  
  1080 0000156C 49C7431800000000            mov qword [r11 + 24], USER_ALLOC_START          ; 填写 PCB 的下一次内存分配时可用线性地址
  1081                                      
  1082                                      ; 从当前的四级头表复制并创建新任务的四级头表
  1083 00001574 E8BCF2FFFF                  call copy_current_pml4                          ; 在 core_utils64.asm 中实现
  1084 00001579 49894338                    mov [r11 + 56], rax                             ; 填写 PCB 的 CR3, 默认 PCD=PWT=0(这两个属性忘记的话可以看看书中 123 页)
  1085                                  
  1086                                      ; 以下，切换到新任务的地址空间，并清空其 4 级头表的前半部分。
  1087                                      ; 我们正在地址空间的高端执行，可正常执行内核代码并访问内核数据，同时，当前使用的栈位于地址空间高端的栈。
  1088 0000157D 410F20DF                    mov r15, cr3                                    ; 保存控制寄存器, 本次是临时切换, 还要再切回来
  1089 00001581 0F22D8                      mov cr3, rax                                    ; 切换到新四级头表的新地址空间
  1090                                  
  1091                                      ; 清空四级头表的前半部分, 即局部地址
  1092 00001584 48C7C000F0FFFF              mov rax, 0xffff_ffff_ffff_f000                  ; 四级头表线性地址, 还是递归映射...
  1093 0000158B B900010000                  mov rcx, 256
  1094                                  .clsp:
  1095 00001590 48C70000000000              mov qword [rax], 0
  1096 00001597 4883C008                    add rax, 8
  1097 0000159B E2F3                        loop .clsp
  1098                                  
  1099 0000159D 0F20D8                      mov rax, cr3                                    ; 刷新 TLB
  1100 000015A0 0F22D8                      mov cr3, rax 
  1101                                  
  1102                                      ; 为新任务分配 0 特权级使用的栈空间
  1103 000015A3 B900000100                  mov rcx, 4096 * 16                              ; 在内核地址开辟空间
  1104 000015A8 E8E7F1FFFF                  call core_memory_allocate
  1105 000015AD 4D89742420                  mov [r12 + 32], r14                             ; 填入 TCB 中 RSP0, 满减栈, 所以写入结尾地址
  1106                                  
  1107                                      ; 为新任务分配 3 特权级使用的栈空间
  1108 000015B2 B900000100                  mov rcx, 4096 * 16                              ; 在用户地址开辟空间
  1109 000015B7 E82DF2FFFF                  call user_memory_allocate
  1110 000015BC 4D89742478                  mov [r12 + 120], r14                            ; 填入 TCB 中 RSP
  1111                                  
  1112 000015C1 49C7431000000000            mov qword [r11 + 16], 0                         ; PCB 中的任务状态填为运行
  1113 000015C9 49C744241000000000          mov qword [r12 + 16], 0                         ; TCB 中的任务状态填为就绪
  1114                                  
  1115                                      ; 以下开始加载用户程序
  1116 000015D2 B900020000                  mov rcx, 512                                    ; 在用户空间开辟一个缓冲区
  1117 000015D7 E80DF2FFFF                  call user_memory_allocate
  1118 000015DC 4C89EB                      mov rbx, r13 
  1119 000015DF 4C89C0                      mov rax, r8                                     ; r8 中存的用户程序起始扇区号         
  1120 000015E2 E8CAEBFFFF                  call read_hard_disk_0
  1121                                  
  1122 000015E7 4D896D10                    mov [r13 + 16], r13                             ; 在程序头填写它自己的起始线性地址
  1123 000015EB 4D89EE                      mov r14, r13 
  1124 000015EE 4D037508                    add r14, [r13 + 8]
  1125 000015F2 4D89B424C0000000            mov [r12 + 192], r14                            ; 在 TCB 中登记程序入口的线性地址
  1126                                  
  1127                                      ; 以下读取程序剩下代码
  1128 000015FA 498B4D00                    mov rcx, [r13]                                  ; 程序尺寸(在程序头部记录)
  1129 000015FE 48F7C1FF010000              test rcx, 0x1ff                                 ; 能被 512 整除吗?
  1130 00001605 740F                        jz .y512
  1131 00001607 48C1E909                    shr rcx, 9                                      ; 不能就凑整
  1132 0000160B 48C1E109                    shl rcx, 9
  1133 0000160F 4881C100020000              add rcx, 512
  1134                                  .y512:
  1135 00001616 4881E900020000              sub rcx, 512                                    ; 减去已读一个扇区的长度
  1136 0000161D 7416                        jz .rdok 
  1137 0000161F E8C5F1FFFF                  call user_memory_allocate                       ; 先分配内存在读数据
  1138 00001624 48C1E909                    shr rcx, 9                                      ; 除以 512, 计算还需要读的扇区数
  1139 00001628 48FFC0                      inc rax                                         ; 起始扇区号
  1140                                  .b1:
  1141 0000162B E881EBFFFF                  call read_hard_disk_0
  1142 00001630 48FFC0                      inc rax 
  1143 00001633 E2F6                        loop .b1 
  1144                                  
  1145                                  .rdok:
  1146 00001635 49C78424C80000003B-         mov qword [r12 + 200], USER_CODE64_SEL          ; 填写 TCB 中代码段选择子
  1146 0000163E 000000             
  1147 00001641 49C78424D000000033-         mov qword [r12 + 208], USER_STACK64_SEL         ; 填写 TCB 中栈段选择子
  1147 0000164A 000000             
  1148                                  
  1149 0000164D 9C                          pushfq
  1150 0000164E 418F8424E8000000            pop qword [r12 + 232]                           ; 填写 TCB 中 RFLAGS
  1151                                  
  1152 00001656 49C78424F000000037-         mov qword [r12 + 240], SUGG_PREEM_SLICE         ; 推荐的执行时间片
  1152 0000165F 000000             
  1153                                  
  1154 00001662 E88FF2FFFF                  call generate_process_id
  1155 00001667 49894308                    mov [r11 + 8], rax                              ; 填入 PCB 中当前任务标识
  1156                                  
  1157 0000166B E89DF2FFFF                  call generate_thread_id
  1158 00001670 4989442408                  mov [r12 + 8], rax                              ; 记录主线程标识
  1159                                  
  1160 00001675 49C784241801000000-         mov qword [r12 + 280], 0                        ; 下一个 TCB 的线性地址初始化为 0
  1160 0000167E 000000             
  1161                                  
  1162 00001681 E874F8FFFF                  call append_to_pcb_link                         ; 将 PCB 添加到进程控制链表尾部
  1163                                  
  1164 00001686 410F22DF                    mov cr3, r15                                    ; 切换到原任务地址空间
  1165                                  
  1166 0000168A 48BE00E0FFFF7FFFFF-         mov rsi, LAPIC_START_ADDR                       ; Local APIC 的线性地址
  1166 00001693 FF                 
  1167 00001694 C78610030000000000-         mov dword [rsi + 0x310], 0
  1167 0000169D 00                 
  1168 0000169E C78600030000FE4008-         mov dword [rsi + 0x300], 0x000840fe             ; 向所有处理器发送任务/线程认领中断
  1168 000016A7 00                 
  1169                                  
  1170 000016A8 415F                        pop r15
  1171 000016AA 415E                        pop r14
  1172 000016AC 415D                        pop r13
  1173 000016AE 415C                        pop r12
  1174 000016B0 415B                        pop r11
  1175 000016B2 415A                        pop r10
  1176 000016B4 4159                        pop r9
  1177 000016B6 4158                        pop r8
  1178 000016B8 5D                          pop rbp
  1179 000016B9 5F                          pop rdi
  1180 000016BA 5E                          pop rsi
  1181 000016BB 5A                          pop rdx
  1182 000016BC 59                          pop rcx
  1183 000016BD 5B                          pop rbx
  1184 000016BE 58                          pop rax
  1185                                  
  1186 000016BF C3                          ret
  1187                                  ; ------------------------------------------------------------
  1188                                  ; syscall_procedure
  1189                                  ; 功能: 系统调用的处理过程, 处理器会自动关闭可屏蔽中断
  1190                                  ; 注意: RCX 和 R11 由处理器使用，保存 RIP 和 RFLAGS 的内容. 进入时中断是禁止状态
  1191                                  ; ------------------------------------------------------------
  1192                                  syscall_procedure: 
  1193                                  
  1194 000016C0 0F01F8                      swapgs
  1195 000016C3 654889242500000000          mov [gs:0], rsp                                 ; 保存当前 3 特权级栈指针
  1196 000016CC 65488B242584000000          mov rsp, [gs:128 + 4],                          ; 使用 TSS 的 RSP0 作为安全栈
  1197 000016D5 65FF342500000000            push qword [gs:0]                               
  1198 000016DD 0F01F8                      swapgs
  1199 000016E0 FB                          sti                                             ; 准备工作全部完成，中断和任务切换无虞
  1200                                  
  1201 000016E1 51                          push rcx 
  1202 000016E2 488B0D(08000000)            mov rcx, [rel position]
  1203 000016E9 48038CC1[69020000]          add rcx, [rcx + rax * 8 + sys_entry]            ; 得到指定的那个系统调用功能的线性地址
  1204 000016F1 FFD1                        call rcx
  1205 000016F3 59                          pop rcx 
  1206                                  
  1207 000016F4 FA                          cli 
  1208 000016F5 5C                          pop rsp                                         ; 恢复原先的 3 特权级栈指针
  1209 000016F6 480F07                      o64 sysret
  1210                                  
  1211                                  ; ------------------------------------------------------------
  1212                                  ; init
  1213                                  ; 功能: 初始化内核工作环境
  1214                                  ; ------------------------------------------------------------
  1215                                  init: 
  1216                                      ; 将 GDT 的线性地址映射到虚拟内存高端的相同位置。
  1217                                      ; 处理器不支持 64 位立即数到内存地址的操作, 所以用两条指令完成。
  1218 000016F9 48B8000001000080FF-         mov rax, UPPER_GDT_LINEAR                       ; GDT 高端线性地址
  1218 00001702 FF                 
  1219 00001703 48890425047E0000            mov qword [SDA_PHY_ADDR + 4], rax
  1220                                  
  1221 0000170B 0F011425027E0000            lgdt [SDA_PHY_ADDR + 2]                
  1222                                  
  1223                                      ; 将栈映射到高端
  1224                                      ; 64 位模式下不支持源操作数为 64 位立即数的加法操作。
  1225 00001713 48B8000000000080FF-         mov rax, UPPER_LINEAR_START
  1225 0000171C FF                 
  1226 0000171D 4801C4                      add rsp, rax 
  1227                                  
  1228                                      ; 准备让处理器从虚拟地址空间的高端开始执行（现在依然在低端执行）
  1229 00001720 48B8000000000080FF-         mov rax, UPPER_LINEAR_START
  1229 00001729 FF                 
  1230 0000172A 480105(08000000)            add [rel position], rax                         ; 更新 position 处地址, 采用相对寻址方式
  1231 00001731 488B05(08000000)            mov rax, [rel position]
  1232 00001738 4805[40170000]              add rax, .to_upper
  1233 0000173E FFE0                        jmp rax                                         ; 用 jmp 改变 rip
  1234                                  
  1235                                  .to_upper:
  1236                                      ; 接下来初始化中断描述符表 IDT，并为 32 个异常以及 224 个中断安装门描述符
  1237                                  
  1238                                      ; 为 32 个异常创建通用处理过程的中断门
  1239 00001740 4C8B0D(08000000)            mov r9, [rel position]
  1240 00001747 498D81[F30A0000]            lea rax, [r9 + general_exception_handler]
  1241 0000174E E8D6E9FFFF                  call make_interrupt_gate                        ; 在 core_utils64.asm 中实现
  1242                                  
  1243 00001753 4D31C0                      xor r8, r8  
  1244                                  .idt0:                                              ; 32 个异常
  1245 00001756 E813EAFFFF                  call mount_idt_entry                            ; 在 core_utils64.asm 中实现
  1246 0000175B 49FFC0                      inc r8 
  1247 0000175E 4983F81F                    cmp r8, 31 
  1248 00001762 7EF2                        jle .idt0
  1249                                  
  1250                                      ; 创建并安装中断门
  1251 00001764 498D81[F10A0000]            lea rax, [r9 + general_interrupt_handler]       
  1252 0000176B E8B9E9FFFF                  call make_interrupt_gate                        ; 在 core_utils64.asm 中实现
  1253                                  
  1254 00001770 41B820000000                mov r8, 32 
  1255                                  .idt1:
  1256 00001776 E8F3E9FFFF                  call mount_idt_entry                            ; 在 core_utils64.asm 中实现
  1257 0000177B 49FFC0                      inc r8 
  1258 0000177E 4981F8FF000000              cmp r8, 255
  1259 00001785 7EEF                        jle .idt1
  1260                                  
  1261 00001787 48B800E000000080FF-         mov rax, UPPER_IDT_LINEAR                       ; 中断描述符表 IDT 的高端线性地址
  1261 00001790 FF                 
  1262 00001791 48BB007E00000080FF-         mov rbx, UPPER_SDA_LINEAR                       ; 系统数据区 SDA 的高端线性地址
  1262 0000179A FF                 
  1263 0000179B 66C7430CFF0F                mov word [rbx + 0x0c], 256 * 16 - 1
  1264 000017A1 4889430E                    mov qword [rbx + 0x0e], rax                     ; 将 IDT 的线性地址和界限写入内核空间保存
  1265                                  
  1266 000017A5 0F015B0C                    lidt [rbx + 0x0c]                               ; 加载 IDT
  1267                                  
  1268 000017A9 B0FF                        mov al, 0xff                                    ; 屏蔽所有发往 8259A 主芯片的中断信号
  1269 000017AB E621                        out 0x21, al                                    ; 多处理器下不再使用 8259 芯片
  1270                                  
  1271                                      ; 在 64 位模式下显示的第一条信息!
  1272 000017AD 4C8B3D(08000000)            mov r15, [rel position]
  1273 000017B4 498D9F[36010000]            lea rbx, [r15 + welcome]
  1274 000017BB E840E8FFFF                  call put_string64                               ; 在 core_utils64.asm 中实现
  1275                                  
  1276                                      ; 安装系统服务(syscall, sysret)所需的代码段和栈段描述符
  1277 000017C0 49BF007E00000080FF-         mov r15, UPPER_SDA_LINEAR                       ; 系统数据区 SDA 的线性地址
  1277 000017C9 FF                 
  1278 000017CA 4831DB                      xor rbx, rbx 
  1279 000017CD 66418B5F02                  mov bx, [r15 + 2]                               ; 得到 GDT 界限值(表的总字节数 - 1 == 下标)
  1280 000017D2 66FFC3                      inc bx 
  1281 000017D5 49035F04                    add rbx, [r15 + 4]                              ; GDT 基址 + GDT 界限值 + 1 == 新描述符的地址
  1282                                                          
  1283                                      ; 增加新的描述符, 这里可以看书中 182 页的图, 将之前设置的四个描述符也画全了
  1284                                  
  1285                                      ; 创建 4# 描述符, 栈/数据段描述符, DPL= 0
  1286 000017D9 C703FFFF0000                mov dword [rbx], 0x0000ffff
  1287 000017DF C743040092CF00              mov dword [rbx + 4], 0x00cf9200                
  1288                                      ; 创建 5# 描述符, 兼容模式下代码段描述符, 暂不支持, 位置保留, 设为全 0
  1289 000017E6 C7430800000000              mov dword [rbx + 8], 0  
  1290 000017ED C7430C00000000              mov dword [rbx + 12], 0
  1291                                      ; 创建 6# 描述符, 栈/数据段描述符, DPL= 3
  1292 000017F4 C74310FFFF0000              mov dword [rbx + 16], 0x0000ffff
  1293 000017FB C7431400F2CF00              mov dword [rbx + 20], 0x00cff200
  1294                                      ; 创建 7# 描述符, 64 位模式的代码段描述符, DPL= 3
  1295 00001802 C74318FFFF0000              mov dword [rbx + 24], 0x0000ffff
  1296 00001809 C7431C00F8AF00              mov dword [rbx + 28], 0x00aff800
  1297                                  
  1298                                      ; 我们为每个逻辑处理器都准备一个专属数据区, 它是由每个处理器的 GS 所指向的。
  1299                                      ; 为当前处理器(BSP)准备专属数据区, 设置 GS 并安装任务状态段 TSS 的描述符
  1300                                      ; 详情见书中 348 页
  1301 00001810 B900010000                  mov rcx, 256                                    ; 专属数据区长度
  1302 00001815 E87AEFFFFF                  call core_memory_allocate                       ; 在 core_utils64.asm 中实现
  1303 0000181A 49C7450800000000            mov qword [r13 + 8], 0                          ; 当前任务的 PCB 指针, 初始化为 0
  1304 00001822 49C7451000000000            mov qword [r13 + 16], 0                         ; 将当前的处理器编号设置为 #0
  1305 0000182A 49896518                    mov [r13 + 24], rsp                             ; 当前处理器的专属栈
  1306 0000182E 498D8580000000              lea rax, [r13 + 128]                            ; TSS 开始于专属数据区内偏移为 128 的地方
  1307 00001835 E80BE9FFFF                  call make_tss_descriptor
  1308 0000183A 48897320                    mov qword [rbx + 32], rsi                       ; TSS 描述符的低 64 位
  1309 0000183E 48897B28                    mov qword [rbx + 40], rdi                       ; TSS 描述符的高 64 位
  1310                                  
  1311 00001842 664183470230                add word [r15 + 2], 48                          ; 更新 GDT 的边界值, 48 是四个段描述符和一个 TSS 描述符的字节数
  1312 00001848 410F015702                  lgdt [r15 + 2]
  1313                                  
  1314 0000184D 66B94000                    mov cx, 0x0040                                  ; TSS 描述符选择子
  1315 00001851 0F00D9                      ltr cx                                          ; 使用 ltr 指令加载 TSS 选择子
  1316                                  
  1317                                      ; 将处理器专属数据区首地址保存到当前处理器的型号专属寄存器 IA32_KERNEL_GS_BASE
  1318 00001854 B9020100C0                  mov ecx, 0xc000_0102                            ; IA32_KERNEL_GS_BASE
  1319 00001859 4C89E8                      mov rax, r13                                    ; 只用 eax
  1320 0000185C 4C89EA                      mov rdx, r13 
  1321 0000185F 48C1EA20                    shr rdx, 32                                     ; 只用 edx
  1322 00001863 0F30                        wrmsr
  1323                                  
  1324                                      ; 为快速系统调用 syscall 和 sysret 准备参数, 详细见书中 180-185
  1325 00001865 B9800000C0                  mov ecx, 0x0c0000080                            ; 指定型号专属寄存器 IA32_EFER
  1326 0000186A 0F32                        rdmsr
  1327 0000186C 0FBAE800                    bts eax, 0                                      ; 置位 SCE 位, 允许 syscall 和 sysret
  1328 00001870 0F30                        wrmsr
  1329                                  
  1330 00001872 B9810000C0                  mov ecx, 0xc0000081                             ; IA32_STAR, syscall 会自动切换代码段寄存器（CS）到内核态的代码段，其值来自 IA32_STAR
  1331 00001877 BA18002B00                  mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL ; 高 32 位, RESVD_DESC_SEL 是用户态代码段选择子（返回用户态时使用）, CORE_CODE64_SEL 是内核态代码段选择子（进入内核态时使用）
  1332 0000187C 31C0                        xor eax, eax                                    ; 低 32 位
  1333 0000187E 0F30                        wrmsr                                           
  1334                                  
  1335 00001880 B9820000C0                  mov ecx, 0xc0000082                             ; IA32_LSTAR
  1336 00001885 488B05(08000000)            mov rax, [rel position]
  1337 0000188C 488D80[C0160000]            lea rax, [rax + syscall_procedure]              ; 只用 EAX 部分
  1338 00001893 4889C2                      mov rdx, rax 
  1339 00001896 48C1EA20                    shr rdx, 32                                     ; 只用 EDX 部分
  1340 0000189A 0F30                        wrmsr
  1341                                  
  1342 0000189C B9840000C0                  mov ecx, 0xc0000084                             ; IA32_FMASK
  1343 000018A1 31D2                        xor edx, edx 
  1344 000018A3 B800770400                  mov eax, 0x00047700                             ; 将 TF, IF, DF, IOPL, AC 清零, 其他保持不变, 可看书 185 页的图
  1345 000018A8 0F30                        wrmsr
  1346                                  
  1347                                      ; 以下初始化高级可编程中断控制器 APIC。在计算机启动后，BIOS已经对 LAPIC 和 IOAPIC 做了
  1348                                      ; 初始化并创建了相关的高级配置和电源管理接口（ACPI）表项。可以从中获取多处理器和
  1349                                      ; APIC 信息。英特尔架构的个人计算机（IA-PC）从 1MB 物理内存中搜索获取；启用可扩展固件
  1350                                      ; 接口（EFI或者叫UEFI）的计算机需使用 EFI 传递的 EFI 系统表指针定位相关表格并从中获取
  1351                                      ; 多处理器和 APIC 信息。为简单起见，我们采用前一种传统的方式。请注意虚拟机的配置！
  1352                                  
  1353                                      ; ACPI 申领的内存区域已经保存在我们的系统数据区（SDA），以下将其读出。此内存区可能
  1354                                      ; 位于分页系统尚未映射的部分，故以下先将这部分内存进行一一映射（线性地址=物理地址）
  1355 000018AA 66833C25167E000000          cmp word [SDA_PHY_ADDR + 0x16], 0               ; 检查检查地址范围描述结构的数量是否为 0
  1356 000018B3 7411                        jz .acpi_err                                    ; 除非 bios 不支持 acpi, 否则不会是 0
  1357 000018B5 BE187E0000                  mov rsi, SDA_PHY_ADDR + 0x18                    ; 系统数据区, 地址范围描述结构的起始地址
  1358                                  .looking:
  1359 000018BA 837E1003                    cmp dword [rsi + 16], 3                         ; 3 代表是 ACPI 申领的内存, ACPI 的介绍可以看书中 257 页
  1360 000018BE 741B                        jz .looked
  1361 000018C0 4883C620                    add rsi, 32                                     ; 每个地址范围描述结构的长度
  1362 000018C4 E2F4                        loop .looking
  1363                                  
  1364                                  .acpi_err:
  1365 000018C6 4C8B3D(08000000)            mov r15, [rel position]
  1366 000018CD 498D9F[00000000]            lea rbx, [r15 + acpi_error]
  1367 000018D4 E827E7FFFF                  call put_string64
  1368 000018D9 FA                          cli 
  1369 000018DA F4                          hlt 
  1370                                  
  1371                                  .looked:
  1372 000018DB 488B1E                      mov rbx, [rsi]                                  ; ACPI 申领的起始物理地址
  1373 000018DE 488B4E08                    mov rcx, [rsi + 8]                              ; ACPI 申领的内存大小, 以字节计
  1374 000018E2 4801D9                      add rcx, rbx                                    ; ACPI 申领的内存上边界
  1375 000018E5 48C7C200F0FFFF              mov rdx, 0xffff_ffff_ffff_f000                  ; 用于生成页地址的掩码
  1376                                  
  1377                                  .mapping:
  1378 000018EC 4989DD                      mov r13, rbx                                    ; 映射的线性地址
  1379 000018EF 4889D8                      mov rax, rbx 
  1380 000018F2 4821D0                      and rax, rdx 
  1381 000018F5 4883C807                    or rax, 0x07                                    ; 将地址设置上属性
  1382 000018F9 E87AEEFFFF                  call mapping_laddr_to_page
  1383 000018FE 4881C300100000              add rbx, 0x1000
  1384 00001905 4839CB                      cmp rbx, rcx 
  1385 00001908 7EE2                        jle .mapping
  1386                                  
  1387                                      ; 从物理地址 0x60000(常规内存顶端) 开始, 搜索系统描述指针结构(RSDP)
  1388 0000190A BB00000600                  mov rbx, 0x60000
  1389 0000190F 48B952534420505452-         mov rcx, "RSD PTR "                             ; 结构起始标记
  1389 00001918 20                 
  1390                                  
  1391                                  .searc:
  1392 00001919 48390B                      cmp qword [rbx], rcx
  1393 0000191C 740F                        je .finda 
  1394 0000191E 4883C310                    add rbx, 16                                     ; 结构的标记位于 16 字节边界处, 也就是说可以以 16 字节为单位搜索
  1395 00001922 4881FBF0FF0F00              cmp rbx, 0xffff0                                ; 搜索上边界
  1396 00001929 7CEE                        jl .searc 
  1397 0000192B EB99                        jmp .acpi_err                                   ; 未找到 RSDP, 报错停机
  1398                                  
  1399                                  .finda:
  1400                                      ; RSDT 和 XSDT 都指向 MADT, 但 RSDT 给出的是 32 位物理地址, 而 XDST 给出 64 位物理地址。
  1401                                      ; 只有 VCPI 2.0 及更高版本才有 XSDT。典型地, VBox 支持 ACPI 2.0 而 Bochs 仅支持 1.0
  1402                                      ; 这个可以看书中 274 往后的几个图
  1403 0000192D 807B0F02                    cmp byte [rbx + 15], 2                          ; 检测 ACPI 的版本是否为 2
  1404 00001931 752B                        jne .vcpi_1
  1405 00001933 488B5B18                    mov rbx, [rbx + 24]                             ; 得到扩展的系统描述表 XSDT 的物理地址
  1406                                  
  1407                                      ; 以下开始在 XSDT 中遍历搜索多 APIC 描述符表, 即 MADT
  1408 00001937 4831FF                      xor rdi, rdi                                    ; 下面要使用 rdi, 尽管 edi 赋值了, 但还是要清空 rdi
  1409 0000193A 8B7B04                      mov edi, [rbx + 4]                              ; 得到 XSDT 长度, 以字节计
  1410 0000193D 4801DF                      add rdi, rbx                                    ; 计算上边界的物理地址
  1411 00001940 4883C324                    add rbx, 36                                     ; XSDT 尾部数组的物理地址
  1412                                  .madt0:
  1413 00001944 4C8B1B                      mov r11, [rbx]             
  1414 00001947 41813B41504943              cmp dword [r11], "APIC"                         ; MADT 表的标记
  1415 0000194E 7436                        je .findm                       
  1416 00001950 4883C308                    add rbx, 8                                      ; 下一个元素
  1417 00001954 4839FB                      cmp rbx, rdi  
  1418 00001957 7CEB                        jl .madt0
  1419 00001959 E968FFFFFF                  jmp .acpi_err
  1420                                  
  1421                                      ; 以下处理 VCPI 1.0, 在 RSDT 中遍历搜索 MADT
  1422                                  .vcpi_1:
  1423 0000195E 8B5B10                      mov ebx, [rbx + 16]                             ; 得到根系统描述符表 RSDT 的物理地址
  1424 00001961 678B7B04                    mov edi, [ebx + 4]                              ; 得到 RSDT 的长度, 以字节计
  1425 00001965 01DF                        add edi, ebx                                    ; 上边界物理地址
  1426 00001967 83C324                      add ebx, 36                                     ; 尾部数组的物理地址
  1427 0000196A 4D31DB                      xor r11, r11 
  1428                                  .madt1:
  1429 0000196D 67448B1B                    mov r11d, [ebx]
  1430 00001971 41813B41504943              cmp dword [r11], "APIC"                         ; MADT 表的标记
  1431 00001978 740C                        je .findm
  1432 0000197A 83C304                      add ebx, 4
  1433 0000197D 39FB                        cmp ebx, edi 
  1434 0000197F 7CEC                        jl .madt1
  1435 00001981 E940FFFFFF                  jmp .acpi_err
  1436                                  
  1437                                  .findm:
  1438                                      ; 此时, r11 是 MADT 的物理地址
  1439 00001986 418B5324                    mov edx, [r11 + 36]                             ; 预置的 Local APIC 物理地址
  1440 0000198A 8915(28010000)              mov [rel lapic_addr], edx
  1441                                  
  1442                                      ; 以下开始遍历系统中的逻辑处理器的 LAPIC ID 和 I/O APIC
  1443 00001990 4C8B3D(08000000)            mov r15, [rel position]
  1444 00001997 4D8DBF[28000000]            lea r15, [r15 + cpu_list]
  1445                                  
  1446 0000199E 4831FF                      xor rdi, rdi 
  1447 000019A1 418B7B04                    mov edi, [r11 + 4]                              ; MADT 的长度
  1448 000019A5 4C01DF                      add rdi, r11                                    ; 上边界物理地址
  1449 000019A8 4983C32C                    add r11, 44                                     ; 指向 MADT 尾部中断控制器结构列表
  1450                                  .enumd:
  1451 000019AC 41803B00                    cmp byte [r11], 0                               ; 0 代表 Local APIC
  1452 000019B0 7408                        je .l_apic
  1453 000019B2 41803B01                    cmp byte [r11], 1                               ; 1 代表 I/O APIC
  1454 000019B6 741B                        je .ioapic
  1455 000019B8 EB2D                        jmp .m_end 
  1456                                  .l_apic:
  1457 000019BA 41837B0400                  cmp dword [r11 + 4], 0                          ; Local APIC flag
  1458 000019BF 7426                        jz .m_end
  1459 000019C1 418A4303                    mov al, [r11 + 3]                                ; 获取 Local APIC ID
  1460 000019C5 418807                      mov [r15], al                                   ; 保存 Local APIC ID 到 cpu_list
  1461 000019C8 49FFC7                      inc r15
  1462 000019CB FE05(27000000)              inc byte [rel num_cpus]                         ; 原来 cpu 数量是这么统计出来的
  1463 000019D1 EB14                        jmp .m_end
  1464                                  .ioapic:
  1465 000019D3 418A4302                    mov al, [r11 + 2]                               ; 取出 I/O APIC ID
  1466 000019D7 8805(30010000)              mov [rel ioapic_id], al                         ; 保存 I/O APIC ID
  1467 000019DD 418B4304                    mov eax, [r11 + 4]                              ; 取出 I/O APIC 物理地址
  1468 000019E1 8905(2C010000)              mov [rel ioapic_addr], eax                      ; 保存 I/O APIC ID 物理地址
  1469                                  .m_end:
  1470 000019E7 4831C0                      xor rax, rax 
  1471 000019EA 418A4301                    mov al, [r11 + 1]
  1472 000019EE 4901C3                      add r11, rax                                    ; 计算出下一个中断控制结构列表的物理地址
  1473 000019F1 4939FB                      cmp r11, rdi 
  1474 000019F4 7CB6                        jl .enumd
  1475                                  
  1476                                      ; 遍历完成, 映射物理地址到内核指定区域
  1477                                  
  1478                                      ; Local APIC -> LAPIC_START_ADDR
  1479 000019F6 49BD00E0FFFF7FFFFF-         mov r13, LAPIC_START_ADDR
  1479 000019FF FF                 
  1480 00001A00 4831C0                      xor rax, rax 
  1481 00001A03 8B05(28010000)              mov eax, [rel lapic_addr]                       ; 取出 LAPIC 的物理地址
  1482 00001A09 83C81F                      or eax, 0x1f                                    ; 设置属性, PCD=PWT=U/S=R/W=P=1, 强不可缓存
  1483 00001A0C E867EDFFFF                  call mapping_laddr_to_page
  1484                                      ; I/O APIC -> IOAPIC_START_ADDR
  1485 00001A11 49BD00D0FFFF7FFFFF-         mov r13, IOAPIC_START_ADDR
  1485 00001A1A FF                 
  1486 00001A1B 4831C0                      xor rax, rax 
  1487 00001A1E 8B05(2C010000)              mov eax, [rel ioapic_addr]
  1488 00001A24 83C81F                      or eax, 0x1f  
  1489 00001A27 E84CEDFFFF                  call mapping_laddr_to_page
  1490                                  
  1491                                      ; 以下测量当前处理器 1ms 内经历了多少时钟周期, 作为后续的定时基准, 详情见书中284 页
  1492 00001A2C 48BE00E0FFFF7FFFFF-         mov rsi, LAPIC_START_ADDR
  1492 00001A35 FF                 
  1493                                  
  1494 00001A36 C78620030000000001-         mov dword [rsi + 0x320], 0x10000                ; 定时器的本地向量表入口寄存器, 单次击发模式
  1494 00001A3F 00                 
  1495 00001A40 C786E00300000B0000-         mov dword [rsi + 0x3e0], 0x0b                   ; 定时器的分频配置寄存器: 1 分频
  1495 00001A49 00                 
  1496                                  
  1497 00001A4A B00B                        mov al, 0x0b                                    ; RTC 寄存器 B                                     
  1498 00001A4C 0C80                        or al, 0x80                                     ; 阻断 NMI
  1499 00001A4E E670                        out 0x70, al            
  1500 00001A50 B052                        mov al, 0x52                                    ; 设置寄存器 B, 开发周期性中断, 开放更新结束后中断, BCD 码, 24 小时制
  1501 00001A52 E671                        out 0x71, al 
  1502                                  
  1503 00001A54 B08A                        mov al, 0x8a                                    ; CMOS 寄存器 A
  1504 00001A56 E670                        out 0x70, al 
  1505 00001A58 B02D                        mov al, 0x2d                                    ; 32 kHz, 125 ms 的周期性中断
  1506 00001A5A E671                        out 0x71, al                                    ; 写回 CMOS 寄存器 A
  1507                                  
  1508 00001A5C B08C                        mov al, 0x8c
  1509 00001A5E E670                        out 0x70, al 
  1510 00001A60 E471                        in al, 0x71                                     ; 读寄存器 C
  1511                                  .w0:
  1512 00001A62 E471                        in al, 0x71 
  1513 00001A64 480FBAE006                  bt rax, 6                                       ; 更新周期结束中断已发生
  1514 00001A69 73F7                        jnc .w0 
  1515 00001A6B C78680030000FFFFFF-         mov dword [rsi + 0x380], 0xffff_ffff            ; 定时器初始计数寄存器: 置初始值并开始计数
  1515 00001A74 FF                 
  1516                                  .w1:
  1517 00001A75 E471                        in al, 0x71     
  1518 00001A77 480FBAE006                  bt rax, 6   
  1519 00001A7C 73F7                        jnc .w1 
  1520 00001A7E 8B9690030000                mov edx, [rsi + 0x390],                         ; 定时器初始计数寄存器: 读当前计数值
  1521                                  
  1522 00001A84 B8FFFFFFFF                  mov eax, 0xffff_ffff
  1523 00001A89 29D0                        sub eax, edx 
  1524 00001A8B 31D2                        xor edx, edx 
  1525 00001A8D BB7D000000                  mov ebx, 125                                    ; 125ms
  1526 00001A92 F7F3                        div ebx                                         ; 结果存在 eax 中, 即当前处理器在 1ms 内的时钟数
  1527                                  
  1528 00001A94 8905(32010000)              mov [rel clocks_1ms], eax                       ; 记录
  1529                                  
  1530 00001A9A B00B                        mov al, 0x0b                                    ; RTC 寄存器 B
  1531 00001A9C 0C80                        or al, 0x80                                     ; 阻断 NMI
  1532 00001A9E E670                        out 0x70, al 
  1533 00001AA0 B012                        mov al, 0x12                                    ; 设置寄存器 B, 只允许更新周期结束中断
  1534 00001AA2 E671                        out 0x71, al 
  1535                                  
  1536                                      ; 安装用于任务切换的中断处理过程
  1537 00001AA4 4C8B0D(08000000)            mov r9, [rel position]
  1538 00001AAB 498D81[9E0E0000]            lea rax, [r9 + new_task_notify_handler]         ; 得到中断处理过程的线性地址
  1539 00001AB2 E872E6FFFF                  call make_interrupt_gate                        
  1540                                  
  1541 00001AB7 FA                          cli 
  1542 00001AB8 41B8FE000000                mov r8, 0xfe                                    ; 任务切换使用的中断向量, 数越大, 优先级越高
  1543 00001ABE E8ABE6FFFF                  call mount_idt_entry
  1544 00001AC3 FB                          sti 
  1545                                  
  1546                                      ; 以下安装时间片到期中断处理过程
  1547 00001AC4 4C8B0D(08000000)            mov r9, [rel position]
  1548 00001ACB 498D81[D90D0000]            lea rax, [r9 + time_slice_out_handler]          ; 得到中断处理过程的线性地址
  1549 00001AD2 E852E6FFFF                  call make_interrupt_gate            
  1550                                  
  1551 00001AD7 FA                          cli 
  1552 00001AD8 41B8FD000000                mov r8, 0xfd 
  1553 00001ADE E88BE6FFFF                  call mount_idt_entry
  1554 00001AE3 FB                          sti
  1555                                  
  1556                                      ; 以下安装系统管理中断处理过程
  1557 00001AE4 4C8B0D(08000000)            mov r9, [rel position]
  1558 00001AEB 498D81[EC0B0000]            lea rax, [r9 + system_management_handler]
  1559 00001AF2 E832E6FFFF                  call make_interrupt_gate
  1560                                  
  1561 00001AF7 FA                          cli 
  1562 00001AF8 41B8FC000000                mov r8, 0xfc 
  1563 00001AFE E86BE6FFFF                  call mount_idt_entry
  1564 00001B03 FB                          sti 
  1565                                  
  1566                                      ; 以下初始化应用处理器 AP, 先将初始化代码复制到物理内存的选定位置
  1567 00001B04 488B35(08000000)            mov rsi, [rel position]
  1568 00001B0B 488DB6[00000000]            lea rsi, [rsi + section.ap_init_block.start]    ; 源
  1569 00001B12 BF00F00000                  mov rdi, AP_START_UP_ADDR                       ; 目的地
  1570 00001B17 B983000000                  mov rcx, ap_init_tail - ap_init                 ; 次数
  1571 00001B1C FC                          cld 
  1572 00001B1D F3A4                        repe movsb 
  1573                                  
  1574                                      ; 所有处理器都应该在初始化期间递增应答计数值
  1575 00001B1F FE05(31010000)              inc byte [rel ack_cpus]                         ; BSP 自己的应答计数值
  1576                                  
  1577                                      ; 给其它处理器发送 INIT IPI 和 SIPI, 命令他们初始化自己
  1578 00001B25 48BE00E0FFFF7FFFFF-         mov rsi, LAPIC_START_ADDR
  1578 00001B2E FF                 
  1579 00001B2F C78610030000000000-         mov dword [rsi + 0x310], 0
  1579 00001B38 00                 
  1580 00001B39 C7860003000000450C-         mov dword [rsi + 0x300], 0x000c4500             ; 先发送 INIT IPI
  1580 00001B42 00                 
  1581 00001B43 C786000300000F460C-         mov dword [rsi + 0x300], (AP_START_UP_ADDR >> 12) | 0x000c4600      ; start up IPI
  1581 00001B4C 00                 
  1582 00001B4D C786000300000F460C-         mov dword [rsi + 0x300], (AP_START_UP_ADDR >> 12) | 0x000c4600      ; 保险起见发两次
  1582 00001B56 00                 
  1583                                  
  1584 00001B57 8A05(27000000)              mov al, [rel num_cpus]
  1585                                  
  1586                                  .wcpus:
  1587 00001B5D 3A05(31010000)              cmp al, [rel ack_cpus]
  1588 00001B63 75F8                        jne .wcpus                                      ; 等待所有应用处理器的应答
  1589                                  
  1590                                      ; 显示已应答的处理器数量
  1591 00001B65 4C8B3D(08000000)            mov r15, [rel position]
  1592                                  
  1593 00001B6C 4D31C0                      xor r8, r8 
  1594 00001B6F 448A05(31010000)            mov r8b, [rel ack_cpus]
  1595 00001B76 498D9F[69010000]            lea rbx, [r15 + buffer]
  1596 00001B7D E8DEEDFFFF                  call bin64_to_dec
  1597 00001B82 E879E4FFFF                  call put_string64
  1598                                  
  1599 00001B87 498D9F[58010000]            lea rbx, [r15 + cpu_init_ok]
  1600 00001B8E E86DE4FFFF                  call put_string64
  1601                                  
  1602                                      ; 系统管理中断的中断源
  1603 00001B93 48BF00D0FFFF7FFFFF-         mov rdi, IOAPIC_START_ADDR
  1603 00001B9C FF                 
  1604 00001B9D C70714000000                mov dword [rdi], 0x14                           ; 对应 8254 定时器。
  1605 00001BA3 C74710FC000000              mov dword [rdi + 0x10], 0x000000fc              ; 不屏蔽；物理模式；固定模式；向量 0xfc
  1606 00001BAA C70715000000                mov dword [rdi], 0x15
  1607 00001BB0 C7471000000000              mov dword [rdi + 0x10], 0x00000000              ; Local APIC ID：0
  1608                                  
  1609                                      ; 以下创建进程
  1610 00001BB7 41B832000000                mov r8, 50
  1611 00001BBD E877F9FFFF                  call create_process
  1612                                  
  1613 00001BC2 E927EFFFFF                  jmp ap_to_core_entry.do_idle                    ; 去处理器集结休息区
  1614                                  
  1615                                  section ap_init_block vstart=0                      ; vstart 改变段内汇编地址, 让其都相对于段起始, 即这段代码是浮动的
  1616                                  
  1617                                      bits 16                                         ; 应用处理器 AP 从实模式开始
  1618                                  
  1619                                  ap_init:
  1620 00000000 B8000F                      mov ax, AP_START_UP_ADDR >> 4
  1621 00000003 8ED8                        mov ds, ax 
  1622                                  
  1623                                      SET_SPIN_LOCK al, byte [lock_var]               ; 自旋知道获得锁
    49                              <1>  %%spin_lock:
    50 00000005 803E[8200]00        <1>  cmp %2, 0
    51 0000000A 7404                <1>  je %%get_lock
    52 0000000C F390                <1>  pause
    53 0000000E EBF5                <1>  jmp %%spin_lock
    54                              <1>  %%get_lock:
    55 00000010 B001                <1>  mov %1, 1
    56 00000012 8606[8200]          <1>  xchg %1, %2
    57 00000016 3C00                <1>  cmp %1, 0
    58 00000018 75EB                <1>  jne %%spin_lock
  1624                                  
  1625 0000001A B8E007                      mov ax, SDA_PHY_ADDR >> 4                       ; 切换到系统数据区
  1626 0000001D 8ED8                        mov ds, ax 
  1627                                  
  1628 0000001F 0F01160200                  lgdt [2]                                        ; 加载描述符寄存器 GDTR, 实模式下只加载 6 字节的内容, 界限值 2 字节, 基地址 4 字节, 描述符已经填好
  1629                                  
  1630 00000024 E492                        in al, 0x92                                     ; 南桥芯片内端口
  1631 00000026 0C02                        or al, 0000_0010B
  1632 00000028 E692                        out 0x92, al                                    ; 打开 A20
  1633                                  
  1634 0000002A FA                          cli                                             ; 中断机制尚未工作
  1635                                  
  1636 0000002B 0F20C0                      mov eax, cr0
  1637 0000002E 6683C801                    or eax, 1
  1638 00000032 0F22C0                      mov cr0, eax                                    ; 设置 PE 位
  1639                                  
  1640                                      ; 进入保护模式...
  1641 00000035 EA[3AF0]0800                jmp 0x0008: AP_START_UP_ADDR + .flush           ; 0x0008 是保护模式下的代码段描述符的选择子, 清流水线并串行化处理器
  1642                                  
  1643                                      [bits 32]
  1644                                  .flush:
  1645 0000003A B810000000                  mov eax, 0x0010                                 ; 加载数据段(4gb)选择子
  1646 0000003F 8ED0                        mov ss, eax                                     ; 加载堆栈段(4gb)选择子
  1647 00000041 BC007E0000                  mov esp, 0x7e00                                 ; 堆栈指针
  1648                                  
  1649                                      ; 令 CR3 寄存器指向 4 级表头(保护模式下的 32 位 CR3)
  1650 00000046 B800A00000                  mov eax, PML4_PHY_ADDR                          ; PCD = PWT = 0
  1651 0000004B 0F22D8                      mov cr3, eax 
  1652                                  
  1653                                      ; 开启物理地址扩展 PAE
  1654 0000004E 0F20E0                      mov eax, cr4 
  1655 00000051 0FBAE805                    bts eax, 5
  1656 00000055 0F22E0                      mov cr4, eax 
  1657                                  
  1658                                      ; 设置型号专属寄存器 IA32_EFER.LME，允许 IA_32e 模式
  1659 00000058 B9800000C0                  mov ecx, 0x0c0000080                            ; 指定型号专属寄存器 IA32_EFER
  1660 0000005D 0F32                        rdmsr 
  1661 0000005F 0FBAE808                    bts eax, 8                                      ; 设置 LME 位
  1662 00000063 0F30                        wrmsr
  1663                                  
  1664                                      ; 开启分页功能
  1665 00000065 0F20C0                      mov eax, cr0 
  1666 00000068 0FBAE81F                    bts eax, 31                                     ; 置位 CR0.PG
  1667 0000006C 0F22C0                      mov cr0, eax 
  1668                                  
  1669                                      ; 进入 64 位模式
  1670 0000006F EA[76F00000]1800            jmp CORE_CODE64_SEL:AP_START_UP_ADDR + .to64
  1671                                  .to64:
  1672                                      bits 64
  1673                                  
  1674                                      ; 转入内核中继续初始化, 使用高端线性地址
  1675 00000076 48BB-                       mov rbx, UPPER_CORE_LINEAR + ap_to_core_entry
  1675 00000078 [CB0902000080FFFF] 
  1676 00000080 FFE3                        jmp rbx 
  1677                                  
  1678 00000082 00                      lock_var db 0
  1679                                  
  1680                                  ap_init_tail:
  1681                                  
  1682                                  section core_tail
  1683                                  core_end:
