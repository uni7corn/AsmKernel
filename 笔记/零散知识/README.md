## 软件中断指令 int
- int 0x13: x86 架构下的 BIOS 磁盘服务中断, 用于在实模式下执行底层磁盘操作(如读取、写入、格式化等)。它是早期操作系统和引导加载程序直接访问硬件的关键接口。
- int 0x10: 是 x86 实模式下的 BIOS 视频服务中断, 用于控制文本/图形显示、光标、颜色等。它是早期操作系统和引导程序直接操作屏幕的核心接口。

## cli
禁用可屏蔽中断(将 CPU 的 IF 标志位清零), CPU 不再响应外部硬件中断(如键盘、定时器、磁盘等), 但不可屏蔽中断(NMI)和异常(如除零)仍会被处理。
## hlt
暂停 CPU 执行, 直到下一个中断发生。CPU 进入低功耗状态, 停止取指和执行, 但保持寄存器和内存状态。
- 唤醒条件: 
    - 任何不可屏蔽中断(NMI)或已启用的可屏蔽中断(需 IF=1)。
    - 复位信号(如硬件重启)。

## nasm 中的伪指令
- equ: 用于定义符号常量。`SDA_PHY_ADDR equ 0x00007e00` 类似 C 语言中的 `#define SDA_PHY_ADDR 0x00007e00`
- times: 用于 重复填充 指定次数的字节、字或双字, times 重复次数 填充内容


## nasm 中的 $ 与 $$
- `$`: 当前地址
- `$$`: 当前段起始地址, 如 `SECTION  mbr vstart=0x00007c00` 是设置当前段起始地址为 0x00007c00

## `xor edx, edx` 与 `or edx, edx`
- `xor edx, edx`: 将 edx 寄存器 清零, 同时设置标志位(ZF=1, SF=0, CF=0, OF=0)
- `or edx, edx`: 对 edx 自身做 按位或运算(edx | edx), 不改变寄存器值, 仅设置标志位

## 0x0d, 0x0a
回车符和换行符的 ASCII 编码

## cpuid
cpuid 是 x86 架构的 CPU 识别指令, 用于查询处理器支持的功能、型号、扩展特性等信息。

## lgdt
将 GDT 的基地址加载到 GDTR（GDT 基地址寄存器）中，从而让 CPU 可以通过 GDTR 访问 GDT

## in 与 out
- in destination, source: source -> destination
    - destination 是目标寄存器，用于存储从端口读取的数据。可以是AL、AX或EAX，分别用于读取8位、16位或32位数据。
    - source 是端口号，可以是直接的数值（如0x92）或存储在 dx 寄存器中的值。
- out destination, source: source -> destination
    - destination 是端口号，可以是直接的数值（如0x92）或存储在DX寄存器中的值。
    - source 是要写入端口的数据，可以是AL、AX或EAX，分别用于写入8位、16位或32位数据。
- 端口号: 硬件设备的端口号通常在设备的技术手册或数据手册中明确列出。

## 显存
显存是计算机显卡中用于存储屏幕显示数据的内存区域。它直接与显卡的硬件（如显示控制器）相连，用于存储屏幕上显示的图像数据或文本数据。

- 在文本模式下: 屏幕显示的是字符而不是像素。屏幕通常被划分为一个字符网格，例如常见的 80 列 × 25 行 的布局。这种布局意味着屏幕上可以显示 2000 个字符。每个字符占用 2 个字节, 第一个字节存储字符的 ASCII 码。第二个字节存储字符的显示属性（如颜色、闪烁等）。对于彩色文本模式，显存的起始地址是 0xb800:0000。对于单色文本模式，显存的起始地址是 0xb000:0000。