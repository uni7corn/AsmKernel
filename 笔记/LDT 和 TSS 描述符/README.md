在x86架构中，你自己安装的IDT表中的中断触发方式和`int xx`软中断的作用，需要结合中断类型和运行模式来理解，具体可以分为以下几种情况：


### 一、自己安装的IDT中中断的触发方式
你通过代码初始化的IDT（中断描述符表）包含了对**异常、硬件中断、软件中断**的处理入口，这些中断的触发方式各有不同：

1. **异常（Exception）：由CPU自动触发**  
   你代码中初始化的0~31号向量（`idt0`循环处理的部分）对应CPU的异常（如除零、页错误、调试异常等）。这些中断由CPU在执行指令时自动检测并触发：  
   - 例如执行`div 0`（除以零）时，CPU会自动产生向量0的异常，查找IDT中0号条目对应的`general_exception_handler`处理程序。  
   - 再如访问未映射的内存时，CPU会触发页错误（向量14），进入对应的异常处理逻辑。

2. **硬件中断（Hardware Interrupt）：由外部设备触发**  
   你代码中通过`init_8259`初始化了8259中断控制器，后续`r8`从0x20开始循环处理的中断（通常对应8259映射的外部设备中断），由硬件设备触发：  
   - 例如键盘按下时，键盘控制器会通过8259向CPU发送中断请求，8259会将中断向量号（如0x21，取决于你重映射的设置）通知CPU，CPU再到IDT中查找对应`general_8259ints_handler`处理程序。  
   - 其他设备（如定时器、硬盘）触发中断的流程类似，均通过中断控制器（8259或APIC）向CPU发送请求。

3. **软件中断（Software Interrupt）：通过`int xx`指令主动触发**  
   对于IDT中已注册的任意向量号（包括0~255），都可以通过`int xx`指令主动触发（xx为向量号）。例如：  
   - 执行`int 0x30`时，CPU会直接查找IDT中0x30号条目，跳转到你注册的`general_interrupt_handler`处理程序。  
   - 操作系统常利用这种方式实现系统调用（如早期Linux用`int 0x80`作为系统调用入口）。


### 二、`int xx`软中断不只针对BIOS
`int xx`是x86架构的通用软件中断指令，其作用完全由当前IDT中对应的条目决定，并非只属于BIOS：

1. **实模式下的BIOS中断**：  
   在实模式（如开机初期），IDT由BIOS初始化，此时`int xx`（如`int 0x10`、`int 0x13`）确实会触发BIOS提供的服务（显示、磁盘操作等）。这是因为BIOS在实模式下预先注册了这些中断的处理程序。

2. **保护模式/长模式下的自定义中断**：  
   当你进入保护模式（或长模式，如你代码中64位环境）并重新初始化IDT后，原BIOS的中断处理程序会被覆盖。此时`int xx`触发的是你在IDT中注册的处理程序：  
   - 例如你可以将`int 0x80`注册为系统调用入口，用户态程序执行`int 0x80`时，会直接进入内核态的处理逻辑（而非BIOS）。  
   - 甚至可以重新定义0~31号异常的处理程序（覆盖CPU默认行为，但不建议随意修改关键异常）。


### 总结
- 你安装的IDT中的中断可通过**CPU异常（自动）、硬件设备（外部触发）、`int xx`指令（主动调用）** 三种方式触发。  
- `int xx`是通用指令，其功能由当前IDT决定：实模式下对应BIOS服务，操作系统接管后则对应自定义的处理逻辑（如系统调用、内核功能）。