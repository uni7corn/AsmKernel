## 前言
希望用寥寥几笔就勾勒出一个操作系统的知识框架, 顺着这个框架你可以从一头推导到另一头. 在我们各自日后的学习, 工作中实际上也是在修修补补这个知识框架, 事实上, 在计算机领域你能见到的任何领域都或多或少和操作系统有联系, 毕竟是计算机的基石. 希望我不要讲的太复杂, 讲的越简单越好.

这样做有一个好处, 不会涉及太多细节, 尽管你是一个小白也能看懂, 坏处是如果你想清除里面的细节, 仍需要自己写一写, 感悟一下. 所幸本项目就照着李忠前辈 `x86汇编语言-编写64位多处理器多线程操作系统` 实现了一个操作系统, 并且写了很多注释, 应该能给你参考.

## 从主引导程序(MBR)开始
当计算机启动时, BIOS(基本输入输出系统)会执行以下步骤:
- 自检: BIOS 首先会对硬件进行自检, 检查硬件是否正常工作. 
- 查找启动设备: BIOS 会按照启动顺序(通常是硬盘、光驱、USB 等)查找启动设备. 
- 加载 MBR: 如果找到启动设备(例如硬盘), BIOS 会从硬盘的第 0 号扇区(LBA 0)读取主引导记录(MBR). MBR 通常位于硬盘的第 0 号扇区, 大小为 512 字节. 读取后检查 BIOS 是否合格, 如果合格就将它加载到内存的 0x7c00 处, 开始执行.

**看完这段你可能疑惑, BIOS 是什么, 怎么实现的, 我们不是从 0 开始吗, 怎么已经有了一个 BIOS 了?**

BIOS(Basic Input/Output System, 基本输入输出系统)通常是硬件制造商提供的, 硬件厂商负责对其优化, 毕竟做了硬件总得提供接口让别人使用吧. 

所以我们的首要任务是写一个引导程序, 为什么是引导, 因为 BIOS 只会读取 512 字节(一个扇区), 读取后检查最后两个字节是不是 `55 AA`, 这个 `55 AA` 应该能算作是引导程序的签名, 告诉 BIOS 我是一个合格的引导程序. 然后 BIOS 才会将它加载到内存的 0x7c00 处开始执行. 那 512 字节够干什么呢, 很可能连现在的一个 hello world 程序都装不下. 所以引导扇区的首要任务是加载处于硬盘其他位置的数据和代码, 然后跳转过去执行. 综上, 在 MBR 我们主要做的是, 读取硬盘中内核加载程序(LDR)到你指定的内存. 

**聪明的你不禁又要提问: 为什么不直接加载内核程序, 还有费事搞一个什么内核加载程序(LDR)出来?**

在 MBR, 内核刚刚启动, 我们仍处于 16 位实模式下, 现在处理器为了兼容性, 既能跑 16 位程序, 也能跑 32 位, 64 位程序. 我们需要一步步启用, 才能从 16 模式到 64 位. 而内核程序模块, 我们只想让它实现内核的功能, 而不实现额外的加载过程, 以降低耦合, 为此才有了内核加载程序(LDR)

## 内核加载程序(LDR)都做了什么
在 LDR 中我们的任务是最终进入 64 位模式(IA-32e 模式), 为此我们要先进入 32 位保护模式, 然后才能进入 64 位模式. 而 LDR 首要任务就是实现这个. 

**那么为什么 16 位叫实模式, 32 位又叫保护模式呢, 实模式实在哪, 保护模式又保护了什么?**

这个问题用一段话就能将清楚了, 在我们直接的思维中, 对于内存的访问, 当然是指一就是一, 说二就是二, 我们要访问, 使用某块内存直接输入它的地址就行了, 输入了就直接能获取, 不过做一个我们自己的玩具, 这样当然可以. 不过要是一个实际使用的产品, 设想这样一种情况: 你双击点击运行了某款国民级社交软件, 突然, 你的电脑系统直接崩溃了, 然后怎么都打不开, 卧槽, 血压已经上来了, 用手机查新闻后发现, 原来是这个互联网公司裁员裁到了真正干活的人, 然后后面的人写代码时, 不小心访问并修改了引导扇区程序的代码, 将 `55 AA` 写成了 `55 66`, 那就悲剧了, BIOS 不认你这个 MBR. 为了避免类似情况发生, 我们必须要想一种办法, 在所有要访问内存的地方做检查, 并划分特权, 只用最核心的内核程序可以完全访问所有内存, 而你下载的应用程序, 一般情况下不允许他们访问或修改内核所处的内存. 为此, 我们创建 GDT, 里面存放了一个个描述符, 描述符就记录访问哪些地址需要什么权限, 并且段寄存器(如 cs, ss)不再直接表示段基址, 而是作为选择子, 当你要访问内存时必须是选择子加偏移的形式, 这样 cs 是你当前描述符的选择子, 你要跳转时要输入目标地址描述符的选择子和偏移, 然后提交给处理器, 检查你是否有这个权限访问目标内存地址. 

所以在 ldr 中我们找个位置创建 gdt 表, 再将 gdt 表的地址加载到 GDTR 寄存器, 然后做公式化流程(打开处理器的第 21 根地址线 A20, 设置控制寄存器 CR0 的 PE 位), 将处理器从实模式切换到保护模式, 在这之后, 我们再将内核程序从硬盘中加载到内存中你自定义的位置, 设置并填写四级页表, 将 4 级头表的物理地址存入 cr3 寄存器, 然后公式化流程(开启物理扩展 PAE, 设置型号专属寄存器 IA32_EFER.LME, 允许 IA_32e 模式, 开启分页功能), 最后以远跳转的方式进入 64 位代码段(段描述符需设置 L=1 标志，表明是 64 位段), 至此我们以 64 位的王者之资进入内核.

## 进入内核后, 我们都实现了哪些